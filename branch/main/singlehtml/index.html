

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum Autumn School 2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
      <link rel="stylesheet" type="text/css" href="_static/sphinx_lesson.css" />
      <link rel="stylesheet" type="text/css" href="_static/term_role_formatting.css" />
      <link rel="stylesheet" type="text/css" href="_static/sphinx_rtd_theme_ext_color_contrast.css" />
      <link rel="stylesheet" type="text/css" href="_static/overrides.css" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js"></script>
      <script src="_static/doctools.js"></script>
      <script src="_static/sphinx_highlight.js"></script>
      <script src="_static/clipboard.min.js"></script>
      <script src="_static/copybutton.js"></script>
      <script src="_static/minipres.js"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="_static/togglebutton.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script data-domain="enccs.github.io/qas2024" defer="defer" src="https://plausible.io/js/script.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            Quantum Autumn School 2024
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Setup</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-setup">Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 1</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-welcome">Welcome and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-hpc_qc">Integration of High Performance Computing and Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-helmi">Introduction to Helmi</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-notebooks/GHZ_Estimator_Attendees">Tutorial - Introduction to Helmi</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-qaoa_vqe_intro">Introduction to variational quantum algorithms: VQE and QAOA</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-notebooks/QAS2024_QAOA_exercise">Tutorial - Variational Quantum Algorithms</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 2</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-notebooks/Decoding_excercise">Tutorial - MAP Decoding Exercise</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-notebooks/css_code_steane">Tutorial - Fault-Tolerant Quantum Computing with CSS codes</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-notebooks/surface_code_threshold">Tutorial - Estimating the Surface Code Threshold</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-qmc_fin">Quantum Monte Carlo and quantum finance</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-notebooks/option_pricing">Pricing a European call option on a quantum computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-notebooks/option_pricing_tutorial">Tutorial - Pricing a European call option using quantum computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-qsip">QSIP - Quantum Sweden Innovation Platform</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 3</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-notebooks/flight_scheduling_optimization_qaoa">Tutorial - Solving Flight Scheduling Optimization using QAOA</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-qwalks">Quantum walks on quantum computers</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-tergite-overview">Tergite overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-cos">Distributed Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-qelm">Quantum extreme learning machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-matsci_on_qc/README">Quantum Computing for Materials Science</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-ihpc">Quantum Computing Activities of NCC Iceland</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://enccs.se/lessons/">All ENCCS lessons</a></li>
<li class="toctree-l1"><a class="reference external" href="https://enccs.se/">About ENCCS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Quantum Autumn School 2024</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Quantum Autumn School 2024  documentation</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ENCCS/qas2024/blob/main/content/index" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quantum-autumn-school-2024">
<h1>Quantum Autumn School 2024<a class="headerlink" href="#quantum-autumn-school-2024" title="Link to this heading"></a></h1>
<p>Recent developments in quantum technology are bringing the world closer to a new technological revolution – the advent of usable quantum computers able to provide enormous acceleration to important computational tasks. In coming years, quantum computing is expected to have a significant impact on many areas of research that can utilise computational modelling.
Indeed, significant efforts and investments are currently underway in Europe to <a class="reference external" href="https://enccs.se/news/2024/06/european-hpc-quantum-computing-infrastructure/">bolster skills and capacity within quantum computing</a>.</p>
<p>ENCCS joins forces again this year with <a class="reference external" href="https://nordiquest.net">NordIQuEst</a>, to deliver a three-day quantum autumn school in early December 2024! The school will also be visited by and contributed to by several companies who are developing in-house expertise in various application domains of quantum computing.</p>
<p>NordΙQuEst brings together a consortium of seven partners from five Nordic and Baltic countries to connect world leading traditional HPC resources and quantum computers across national borders with the aim to establish a quantum computing platform customised to the needs of the region.</p>
<p>The quantum autumn school will be held in Stockholm in hybrid form, in-person and online.</p>
<div class="admonition-prerequisites prerequisites admonition" id="prerequisites-0">
<p class="admonition-title">Prerequisites</p>
<p>For the hands-on tutorials, basic familiarity with Python and some experience working in a Unix environment are desirable. Some previous experience with quantum computing is expected.</p>
</div>
<div class="toctree-wrapper compound">
<span id="document-setup"></span><section class="tex2jax_ignore mathjax_ignore" id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Link to this heading"></a></h2>
<p>Participants can run the course notebooks either on the Helmi quantum computer through the LUMI Open OnDemand platform, or locally on their laptops. Please refer to step by step instructions below to get started!</p>
<section id="using-helmi-via-the-custom-quantum-course-environment-on-lumi-open-ondemand">
<h3>Using Helmi via the Custom Quantum Course Environment on LUMI Open OnDemand<a class="headerlink" href="#using-helmi-via-the-custom-quantum-course-environment-on-lumi-open-ondemand" title="Link to this heading"></a></h3>
<p>A course environment has been made with preloaded modules (<a class="reference external" href="https://iqm-finland.github.io/qiskit-on-iqm/">qiskit-iqm</a>) and resource settings for connecting to Helmi. This section offers guidance on accessing this environment.</p>
<p>See also these <a class="reference download internal" download="" href="_downloads/09a36f01864da24c1c7066b6f57c1a2a/Introduction-to-QC-Course-env-LUMI-QAS.pdf"><code class="xref download docutils literal notranslate"><span class="pre">up-to-date</span> <span class="pre">instructions</span></code></a>.</p>
<ol class="arabic simple">
<li><p>Log in to <a class="reference external" href="https://www.lumi.csc.fi/public/">LUMI Open OnDemand / web interface</a> with your MyCSC / Haka account</p></li>
<li><p>Click on <code class="docutils literal notranslate"><span class="pre">Jupyter</span> <span class="pre">for</span> <span class="pre">Courses</span></code></p></li>
</ol>
<p><img alt="OOD1" src="_images/lumi-ood-1.png" /></p>
<ol class="arabic simple" start="3">
<li><p>You should get a prefilled page shown below, you can change a few variables such as your <code class="docutils literal notranslate"><span class="pre">working</span> <span class="pre">directory</span></code>.</p>
<ul class="simple">
<li><p>Please note what you selected as your working directory when launching your Jupyter Notebook as this will determine where your file is saved.</p></li>
<li><p>You can find more information about storage on LUMI here: https://docs.lumi-supercomputer.eu/storage/#__tabbed_1_1</p></li>
</ul>
</li>
</ol>
<p><img alt="OOD1" src="_images/lumi-ood-2.png" /></p>
<ol class="arabic simple" start="4">
<li><p>You also have the flexibility to adjust some resource settings. By clicking <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">custom</span> <span class="pre">resource</span> <span class="pre">settings</span></code>(Please note that memory should be kept under 3GB).</p></li>
</ol>
<p><img alt="OOD1" src="_images/lumi-ood-3.png" /></p>
<ol class="arabic simple" start="5">
<li><p>Once you are ready, click on Lunch.</p></li>
</ol>
<p><img alt="OOD1" src="_images/lumi-ood-4.png" /></p>
<ol class="arabic simple" start="6">
<li><p>Depending on the queue, it might take a few minutes before you can access your session. Once your session is ready, you should see a page like this:</p></li>
</ol>
<p><img alt="OOD1" src="_images/lumi-ood-5.png" /></p>
<ol class="arabic simple" start="7">
<li><p>Click on the big blue <code class="docutils literal notranslate"><span class="pre">Connect</span> <span class="pre">to</span> <span class="pre">Jupyter</span></code> button and it will launch a Jupyter notebook on a separate tab. Navigate to the new tab.</p></li>
<li><p>Now you can create and run codes on a jupyter notebook. A sample is shown in the image below.</p></li>
</ol>
<p><img alt="OOD1" src="_images/lumi-ood-6.png" /></p>
<ol class="arabic simple" start="9">
<li><p>You can save your notebooks like this:</p>
<ul class="simple">
<li><p>go to the top left corner, click on file</p></li>
<li><p>click on <code class="docutils literal notranslate"><span class="pre">Save</span> <span class="pre">notebook</span></code> to save a specific file or <code class="docutils literal notranslate"><span class="pre">Save</span> <span class="pre">all</span></code> to save all file &amp; changes</p></li>
</ul>
</li>
<li><p>This environment gives each user 2 hours and 2GB per session. It is configured to load the helmi_qiskit (qiskit-iqm) module and connect to Helmi.</p></li>
<li><p>To add extra python packages use <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--user</span> <span class="pre">&lt;package-name&gt;</span></code></p></li>
</ol>
<p><strong>Useful Links</strong></p>
<ul class="simple">
<li><p>https://fiqci.fi/_posts/2024-08-23-Lumi_web_introduction</p></li>
<li><p>https://docs.csc.fi/computing/quantum-computing/helmi/running-on-helmi/</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="locally-with-your-laptop">
<h3>Locally with your laptop<a class="headerlink" href="#locally-with-your-laptop" title="Link to this heading"></a></h3>
<p>All of the course contents can be followed along locally on your laptop. Each tutorial will provide installation instructions.</p>
<p>If you already have a preferred way to manage Python versions and libraries, you can stick to that. If not, we recommend that you install Python3 and all libraries using <a class="reference external" href="https://docs.conda.io/en/latest/miniconda.html"><code class="docutils literal notranslate"><span class="pre">miniconda</span></code></a> a free minimal installer for the package, dependency and environment manager for <a class="reference external" href="https://docs.conda.io/en/latest/index.html%3E"><code class="docutils literal notranslate"><span class="pre">conda</span></code></a>.</p>
<p>Please follow the installation instructions on <a class="reference external" href="https://docs.conda.io/en/latest/miniconda.html">https://docs.conda.io/en/latest/miniconda.html</a> to install Miniconda3.</p>
<p>Make sure that both Python and conda are correctly installed:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>--version
<span class="gp">$ </span><span class="c1"># should give something like Python 3.11.7</span>
<span class="gp">$ </span>conda<span class="w"> </span>--version
<span class="gp">$ </span><span class="c1"># should give something like conda 24.9.2</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> file is provided which contains all of the python packages to install a local software environment on your computer. Using this a <code class="docutils literal notranslate"><span class="pre">conda</span></code> environment can be created using the command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>conda<span class="w"> </span>create<span class="w"> </span>--name<span class="w"> </span>qas2024<span class="w"> </span>-y<span class="w"> </span><span class="nv">python</span><span class="o">=</span><span class="m">3</span>.11.7<span class="w"> </span>pip
</pre></div>
</div>
<p>Which creates a new conda environment with Python 3.10 and <code class="docutils literal notranslate"><span class="pre">pip</span></code>. You can then activate it and install the python packages:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>conda<span class="w"> </span>activate<span class="w"> </span>qas2024
<span class="gp">$ </span>pip<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements.txt
</pre></div>
</div>
<p>You can download the <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> <a class="reference download internal" download="" href="_downloads/b4ef698db8ca845e5845c4618278f29a/requirements.txt"><span class="xref download myst">here</span></a>.</p>
<p>To get access to the notebooks covered during the school, you can clone the Git repository behind this lesson page:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/ENCCS/qas2024.git
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>content/notebooks
</pre></div>
</div>
<p>Alternatively, you can navigate to https://github.com/ENCCS/qas2024, click the green “Code” button, and select “Download ZIP”.</p>
</section>
<section id="backup-approach-notebooks-csc-fi">
<h3>(Backup approach) <a class="reference external" href="https://notebooks.rahtiapp.fi/welcome">Notebooks.csc.fi</a><a class="headerlink" href="#backup-approach-notebooks-csc-fi" title="Link to this heading"></a></h3>
<p>CSC’s notebooks platform provides a preconfigured python environment and jupyter-lab server for running all of the jupyter notebooks shown in this course. <strong>No setup is required</strong> to run the notebooks.</p>
<p>Please find <a class="reference download internal" download="" href="_downloads/66afc6636cfb4927e687121cf2ac6f13/Introduction-to-CSC-Noppe-QAS.pdf"><code class="xref download docutils literal notranslate"><span class="pre">instructions</span> <span class="pre">here</span></code></a>.</p>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-welcome"></span><section class="tex2jax_ignore mathjax_ignore" id="welcome-and-introduction">
<h2>Welcome and introduction<a class="headerlink" href="#welcome-and-introduction" title="Link to this heading"></a></h2>
<section id="agenda">
<h3>Agenda<a class="headerlink" href="#agenda" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Time</p></th>
<th class="head"><p>Topic</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10:00-11:00</p></td>
<td><p>Arrival and registration</p></td>
</tr>
<tr class="row-odd"><td><p>11:00-11:15</p></td>
<td><p>Welcome and introduction to NordIQuEst, ENCCS and SQS</p></td>
</tr>
<tr class="row-even"><td><p>11:15-12:00</p></td>
<td><p>HPC/QC integration and the NordIQuEst application library</p></td>
</tr>
<tr class="row-odd"><td><p>12:00-13:00</p></td>
<td><p>Lunch</p></td>
</tr>
<tr class="row-even"><td><p>13:00-14:00</p></td>
<td><p>Introduction to the Helmi quantum computer</p></td>
</tr>
<tr class="row-odd"><td><p>14:00-17:00</p></td>
<td><p>Intro to variational quantum algorithms: QAOA theory and hands-on</p></td>
</tr>
<tr class="row-even"><td><p>17:30-18:30</p></td>
<td><p>Study visit to quantum optics labs at Albanova University Center</p></td>
</tr>
<tr class="row-odd"><td><p>18:30-21:00</p></td>
<td><p>Self-organised dinner in Stockholm</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Time</p></th>
<th class="head"><p>Topic</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>09:00-12:00</p></td>
<td><p>Error correction – theory and hands-on</p></td>
</tr>
<tr class="row-odd"><td><p>12:00-13:00</p></td>
<td><p>Lunch</p></td>
</tr>
<tr class="row-even"><td><p>13:00-14:00</p></td>
<td><p>Quantum computing hardware</p></td>
</tr>
<tr class="row-odd"><td><p>14:00-15:00</p></td>
<td><p>Quantum Monte Carlo and quantum finance</p></td>
</tr>
<tr class="row-even"><td><p>15:00-16:30</p></td>
<td><p>QMC and quantum finance tutorial</p></td>
</tr>
<tr class="row-odd"><td><p>16:30-17:00</p></td>
<td><p>Overview of the Quantum Sweden Innovation Platform – QSIP</p></td>
</tr>
<tr class="row-even"><td><p>17:00-17:30</p></td>
<td><p>Post-quantum cryptography</p></td>
</tr>
<tr class="row-odd"><td><p>18:00-21:00</p></td>
<td><p>QAS dinner, drinks and Pecha Kucha social event</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Time</p></th>
<th class="head"><p>Topic</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>09:00-10:00</p></td>
<td><p>Solving Flight Scheduling Optimization using QAOA – Theory</p></td>
</tr>
<tr class="row-odd"><td><p>10:00-11:00</p></td>
<td><p>Solving Flight Scheduling Optimization using QAOA – Hands-on</p></td>
</tr>
<tr class="row-even"><td><p>11:00-12:00</p></td>
<td><p>Quantum walk – seminar and demo</p></td>
</tr>
<tr class="row-odd"><td><p>12:00-13:00</p></td>
<td><p>Lunch</p></td>
</tr>
<tr class="row-even"><td><p>13:00-14:00</p></td>
<td><p>Quantum chemistry and materials science seminar</p></td>
</tr>
<tr class="row-odd"><td><p>14:00-15:00</p></td>
<td><p>Quantum chemistry and materials science hands-on</p></td>
</tr>
<tr class="row-even"><td><p>15:00-15:30</p></td>
<td><p>Quantum extreme learning machine: presentation and case study</p></td>
</tr>
<tr class="row-odd"><td><p>15:30-16:15</p></td>
<td><p>Overview of the Tergite framework</p></td>
</tr>
</tbody>
</table>
</section>
<section id="about-enccs">
<h3>About ENCCS<a class="headerlink" href="#about-enccs" title="Link to this heading"></a></h3>
<p><img alt="ENCCS" src="_images/ENCCS-erbjudande.png" /></p>
</section>
<section id="about-nordiquest">
<h3>About NordIQuEst<a class="headerlink" href="#about-nordiquest" title="Link to this heading"></a></h3>
<p><img alt="ENCCS" src="_images/2024-12-02_NordIQuEst_QAS24_1.png" /></p>
<p><img alt="ENCCS" src="_images/2024-12-02_NordIQuEst_QAS24_2.png" /></p>
</section>
</section>
<span id="document-hpc_qc"></span><section class="tex2jax_ignore mathjax_ignore" id="integration-of-high-performance-computing-and-quantum-computing">
<h2>Integration of High Performance Computing and Quantum Computing<a class="headerlink" href="#integration-of-high-performance-computing-and-quantum-computing" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/a925277ed235f9ee3f7c4feb646f788d/Integration_HPC_QC.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
<span id="document-helmi"></span><section class="tex2jax_ignore mathjax_ignore" id="introduction-to-helmi">
<h2>Introduction to Helmi<a class="headerlink" href="#introduction-to-helmi" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/67b505441f18fabaae2330a326a7384c/QAS24_Presentation_Zuhair.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
<span id="document-notebooks/GHZ_Estimator_Attendees"></span><section class="tex2jax_ignore mathjax_ignore" id="tutorial-introduction-to-helmi">
<h2>Tutorial - Introduction to Helmi<a class="headerlink" href="#tutorial-introduction-to-helmi" title="Link to this heading"></a></h2>
<section id="estimating-the-ghz-fidelity">
<h3>Estimating the GHZ fidelity<a class="headerlink" href="#estimating-the-ghz-fidelity" title="Link to this heading"></a></h3>
<section id="preparing-the-ghz-circuit">
<h4>Preparing the GHZ circuit<a class="headerlink" href="#preparing-the-ghz-circuit" title="Link to this heading"></a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Importing the required modules</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">iqm.qiskit_iqm</span> <span class="kn">import</span> <span class="n">IQMProvider</span>
<span class="kn">from</span> <span class="nn">iqm.qiskit_iqm.fake_backends</span> <span class="kn">import</span> <span class="n">fake_adonis</span>
<span class="kn">from</span> <span class="nn">iqm.qiskit_iqm.iqm_transpilation</span> <span class="kn">import</span> <span class="n">optimize_single_qubit_gates</span>
<span class="kn">from</span> <span class="nn">qiskit.compiler</span> <span class="kn">import</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">from</span> <span class="nn">qiskit.result</span> <span class="kn">import</span> <span class="n">marginal_counts</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up the Helmi backend</span>
<span class="n">HELMI_CORTEX_URL</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HELMI_CORTEX_URL&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">HELMI_CORTEX_URL</span><span class="p">:</span>
	<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Environment variable HELMI_CORTEX_URL is not set&quot;</span><span class="p">)</span>

<span class="n">provider</span> <span class="o">=</span> <span class="n">IQMProvider</span><span class="p">(</span><span class="n">HELMI_CORTEX_URL</span><span class="p">)</span> 
<span class="n">backend</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span> <span class="c1"># fake_adonis.IQMFakeAdonis()</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Native operations: </span><span class="si">{</span><span class="n">backend</span><span class="o">.</span><span class="n">operation_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of qubits: </span><span class="si">{</span><span class="n">backend</span><span class="o">.</span><span class="n">num_qubits</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coupling map: </span><span class="si">{</span><span class="n">backend</span><span class="o">.</span><span class="n">coupling_map</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">backend</span><span class="o">.</span><span class="n">coupling_map</span><span class="p">)</span>
<span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;QB</span><span class="si">{</span><span class="n">node</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">}</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;skyblue&quot;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us first prepare the GHZ circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simple GHZ circuit</span>
<span class="n">qubits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QB&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span> <span class="c1">#expected equal majority counts of &#39;00000&#39; and &#39;11111&#39;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here is how the circuit will look like if we convert to Helmi’s native gateset.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Optimising for Helmi -&gt; </span>
<span class="n">initial_layout</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">qubit_name_to_index</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span><span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">transpiled_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As the <em>RZ</em> gates commute with the <em>CZ</em> gates, and the measurement is not affected by the final <em>RZ</em> gate, we can optimise those away to decrease the number of gates we perform.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">optimize_single_qubit_gates</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="p">)</span>
<span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">transpiled_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unmitigated GHZ fidelity =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="s2">&quot;00000&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="s2">&quot;11111&quot;</span><span class="p">])</span><span class="o">/</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="applying-readout-mitigation">
<h4>Applying readout mitigation<a class="headerlink" href="#applying-readout-mitigation" title="Link to this heading"></a></h4>
<p>The code used here was modified from <a class="reference external" href="https://nvidia.github.io/cuda-quantum/latest/applications/python/readout_error_mitigation.html">this tutorial</a> from NVIDIA.</p>
<p>To perform readout mitigation with the minimum number of jobs, we will prepare the <span class="math notranslate nohighlight">\(\mid \! 00000 \rangle\)</span> and <span class="math notranslate nohighlight">\(\mid \! 11111 \rangle\)</span> and see which states we actually measure.</p>
<p>First, we observe how the <span class="math notranslate nohighlight">\(\mid \! 00000 \rangle\)</span> state is not strongly affected by state preparation and measurement (SPAM) errors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QB&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">qc_0s</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="n">qc_0s</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">initial_layout</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">qubit_name_to_index</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="n">qc_0s</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc_0s</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span> <span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_0s</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_0s</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">result_0s</span> <span class="o">=</span> <span class="n">job_0s</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts_0s</span> <span class="o">=</span> <span class="n">result_0s</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts_0s</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we can observe how the <span class="math notranslate nohighlight">\(\mid \! 11111 \rangle\)</span> is much more strongly affected by SPAM error. Part of this comes from the <span class="math notranslate nohighlight">\(\mid \! 1 \rangle\)</span> state relaxing to <span class="math notranslate nohighlight">\(\mid \! 0 \rangle\)</span>, however, the exact ways in which Helmi is calibrated also plays an important role here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QB&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">qc_1s</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">qc_1s</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">qubit</span><span class="p">])</span>
<span class="n">qc_1s</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">initial_layout</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">qubit_name_to_index</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="n">qc_1s</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc_1s</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span> <span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_1s</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_1s</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">result_1s</span> <span class="o">=</span> <span class="n">job_1s</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts_1s</span> <span class="o">=</span> <span class="n">result_1s</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts_1s</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">local_states</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span> <span class="o">*</span> <span class="n">n_qubits</span><span class="p">]</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;00000&quot;</span><span class="p">:</span> <span class="n">result_0s</span><span class="p">,</span> <span class="s2">&quot;11111&quot;</span><span class="p">:</span> <span class="n">result_1s</span><span class="p">}</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">local_states</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> becomes </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">possible_counts</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">local_states</span>
<span class="p">]</span>
<span class="n">matrices</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">marginalized_counts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_shots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">local_states</span><span class="p">:</span>
        <span class="n">marginal_cts</span> <span class="o">=</span> <span class="n">marginal_counts</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
        <span class="n">marginalized_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">marginal_cts</span><span class="p">)</span>
        <span class="n">total_shots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">marginal_cts</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="c1"># matrix[i][j] is the probability of counting i for expected j</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">marginalized_counts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                                                      <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_shots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We have just prepared the confusion matrices for each of the <span class="math notranslate nohighlight">\(5\)</span> qubits using just <span class="math notranslate nohighlight">\(2\)</span> jobs, which can be used to calculate the confusion matrix for the whole system. This does assume that measurement or doing gates on one qubit does not affect other gates. We could create these confusion matrices using <span class="math notranslate nohighlight">\(2n_{\text{qubits}}\)</span>, or even more properly using <span class="math notranslate nohighlight">\(2^{n_{\text{qubits}}}\)</span> jobs, however, just these <span class="math notranslate nohighlight">\(2\)</span> jobs should suffice.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matrices</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Confusion matrix for QB</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">n_qubits</span><span class="p">)))</span>
<span class="n">states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">label</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">label</span><span class="p">)),</span> <span class="n">labels</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Let us have another look at the counts from the GHZ circuit. We will perform readout error mitigation on it, and hopefully, improve the GHZ state fidelity.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="n">noisy_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span><span class="n">new_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">states</span><span class="p">)])</span>
<span class="n">noisy_counts</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_closest_distribution</span><span class="p">(</span><span class="n">empirical_dist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the closest distribution to an empirical distribution by minimizing the L1 norm.</span>

<span class="sd">    Args:</span>
<span class="sd">        empirical_dist: Empirical distribution that you want to find the closest distribution to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Closest distribution to `empirical_dist`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">empirical_dist</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Constraint: all elements of p must be positive, and the distribution must sum to 1</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ineq&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;eq&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="n">bnds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">empirical_dist</span><span class="p">))]</span>
    <span class="n">initial_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">empirical_dist</span><span class="p">))</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
        <span class="n">objective</span><span class="p">,</span>
        <span class="n">initial_value</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">},</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bnds</span><span class="p">,</span>
        <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_counts_from_distribution</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates samples based on a given distribution and returns the counts of each sample value.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_qubits: The number of qubits in the quantum circuit.</span>
<span class="sd">        dist: The probability distribution from which samples are drawn.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An array of counts for each possible value in the distribution. The array has a length of 2^n_qubits.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_qubits</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Function to draw the confusion matrix</span>
<span class="k">def</span> <span class="nf">plot_cmat</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Reds</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Confusion Matrix&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Prepared State&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Measured State&quot;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>First, we invert the confusion matrix for each individual qubit. Next, we approximate the inverse confusion matrix for Helmi using the tensor product. Now, we can simply apply this to our “noisy” results and we should have mitigated the effects of the readout errors.</p>
<p>As this is a mathematical operation, we can end up with negative counts, which lack any physical meaning. We can find another distribution with all positive values that is similar to our mitigated distribution. We sample this distribution probabilistically to obtain our corrected counts.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pinv_confusion_matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">]</span>
<span class="n">A_pinv</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">,</span> <span class="n">pinv_confusion_matrices</span><span class="p">)</span>
<span class="n">mitigated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A_pinv</span><span class="p">,</span> <span class="n">noisy_counts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mitigated counts:</span><span class="se">\n</span><span class="si">{</span><span class="n">mitigated</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mitigated</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">positive_dist</span> <span class="o">=</span> <span class="n">find_closest_distribution</span><span class="p">(</span><span class="n">mitigated</span> <span class="o">/</span> <span class="n">shots</span><span class="p">)</span>
    <span class="n">mitigated</span> <span class="o">=</span> <span class="n">get_counts_from_distribution</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">shots</span><span class="p">,</span> <span class="n">positive_dist</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Corrected for negative counts:</span><span class="se">\n</span><span class="si">{</span><span class="n">mitigated</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">A_joint</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">,</span> <span class="n">matrices</span><span class="p">)</span>
<span class="n">plot_cmat</span><span class="p">(</span><span class="n">A_joint</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As we can see, the mitigated fidelity is higher than the unmitigated fidelity, at the cost of two more jobs run.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_histogram</span><span class="p">([</span><span class="n">counts</span><span class="p">,</span> <span class="nb">dict</span><span class="p">({</span><span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mitigated</span><span class="p">)})],</span> <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Unmitigated&quot;</span><span class="p">,</span> <span class="s2">&quot;Mitigated&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unmitigated GHZ fidelity =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="s2">&quot;00000&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="s2">&quot;11111&quot;</span><span class="p">])</span><span class="o">/</span><span class="n">shots</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Corrected GHZ fidelity =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">mitigated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mitigated</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="multiple-quantum-coherences">
<h3>Multiple Quantum Coherences<a class="headerlink" href="#multiple-quantum-coherences" title="Link to this heading"></a></h3>
<section id="theory">
<h4>Theory<a class="headerlink" href="#theory" title="Link to this heading"></a></h4>
<p><a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.101.032343">Multiple Quantum Coherences</a> (MQC) offers an alternative way to estimate the GHZ fidelity. It allows us to calculate a lower and upper bound on the GHZ fidelity, as well as calculating the exact GHZ fidelity if run alongside a GHZ circuit.</p>
<p>MQC works by utilising phase kickback, a highly versatile tool used in many algorithms to “kick” a phase from a target qubit “back” to a control qubit. First, we prepare a <span class="math notranslate nohighlight">\(N\)</span>-qubit GHZ state, and then we apply a phase <span class="math notranslate nohighlight">\(\phi\)</span> to all <span class="math notranslate nohighlight">\(N\)</span> qubits. Then, we “undo” the GHZ state, and this “kicksback” the phase to the control qubit, applying a phase shift of <span class="math notranslate nohighlight">\(N\phi\)</span> to the control qubit.</p>
<p>To help explain this more easily, I will quote the paper directly here.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Starting from the <span class="math notranslate nohighlight">\(N\)</span>-qubit ground state: <span class="math notranslate nohighlight">\(\mid \! GS \rangle = \mid \! 000..00 \rangle\)</span>, apply a Hadamard gate on qubit <span class="math notranslate nohighlight">\(0\)</span> followed by a sequence of <em>CX</em> gates. Ideally this brings the system into the GHZ state: <span class="math notranslate nohighlight">\(\mid \! GHZ \rangle = \tfrac 1{\sqrt 2} \left( \mid \! 000..00 \rangle + \mid \! 111..11 \rangle\right)\)</span></p></li>
<li><p>Apply a collective rotation given by the unitary <span class="math notranslate nohighlight">\(U_{\phi}\)</span> on all qubits. This amounts to adding a phase <span class="math notranslate nohighlight">\(N\phi\)</span> to the GHZ state: <span class="math notranslate nohighlight">\(\tfrac 1{\sqrt 2} \left( \mid \! 000..00 \rangle + e^{-iN\phi}\mid \! 111..11 \rangle\right)\)</span></p></li>
<li><p>Disentangle the GHZ state by performing the <em>CX</em> gate sequence in reverse order. The amplified phase is mapped onto qubit <span class="math notranslate nohighlight">\(0\)</span>: <span class="math notranslate nohighlight">\(\tfrac 1{\sqrt 2} \left( \mid \! 000..00 \rangle + e^{-iN\phi}\mid \! 111..11 \rangle\right) \otimes \mid \! 00..00 \rangle\)</span></p></li>
<li><p>Read out the amplified phase by measuring the probability of the system returning to its initial state: \mid ! GS \rangle</p></li>
</ol>
<p>The measured signal of this protocol is given by <span class="math notranslate nohighlight">\(S_\phi = \left| \langle 000..00 \! \mid \! U^{\dagger}_{GHZ} U_{\phi} U_{GHZ} \! \mid \! 000..00 \rangle \right|^2 = Tr(\rho_\phi\rho)\)</span> where <span class="math notranslate nohighlight">\(\rho = U_{GHZ} \! \mid \! GS \rangle \langle GS \! \mid \! U^{\dagger}_{GHZ}\)</span>, <span class="math notranslate nohighlight">\(U_{GHZ} = U_{CZ}H_0\)</span>, and <span class="math notranslate nohighlight">\(\rho_\phi = U_{\phi}\rho U^{\dagger}_{\phi}\)</span>.</p>
</div></blockquote>
<p>If we run this on a noiseless quantum computer, we expect <span class="math notranslate nohighlight">\(S_{\phi} = \tfrac 12(1 + \cos(N\phi))\)</span>. We can then measure <span class="math notranslate nohighlight">\(S_{\phi}\)</span> for multiple angles <span class="math notranslate nohighlight">\(\phi\)</span>, and then perform a Fourier transform to find which frequency our <span class="math notranslate nohighlight">\(S_{\phi}\)</span> actually corresponds to.</p>
<div class="math notranslate nohighlight">
\[I_q=\mathcal{N}^{-1}\left|\sum_\phi e^{i q \phi} S_\phi\right|\]</div>
<p>Ideally, it should be completely dependent on <span class="math notranslate nohighlight">\(N\)</span>, and have no reliance on any of the other frequencies - however, due to noise, we shall get a spread of frequencies with varying amplitudes. We can then use these to estimate the lower and upper bounds of the GHZ fidelity.</p>
<div class="math notranslate nohighlight">
\[2 \sqrt{I_N} \leq F \leq \sqrt{I_0 / 2}+\sqrt{I_N}\]</div>
</section>
<section id="preparing-the-mqc-circuits">
<h4>Preparing the MQC circuits<a class="headerlink" href="#preparing-the-mqc-circuits" title="Link to this heading"></a></h4>
<p>First, let us define a parametrised circuit for the MQC experiment. Developed based on the original paper.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mqc_circuit</span><span class="p">(</span><span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="n">qubits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QB&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
    <span class="n">mqc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">mqc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="c1"># We will comment out this line later</span>
        <span class="n">mqc</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mqc</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we define which <span class="math notranslate nohighlight">\(\phi\)</span> to sweep over, and how many shots to execute for each circuit. We need a minimum of <span class="math notranslate nohighlight">\(12\)</span> experiments here, so that our Fourier transform can detect frequencies upto <span class="math notranslate nohighlight">\(6\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_exp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_qubits</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">j</span> <span class="o">/</span> <span class="n">n_exp</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_exp</span><span class="p">)]</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">16_384</span>
</pre></div>
</div>
</div>
</div>
<p>The parameterized circuits are collected in a list <code class="docutils literal notranslate"><span class="pre">mqc_circuits</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mqc_circuits</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
    <span class="n">mqc</span> <span class="o">=</span> <span class="n">mqc_circuit</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>    
    <span class="n">mqc_circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mqc</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us observe how the untranspiled circuit looks.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mqc_circuits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Before running, we transpile each circuit to the native gate set and map the logical qubits to the physical qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initial_layout</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">qubit_name_to_index</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;QB1&quot;</span><span class="p">,</span> <span class="s2">&quot;QB2&quot;</span><span class="p">,</span> <span class="s2">&quot;QB3&quot;</span><span class="p">,</span> <span class="s2">&quot;QB4&quot;</span><span class="p">,</span> <span class="s2">&quot;QB5&quot;</span><span class="p">]]</span>

<span class="n">fidelity_circuits</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">mqc_circuits</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span><span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">fidelity_circuits</span> <span class="o">=</span> <span class="n">optimize_single_qubit_gates</span><span class="p">(</span><span class="n">fidelity_circuits</span><span class="p">)</span>
<span class="n">fidelity_circuits</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">fidelity_circuits</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span><span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s have a look at the transpiled circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fidelity_circuits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="with-ideal-backend">
<h4>With Ideal Backend<a class="headerlink" href="#with-ideal-backend" title="Link to this heading"></a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fake_backend</span> <span class="o">=</span> <span class="n">fake_adonis</span><span class="o">.</span><span class="n">IQMFakeAdonis</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fake_jobs</span> <span class="o">=</span> <span class="n">fake_backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fidelity_circuits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fake_results</span> <span class="o">=</span> <span class="n">fake_jobs</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">fake_counts</span> <span class="o">=</span> <span class="n">fake_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_histogram</span><span class="p">(</span><span class="n">fake_counts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>After running the circuit, we should only have the states <span class="math notranslate nohighlight">\(\mid \! 00000 \rangle\)</span> and <span class="math notranslate nohighlight">\(\mid \! 00100 \rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fake_outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">fake_count</span><span class="p">[</span><span class="s1">&#39;00000&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">fake_count</span><span class="p">[</span><span class="s1">&#39;00000&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">fake_count</span><span class="p">[</span><span class="s1">&#39;00100&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">fake_count</span> <span class="ow">in</span> <span class="n">fake_counts</span><span class="p">]</span> <span class="c1"># (fake_count[&#39;00000&#39;] + fake_count[&#39;00100&#39;])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">all_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">10_000</span><span class="p">)</span>
<span class="n">expected_fidelity</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">n_qubits</span> <span class="o">*</span> <span class="n">j</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">all_angles</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">fake_outcomes</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Fake&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">all_angles</span><span class="p">,</span> <span class="n">expected_fidelity</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Expected&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Angle $(\phi)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$S_{\phi}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I_0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">I_n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="n">I_0</span> <span class="o">+=</span> <span class="n">fake_outcomes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">I_n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">n_qubits</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">fake_outcomes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">I_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_0</span> <span class="o">/</span> <span class="n">n_exp</span><span class="p">)</span>
<span class="n">I_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_n</span> <span class="o">/</span> <span class="n">n_exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lower bound for MQC fidelity = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_n</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Upper bound for MQC fidelity = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_n</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="simulations-vs-actual-hardware">
<h4>Simulations vs Actual Hardware<a class="headerlink" href="#simulations-vs-actual-hardware" title="Link to this heading"></a></h4>
<p>Let us now rerun this, but comment out the <code class="docutils literal notranslate"><span class="pre">mqc.x(qubit)</span></code> line at the very start of the circuit. Similarly, try changing the <code class="docutils literal notranslate"><span class="pre">n_exp</span></code> to a higher value. What changes do you observe?</p>
<details>
  <summary>Spoiler warning</summary>
<p>We should not observe any significant changes in the fidelity estimates for the simulator. However, we will now see how this changes when we run on actual hardware.</p>
</details>
</section>
<section id="with-helmi-backend">
<h4>With Helmi Backend<a class="headerlink" href="#with-helmi-backend" title="Link to this heading"></a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jobs</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fidelity_circuits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jobs</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mqc_results</span> <span class="o">=</span> <span class="n">jobs</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">mqc_counts</span> <span class="o">=</span> <span class="n">mqc_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mqc_results</span><span class="o">.</span><span class="n">timestamps</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_histogram</span><span class="p">(</span><span class="n">mqc_counts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mqc_count</span><span class="p">[</span><span class="s1">&#39;00000&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">mqc_count</span><span class="p">[</span><span class="s1">&#39;00000&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">mqc_count</span><span class="p">[</span><span class="s1">&#39;00100&#39;</span><span class="p">])</span>  <span class="k">for</span> <span class="n">mqc_count</span> <span class="ow">in</span> <span class="n">mqc_counts</span><span class="p">]</span> <span class="c1"># (mqc_count[&#39;00000&#39;] + mqc_count[&#39;00100&#39;])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">all_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">10_000</span><span class="p">)</span>
<span class="n">expected_fidelity</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">n_qubits</span> <span class="o">*</span> <span class="n">i</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_angles</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">fake_outcomes</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">outcomes</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Experimental&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">all_angles</span><span class="p">,</span> <span class="n">expected_fidelity</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Expected&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Angle $(\phi)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$S_{\phi}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I_0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">I_n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="n">I_0</span> <span class="o">+=</span> <span class="n">outcomes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">I_n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">n_qubits</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">outcomes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">I_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_0</span> <span class="o">/</span> <span class="n">n_exp</span><span class="p">)</span>
<span class="n">I_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_n</span> <span class="o">/</span> <span class="n">n_exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lower bound for MQC fidelity = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_n</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Upper bound for MQC fidelity = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_n</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<p>What we observe is that removing the <span class="math notranslate nohighlight">\(X\)</span> gates results in a noticeable phase shift in the results, even though it should technically not matter. The presenter’s hypothesis is that this phenomenon is related to qubit relaxation, which causes the state <span class="math notranslate nohighlight">\(\mid \! 00000\rangle\)</span> to dominate over <span class="math notranslate nohighlight">\(\mid  \! 11111\rangle\)</span>, even though they should be even. Consequently, applying the <span class="math notranslate nohighlight">\(X\)</span> gates inverts this distribution, and further relaxation should lead to a more balanced ratio of these states. An analogy can be drawn to the Hahn-Echo experiment, where a <span class="math notranslate nohighlight">\(Z\)</span> gate can help cancel out some of the dephasing effects.</p>
<p>Furthermore, running more experiments provides a higher fidelity. The presenter hypothesises that this can be attributed to the noise after the Fourier transform being spread out over more frequencies, leading to improved results. We are not changing the experiment - just collecting additional data to help average out errors.</p>
</section>
</section>
</section>
<span id="document-qaoa_vqe_intro"></span><section class="tex2jax_ignore mathjax_ignore" id="introduction-to-variational-quantum-algorithms-vqe-and-qaoa">
<h2>Introduction to variational quantum algorithms: VQE and QAOA<a class="headerlink" href="#introduction-to-variational-quantum-algorithms-vqe-and-qaoa" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/f1fd3f0d89d6fda289fb092c2160c4f0/QAS2024_QAOA.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
<span id="document-notebooks/QAS2024_QAOA_exercise"></span><section class="tex2jax_ignore mathjax_ignore" id="tutorial-variational-quantum-algorithms">
<h2>Tutorial - Variational Quantum Algorithms<a class="headerlink" href="#tutorial-variational-quantum-algorithms" title="Link to this heading"></a></h2>
<section id="exercise-1-max-4-cut">
<h3>Exercise 1: Max 4-Cut<a class="headerlink" href="#exercise-1-max-4-cut" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><u>Problem Definition</u></p></li>
</ol>
<p>The Max 4-Cut problem is defined on a graph <span class="math notranslate nohighlight">\( G = (V, E) \)</span>, with a corresponding problem Hamiltonian given by:</p>
<div class="math notranslate nohighlight">
\[
H_P = \sum_{e \in E} w_{e} H_{e},
\]</div>
<p>where <span class="math notranslate nohighlight">\( w_e \)</span> represents the weight of edge <span class="math notranslate nohighlight">\( e \in E\)</span>, and <span class="math notranslate nohighlight">\( H_e \)</span> is the Hamiltonian associated with that edge.</p>
<ol class="arabic simple" start="2">
<li><p><u>Generic Graph Problem</u></p></li>
</ol>
<p>In this exercise, the class <code class="docutils literal notranslate"><span class="pre">GraphProblem</span></code> from the <code class="docutils literal notranslate"><span class="pre">qaoa.problems</span></code> module is used to define the problem. The class requires two inputs:</p>
<ol class="arabic simple">
<li><p>A networkx graph <span class="math notranslate nohighlight">\(G\)</span>,</p></li>
<li><p>The number of qubits per vertex/node.</p></li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">GraphProblem</span></code> class includes a method to create a quantum circuit for implementing the phase separating Hamiltonian <span class="math notranslate nohighlight">\(e^{-i\theta H_P}\)</span>.</p>
<ol class="arabic simple" start="3">
<li><p><u>Specific problem implementation</u></p></li>
</ol>
<p>However, <code class="docutils literal notranslate"><span class="pre">GraphProblem</span></code> relies on an abstract method, <code class="docutils literal notranslate"><span class="pre">create_edge_circuit</span></code>, which must be implemented to define the phase separating Hamiltonian <span class="math notranslate nohighlight">\( H_e \)</span> for an edge.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">qaoa.problems</span> <span class="kn">import</span> <span class="n">GraphProblem</span>

<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">PhaseGate</span>

<span class="k">class</span> <span class="nc">Max4Cut</span><span class="p">(</span><span class="n">GraphProblem</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">N_qubits_per_node</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">N_qubits_per_node</span><span class="p">)</span>

        <span class="c1"># each color is associated with a bitstring combination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;color1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;00&quot;</span><span class="p">],</span>
            <span class="s2">&quot;color2&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;01&quot;</span><span class="p">],</span>
            <span class="s2">&quot;color3&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;10&quot;</span><span class="p">],</span>
            <span class="s2">&quot;color4&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;11&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="c1"># Create a dictionary to map each index to its corresponding set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitstring_to_color</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bitstring_to_color</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">create_edge_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_qubits_per_node</span><span class="p">)</span>

        <span class="s2">&quot; ---------------------&quot;</span>
        <span class="s2">&quot; implement the circuit&quot;</span>
        <span class="s2">&quot; ---------------------&quot;</span>
        
        <span class="k">return</span> <span class="n">qc</span>
    <span class="k">def</span> <span class="nf">create_edge_circuit_fixed_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<p>Show the circuit for one edge</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test</span> <span class="o">=</span> <span class="n">Max4Cut</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})]))</span>
<span class="n">test</span><span class="o">.</span><span class="n">create_edge_circuit</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Graph contains nodes with one or zero edges. These can be removed to reduce the size of the problem.
</pre></div>
</div>
<img alt="_images/8176e52d8674154be6dd10dec3742ef900dd05bcbe676c1c1b4e1bd152003530.png" src="_images/8176e52d8674154be6dd10dec3742ef900dd05bcbe676c1c1b4e1bd152003530.png" />
</div>
</div>
<ol class="arabic simple" start="4">
<li><p><u>Graph instance</u></p></li>
</ol>
<p>Let’s start by defining a Graph with 10 nodes</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># Create a graph with 8 nodes</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="c1"># Add nodes</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="c1"># Add edges (example connections)</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

<span class="c1"># Draw the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/6212f42aa3cefc0fc1c9e15f021a78d6087f425761e72e65ddc85edfdb9e16e4.png" src="_images/6212f42aa3cefc0fc1c9e15f021a78d6087f425761e72e65ddc85edfdb9e16e4.png" />
</div>
</div>
<ol class="arabic simple" start="5">
<li><p><u>Problem instance</u></p></li>
</ol>
<p>Now we can instantiate a Max4Cut problem with the graph and create and draw the resulting circuit for the phase separating Hamiltonian. Observe that there is one circuit per edge in the graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">max4cut</span> <span class="o">=</span> <span class="n">Max4Cut</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">max4cut</span><span class="o">.</span><span class="n">create_circuit</span><span class="p">()</span>
<span class="n">max4cut</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/88f4f0a7737ef47119119fcc77750811c8502313ff9b4079c02ae91e80735b1b.png" src="_images/88f4f0a7737ef47119119fcc77750811c8502313ff9b4079c02ae91e80735b1b.png" />
</div>
</div>
<ol class="arabic simple" start="5">
<li><p><u>QAOA instance</u></p></li>
</ol>
<p>We create a QAOA instance using</p>
<ul class="simple">
<li><p>as initial state we use the <span class="math notranslate nohighlight">\(\ket{+}\)</span> state,</p></li>
<li><p>as mixing operator the <span class="math notranslate nohighlight">\(X\)</span>-mixer, and</p></li>
<li><p>as phase separation operator our newly created max4cut instance.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qaoa</span> <span class="kn">import</span> <span class="n">QAOA</span>
<span class="kn">from</span> <span class="nn">qaoa.initialstates</span> <span class="kn">import</span> <span class="n">Plus</span>
<span class="kn">from</span> <span class="nn">qaoa.mixers</span> <span class="kn">import</span> <span class="n">X</span>
<span class="kn">from</span> <span class="nn">qiskit_algorithms.optimizers</span> <span class="kn">import</span> <span class="n">COBYLA</span>

<span class="n">settings</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s2">&quot;tol&quot;</span><span class="p">:</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="s2">&quot;rhobeg&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">}</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="p">[</span><span class="n">COBYLA</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>

<span class="n">qaoa_k4</span> <span class="o">=</span> <span class="n">QAOA</span><span class="p">(</span><span class="n">initialstate</span><span class="o">=</span><span class="n">Plus</span><span class="p">(),</span> <span class="n">problem</span><span class="o">=</span><span class="n">max4cut</span><span class="p">,</span> <span class="n">mixer</span><span class="o">=</span><span class="n">X</span><span class="p">(),</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="5">
<li><p><u>Run QAOA</u></p></li>
</ol>
<ul class="simple">
<li><p>Sample the cost landscape and plot it.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="k">def</span> <span class="nf">plot_E</span><span class="p">(</span><span class="n">qaoa_instance</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">qaoa_instance</span><span class="o">.</span><span class="n">landscape_p1_angles</span>
    <span class="n">dgamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">qaoa_instance</span><span class="o">.</span><span class="n">gamma_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">qaoa_instance</span><span class="o">.</span><span class="n">gamma_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">dbeta</span> <span class="o">=</span> <span class="p">(</span><span class="n">qaoa_instance</span><span class="o">.</span><span class="n">gamma_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">qaoa_instance</span><span class="o">.</span><span class="n">gamma_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">angles</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dgamma</span><span class="p">,</span>
        <span class="n">angles</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dgamma</span><span class="p">,</span>
        <span class="n">angles</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dbeta</span><span class="p">,</span>
        <span class="n">angles</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dbeta</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">__plot_landscape</span><span class="p">(</span><span class="n">qaoa_instance</span><span class="o">.</span><span class="n">exp_landscape</span><span class="p">(),</span> <span class="n">extent</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__plot_landscape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">fig</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fig</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\gamma$&quot;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\beta$&quot;</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Expectation value&quot;</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
    <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>

<span class="n">qaoa_k4</span><span class="o">.</span><span class="n">sample_cost_landscape</span><span class="p">(</span> <span class="n">angles</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">]}</span> <span class="p">)</span>
<span class="n">plot_E</span><span class="p">(</span><span class="n">qaoa_k4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2024-12-02 13:36:14 [info     ] Calculating energy landscape for depth p=1... file=qaoa.qaoa func=sample_cost_landscape
2024-12-02 13:36:15 [info     ] Executing sample_cost_landscape file=qaoa.qaoa func=sample_cost_landscape
2024-12-02 13:36:15 [info     ] parameters: 2                  file=qaoa.qaoa func=sample_cost_landscape
2024-12-02 13:36:15 [info     ] Done execute                   file=qaoa.qaoa func=sample_cost_landscape
2024-12-02 13:36:22 [info     ] Done measurement               file=qaoa.qaoa func=sample_cost_landscape
2024-12-02 13:36:22 [info     ] Calculating Energy landscape done file=qaoa.qaoa func=sample_cost_landscape
</pre></div>
</div>
<img alt="_images/497ae922c8987da97ad49dc3713743f6844bd401188170f0660c9c36958798ba.png" src="_images/497ae922c8987da97ad49dc3713743f6844bd401188170f0660c9c36958798ba.png" />
</div>
</div>
<ul class="simple">
<li><p>Use a local optimizer to find the optimum for <span class="math notranslate nohighlight">\(p=1\)</span>. We converge quickly to the local optimum.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qaoa_k4</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">beta</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">angles</span> <span class="o">=</span> <span class="n">qaoa_k4</span><span class="o">.</span><span class="n">optimization_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">angles</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
    <span class="n">gamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">beta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="s2">&quot;x-k&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;wo&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;or&quot;</span><span class="p">)</span>
<span class="n">plot_E</span><span class="p">(</span><span class="n">qaoa_k4</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2024-12-02 13:36:23 [info     ] cost(depth 1 = -10.727539062500002 file=qaoa.qaoa func=optimize
</pre></div>
</div>
<img alt="_images/e6b2ace5fc5537384b9ea4f39c28358219dd0764a193e10837455046471dc874.png" src="_images/e6b2ace5fc5537384b9ea4f39c28358219dd0764a193e10837455046471dc874.png" />
</div>
</div>
<ul class="simple">
<li><p>Run QAOA up to depth <span class="math notranslate nohighlight">\(p=5\)</span>. We can see how the approximation ratio increases with <span class="math notranslate nohighlight">\(p\)</span>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">maxdepth</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">qaoa_k4</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">maxdepth</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qaoa_k4</span><span class="o">.</span><span class="n">get_Exp</span><span class="p">()))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">maxval</span><span class="o">=</span><span class="mi">12</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qaoa_k4</span><span class="o">.</span><span class="n">get_Exp</span><span class="p">())</span> <span class="o">/</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;depth&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Approx. ratio&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;QAOA Max 4-Cut&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2024-12-02 13:36:25 [info     ] cost(depth 2 = -11.204101562499991 file=qaoa.qaoa func=optimize
2024-12-02 13:36:29 [info     ] cost(depth 3 = -11.468749999999988 file=qaoa.qaoa func=optimize
2024-12-02 13:36:34 [info     ] cost(depth 4 = -11.54296875    file=qaoa.qaoa func=optimize
2024-12-02 13:36:39 [info     ] cost(depth 5 = -11.604492187500007 file=qaoa.qaoa func=optimize
</pre></div>
</div>
<img alt="_images/dba7e8258f9d89fc64bfd3f3c3b91bf70d63d67c7afa4f65295018de08dfbf27.png" src="_images/dba7e8258f9d89fc64bfd3f3c3b91bf70d63d67c7afa4f65295018de08dfbf27.png" />
</div>
</div>
</section>
<section id="exercise-2-max-3-cut-using-the-full-hilbert-space">
<h3>Exercise 2: Max 3-Cut using the full Hilbert space<a class="headerlink" href="#exercise-2-max-3-cut-using-the-full-hilbert-space" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><u>Find the circuit with pen and paper</u></p></li>
</ol>
<p>Given <span class="math notranslate nohighlight">\(\operatorname{clr}^3_{&lt; 3}\)</span> we now want to devide the states into the following sets (containing power of two states),</p>
<ul class="simple">
<li><p>set one consist of <span class="math notranslate nohighlight">\(\ket{1011}, \ket{1110}\)</span>, and</p></li>
<li><p>set two consists of <span class="math notranslate nohighlight">\(\ket{0000}, \ket{0101}, \ket{1010}, \ket{1111}, \)</span>.</p></li>
</ul>
<p>Apply Theorem 1 from <a class="reference internal" href="#1"><span class="xref myst">[1]</span></a> and work out what the circuit for an edge should look like, using pen and paper.</p>
<p>Are there any gates that cancel?</p>
<ol class="arabic simple" start="2">
<li><p><u>Specific problem implementation</ul></p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Max3CutFullH</span><span class="p">(</span><span class="n">GraphProblem</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">N_qubits_per_node</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">N_qubits_per_node</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;color1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;00&quot;</span><span class="p">],</span>
            <span class="s2">&quot;color2&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;01&quot;</span><span class="p">],</span>
            <span class="s2">&quot;color3&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="s2">&quot;11&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="c1"># Create a dictionary to map each index to its corresponding set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitstring_to_color</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bitstring_to_color</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">create_edge_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_qubits_per_node</span><span class="p">)</span>
        
        <span class="s2">&quot; ---------------------&quot;</span>
        <span class="s2">&quot; implement the circuit&quot;</span>
        <span class="s2">&quot; ---------------------&quot;</span>
        
        <span class="k">return</span> <span class="n">qc</span>

    <span class="k">def</span> <span class="nf">create_edge_circuit_fixed_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test</span> <span class="o">=</span> <span class="n">Max3CutFullH</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})]))</span>
<span class="n">test</span><span class="o">.</span><span class="n">create_edge_circuit</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Graph contains nodes with one or zero edges. These can be removed to reduce the size of the problem.
</pre></div>
</div>
<img alt="_images/7926e6bcb4749685955e8bc35fafed7bddf4deb6ba4bf46f7455e7123da89ad1.png" src="_images/7926e6bcb4749685955e8bc35fafed7bddf4deb6ba4bf46f7455e7123da89ad1.png" />
</div>
</div>
<ol class="arabic simple" start="3">
<li><p><u>Run QAOA</u></p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qaoa_k3_fullH</span> <span class="o">=</span> <span class="n">QAOA</span><span class="p">(</span><span class="n">initialstate</span><span class="o">=</span><span class="n">Plus</span><span class="p">(),</span> <span class="n">problem</span><span class="o">=</span><span class="n">Max3CutFullH</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">mixer</span><span class="o">=</span><span class="n">X</span><span class="p">(),</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qaoa_k3_fullH</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">]}</span> <span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">beta</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">angles</span> <span class="o">=</span> <span class="n">qaoa_k3_fullH</span><span class="o">.</span><span class="n">optimization_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">angles</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
    <span class="n">gamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">beta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="s2">&quot;x-k&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;wo&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;or&quot;</span><span class="p">)</span>
<span class="n">plot_E</span><span class="p">(</span><span class="n">qaoa_k3_fullH</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2024-12-02 13:36:39 [info     ] Calculating energy landscape for depth p=1... file=qaoa.qaoa func=sample_cost_landscape
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">IndexError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">18</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">qaoa_k3_fullH</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">]}</span> <span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span> <span class="n">gamma</span> <span class="o">=</span> <span class="p">[]</span>

<span class="nn">File c:\Users\rubenb\OneDrive - SINTEF\Desktop\test_qas\.venv\Lib\site-packages\qaoa\qaoa.py:451,</span> in <span class="ni">QAOA.optimize</span><span class="nt">(self, depth, angles)</span>
<span class="g g-Whitespace">    </span><span class="mi">449</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">450</span>     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Exp_sampled_p1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">451</span>         <span class="bp">self</span><span class="o">.</span><span class="n">sample_cost_landscape</span><span class="p">(</span><span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">452</span>     <span class="n">ind_Emin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">453</span>         <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Exp_sampled_p1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Exp_sampled_p1</span><span class="o">.</span><span class="n">shape</span>
<span class="g g-Whitespace">    </span><span class="mi">454</span>     <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">455</span>     <span class="n">angles0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">456</span>         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma_grid</span><span class="p">[</span><span class="n">ind_Emin</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_grid</span><span class="p">[</span><span class="n">ind_Emin</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="g g-Whitespace">    </span><span class="mi">457</span>     <span class="p">)</span>

<span class="nn">File c:\Users\rubenb\OneDrive - SINTEF\Desktop\test_qas\.venv\Lib\site-packages\qaoa\qaoa.py:352,</span> in <span class="ni">QAOA.sample_cost_landscape</span><span class="nt">(self, angles)</span>
<span class="g g-Whitespace">    </span><span class="mi">350</span>     <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Done measurement&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">351</span> <span class="k">else</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">352</span>     <span class="bp">self</span><span class="o">.</span><span class="n">createParameterizedCircuit</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">353</span>     <span class="n">gamma</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">angles</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">angles</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="g g-Whitespace">    </span><span class="mi">354</span>     <span class="n">beta</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">angles</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">angles</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

<span class="nn">File c:\Users\rubenb\OneDrive - SINTEF\Desktop\test_qas\.venv\Lib\site-packages\qaoa\qaoa.py:248,</span> in <span class="ni">QAOA.createParameterizedCircuit</span><span class="nt">(self, depth)</span>
<span class="g g-Whitespace">    </span><span class="mi">245</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
<span class="g g-Whitespace">    </span><span class="mi">246</span>     <span class="bp">self</span><span class="o">.</span><span class="n">gamma_params</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;gamma_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="g g-Whitespace">    </span><span class="mi">247</span>     <span class="n">tmp_circuit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span>
<span class="ne">--&gt; </span><span class="mi">248</span>         <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_params</span><span class="p">[</span><span class="n">d</span><span class="p">]},</span>
<span class="g g-Whitespace">    </span><span class="mi">249</span>         <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">250</span>     <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">251</span>     <span class="bp">self</span><span class="o">.</span><span class="n">parameterized_circuit</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">tmp_circuit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">253</span>     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">usebarrier</span><span class="p">:</span>

<span class="nn">File c:\Users\rubenb\OneDrive - SINTEF\Desktop\test_qas\.venv\Lib\site-packages\qiskit\circuit\parametertable.py:241,</span> in <span class="ni">ParameterView.__getitem__</span><span class="nt">(self, index)</span>
<span class="g g-Whitespace">    </span><span class="mi">239</span> <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="g g-Whitespace">    </span><span class="mi">240</span><span class="w">     </span><span class="sd">&quot;&quot;&quot;Get items.&quot;&quot;&quot;</span>
<span class="ne">--&gt; </span><span class="mi">241</span>     <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

<span class="ne">IndexError</span>: list index out of range
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">maxdepth</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">qaoa_k3_fullH</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">maxdepth</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qaoa_k3_fullH</span><span class="o">.</span><span class="n">get_Exp</span><span class="p">()))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">maxval</span><span class="o">=</span><span class="mi">12</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qaoa_k3_fullH</span><span class="o">.</span><span class="n">get_Exp</span><span class="p">())</span> <span class="o">/</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;depth&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Approx. ratio&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;QAOA Max 3-Cut using the full Hilber space&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-3-max-3-cut-using-subspaces">
<h3>Exercise 3: Max 3-Cut using subspaces<a class="headerlink" href="#exercise-3-max-3-cut-using-subspaces" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><u>Show that the Grover mixer is valid using pen and paper</u></p></li>
</ol>
<div class="math notranslate nohighlight">
\[
U_m(\beta) = e^{-i\beta \ket{F}\bra{F}}, \quad \text{where } U_S \ket{0} = \ket{F} := \frac{1}{\sqrt{|B|}} \sum_{x \in B} \ket{x}
\]</div>
<ol class="arabic simple" start="2">
<li><p><u>Create circuit for Grover mixer</u></p></li>
</ol>
<p>Using the package <code class="docutils literal notranslate"><span class="pre">qaoa</span></code> create a Grover mixer for <span class="math notranslate nohighlight">\(\ket{ltk3} = \frac{\ket{00} + \ket{01} + \ket{11}}{\sqrt{3}}\)</span>. For this we import the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qaoa.initialstates</span> <span class="kn">import</span> <span class="n">LessThanK</span>

<span class="n">ltk3</span> <span class="o">=</span> <span class="n">LessThanK</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ltk3</span><span class="o">.</span><span class="n">create_circuit</span><span class="p">()</span>
<span class="n">ltk3</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Create a circuit for <span class="math notranslate nohighlight">\(\ket{ltk3}^{\otimes 3}\)</span>. For this we can use the Tensor class.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qaoa.initialstates</span> <span class="kn">import</span> <span class="n">Tensor</span>

<span class="n">numNodes</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">phi0</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="n">ltk3</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">)</span>
<span class="n">phi0</span><span class="o">.</span><span class="n">create_circuit</span><span class="p">()</span>
<span class="n">phi0</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>create the Grover mixer for <span class="math notranslate nohighlight">\(\ket{ltk3}^{\otimes 3}\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qaoa.mixers</span> <span class="kn">import</span> <span class="n">Grover</span>
<span class="n">grover</span> <span class="o">=</span>
<span class="s2">&quot; ---------------------&quot;</span>
<span class="s2">&quot; define the Grover mixer&quot;</span>
<span class="s2">&quot; ---------------------&quot;</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="3">
<li><p><u>Numerically test that the Grover mixer is valid</u></p></li>
</ol>
<p>Show that we have a valid mixer by plotting the overlap <span class="math notranslate nohighlight">\(\bra{z_1} U_M(\beta) \ket{z_2}\)</span> depending on <span class="math notranslate nohighlight">\(\beta\)</span>:</p>
<ul class="simple">
<li><p>Pick two feasible computational basis states <span class="math notranslate nohighlight">\(\ket{z_1} \neq \ket{z_2}\)</span> and see that the overlap is nonzero for some values of <span class="math notranslate nohighlight">\(\beta\)</span></p></li>
<li><p>Pick a feasible and an infeasible state, and show that the overlap is always zero</p></li>
</ul>
<p>Let’s start by importing the necessary things, before we can do some plots.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pl</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">qiskit_aer</span> <span class="kn">import</span> <span class="n">Aer</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">QuantumRegister</span><span class="p">,</span>
    <span class="n">ClassicalRegister</span><span class="p">,</span>
    <span class="n">transpile</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">backend</span><span class="o">=</span><span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s2">&quot;qasm_simulator&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">overlap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">betavalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
<span class="n">shots</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="mi">5</span>
<span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">betavalues</span><span class="p">):</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">numNodes</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">numNodes</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="s2">&quot; ---------------------&quot;</span>
        <span class="s2">&quot; implement a circuit for &lt;z_1|&quot;</span>
        <span class="s2">&quot; ---------------------&quot;</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grover</span><span class="o">.</span><span class="n">circuit</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
    
    <span class="c1"># Assign float values to the parameters</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="n">parameter_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">beta</span><span class="p">]</span>
    <span class="n">bound_circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">parameter_values</span><span class="p">)))</span>

    
    <span class="c1"># Run the job</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">bound_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
    <span class="n">overlap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot; ---------------------&quot;</span>
        <span class="s2">&quot; choose string for |z_2&gt;&quot;</span>
        <span class="s2">&quot; ---------------------&quot;</span>
        <span class="p">,</span><span class="mf">0.</span><span class="p">)</span><span class="o">/</span><span class="n">shots</span><span class="p">)</span>
    
<span class="c1"># bound_circuit.draw(&#39;mpl&#39;)</span>

<span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">betavalues</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="4">
<li><p><u>Problem class </u></p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Max3Cut</span><span class="p">(</span><span class="n">GraphProblem</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">N_qubits_per_node</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">N_qubits_per_node</span><span class="p">)</span>

        <span class="c1"># each color is associated with a bitstring combination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;color1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;00&quot;</span><span class="p">],</span>
            <span class="s2">&quot;color2&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;01&quot;</span><span class="p">],</span>
            <span class="s2">&quot;color3&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;10&quot;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="c1"># Create a dictionary to map each index to its corresponding set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitstring_to_color</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bitstring_to_color</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">create_edge_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_qubits_per_node</span><span class="p">)</span>

        <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">phase_gate</span> <span class="o">=</span> <span class="n">PhaseGate</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phase_gate</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">qc</span>

        
    <span class="k">def</span> <span class="nf">create_edge_circuit_fixed_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># we will not use this function, so we can skip it</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="5">
<li><p><u>Initial state class</u></p></li>
</ol>
<p>To run QAOA we need to implement the <code class="docutils literal notranslate"><span class="pre">InitialState</span></code> class that creates a Tensor of <span class="math notranslate nohighlight">\(\ket{ltk3}\)</span> state, which can be done just as above</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qaoa.initialstates</span> <span class="kn">import</span> <span class="n">InitialState</span>
<span class="k">class</span> <span class="nc">Max3CutInitialState</span><span class="p">(</span><span class="n">InitialState</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">create_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">numQubitsPerNode</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_V</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_qubits</span><span class="o">/</span><span class="n">numQubitsPerNode</span><span class="p">)</span>
        
        <span class="n">tg</span> <span class="o">=</span> 
        
        <span class="s2">&quot; ---------------------&quot;</span>
        <span class="s2">&quot; define the initial state&quot;</span>
        <span class="s2">&quot; ---------------------&quot;</span>
        
        <span class="n">tg</span><span class="o">.</span><span class="n">create_circuit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">circuit</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="6">
<li><p><u>Mixer class</u></p></li>
</ol>
<p>We also need to implement the <code class="docutils literal notranslate"><span class="pre">Mixer</span></code> class that creates a Tensor of Grover mixer, which can be done just as above</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qaoa.mixers</span> <span class="kn">import</span> <span class="n">Mixer</span>
<span class="k">class</span> <span class="nc">Max3CutGrover</span><span class="p">(</span><span class="n">Mixer</span><span class="p">):</span>
        
    <span class="k">def</span> <span class="nf">create_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">numQubitsPerNode</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_V</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_qubits</span><span class="o">/</span><span class="n">numQubitsPerNode</span><span class="p">)</span>
        
        <span class="n">gm</span> <span class="o">=</span> 
        
        <span class="s2">&quot; ---------------------&quot;</span>
        <span class="s2">&quot; define the Box Grover mixer&quot;</span>
        <span class="s2">&quot; ---------------------&quot;</span>
        
        <span class="n">gm</span><span class="o">.</span><span class="n">create_circuit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">circuit</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="7">
<li><p><u>Run QAOA</u></p></li>
</ol>
<p>create an instance of QAOA and plot the resulting landscape</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qaoa_k3_subH</span> <span class="o">=</span> <span class="n">QAOA</span><span class="p">(</span>
    <span class="n">initialstate</span><span class="o">=</span><span class="n">Max3CutInitialState</span><span class="p">(),</span>
    <span class="n">problem</span><span class="o">=</span><span class="n">Max4Cut</span><span class="p">(</span><span class="n">G</span><span class="p">),</span>
    <span class="n">mixer</span><span class="o">=</span><span class="n">Max3CutGrover</span><span class="p">(),</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">)</span>

<span class="n">qaoa_k3_subH</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">]}</span> <span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">beta</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">angles</span> <span class="o">=</span> <span class="n">qaoa_k3_subH</span><span class="o">.</span><span class="n">optimization_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">angles</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
    <span class="n">gamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">beta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="s2">&quot;x-k&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;wo&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;or&quot;</span><span class="p">)</span>
<span class="n">plot_E</span><span class="p">(</span><span class="n">qaoa_k3_subH</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="8">
<li><p><u>Comparison for MAX 3-CUT</u></p></li>
</ol>
<p>Compare the convergence for the method using the full Hilbert space and the subspace encoding up to d</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">maxdepth</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">qaoa_k3_subH</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">maxdepth</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qaoa_k3_subH</span><span class="o">.</span><span class="n">get_Exp</span><span class="p">()))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">maxval</span><span class="o">=</span><span class="mi">12</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qaoa_k3_fullH</span><span class="o">.</span><span class="n">get_Exp</span><span class="p">())</span> <span class="o">/</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;full H&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qaoa_k3_subH</span><span class="o">.</span><span class="n">get_Exp</span><span class="p">())</span> <span class="o">/</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;sub H&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;depth&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Approx. ratio&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;QAOA Max 3-Cut comparison&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>For more info you can look into the following reference.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading"></a></h3>
<p><a id="1">[1]</a>
Fuchs, Franz G., Ruben P. Bassa, and Frida Lien.
“Encodings of the weighted MAX k-CUT on qubit systems.”
Preprint arXiv 2024.
<a class="reference external" href="https://doi.org/10.48550/arXiv.2411.08594">arXiv:2411.08594</a></p>
<p><a id="2">[2]</a>
Fuchs, Franz G., Ruben P. Bassa.
“LX-mixers for QAOA: Optimal mixers restricted to subspaces and the stabilizer formalism.”
Quantum 8 (2024): 1535.
<a class="reference external" href="https://doi.org/10.22331/q-2024-11-25-1535">10.22331/q-2024-11-25-1535</a></p>
<p><a id="3">[3]</a>
Bärtschi, Andreas, and Stephan Eidenbenz.
“Grover mixers for QAOA: Shifting complexity from mixer design to state preparation.”
In 2020 IEEE International Conference on Quantum Computing and Engineering (QCE), pp. 72-82. IEEE, 2020.
<a class="reference external" href="https://doi.org/10.1109/QCE49297.2020.00020">10.1109/QCE49297.2020.00020</a></p>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-notebooks/Decoding_excercise"></span><section class="tex2jax_ignore mathjax_ignore" id="tutorial-map-decoding-exercise">
<h2>Tutorial - MAP Decoding Exercise<a class="headerlink" href="#tutorial-map-decoding-exercise" title="Link to this heading"></a></h2>
<p>The goal of MAP decoding is to find the most probable error vector <code class="docutils literal notranslate"><span class="pre">e</span></code> given the syndrome <code class="docutils literal notranslate"><span class="pre">s</span></code>.
We optimize:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>max P(e | s)
</pre></div>
</div>
<p>Given the constraints from the parity-check matrix <code class="docutils literal notranslate"><span class="pre">H</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H @ e = s (mod 2)
</pre></div>
</div>
<p>Throughout the excercise we will assume that errors are iid with <span class="math notranslate nohighlight">\(p&lt;1/2\)</span>.</p>
<section id="map-decoding-for-7-4-hamming-code">
<h3>1. MAP Decoding for [7,4] Hamming code<a class="headerlink" href="#map-decoding-for-7-4-hamming-code" title="Link to this heading"></a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="c1"># Function to compute the syndrome for a given error vector</span>
<span class="k">def</span> <span class="nf">compute_syndrome</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="n">e</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Example of a parity-check matrix for a [7,4] Hamming code</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">])</span>

<span class="c1"># Define an error vector e</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">H</span><span class="nd">@e</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Received syndrome, s= &quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Received syndrome, s=  [1 1 0]
</pre></div>
</div>
</div>
</div>
</section>
<section id="exhaustive-map-decoding">
<h3>2. Exhaustive MAP Decoding<a class="headerlink" href="#exhaustive-map-decoding" title="Link to this heading"></a></h3>
<p>Now let’s assume we only received the syndrome <code class="docutils literal notranslate"><span class="pre">s</span></code> and want to find the most likely error vector <code class="docutils literal notranslate"><span class="pre">e</span></code></p>
<p>Let’s simulate the decoding process by searching through all possible error vectors.</p>
<ul class="simple">
<li><p>Generate all possible error vectors <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p></li>
<li><p>Check which satisfy <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">&#64;</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">s</span> <span class="pre">(mod</span> <span class="pre">2)</span></code>.</p></li>
<li><p>Among valid solutions, select the one with the smallest Hamming weight.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate all possible error vectors for n = 7</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">error_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">n</span><span class="p">)]</span>

<span class="c1"># Find all error vectors that satisfy H @ e = s (mod 2)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Valid error vectors, with weight:&quot;</span><span class="p">)</span>
<span class="n">valid_errors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">error_vectors</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">compute_syndrome</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">valid_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

<span class="c1"># Select the error vector with the smallest Hamming weight</span>
<span class="n">best_error</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">valid_errors</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Best error vector (minimum weight):&quot;</span><span class="p">,</span> <span class="n">best_error</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">best_error</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We needed to search&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_vectors</span><span class="p">),</span> <span class="s2">&quot;error vectors.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Valid error vectors, with weight:
[0 0 0 0 1 1 0] 2
[0 0 0 1 0 0 1] 2
[0 0 1 0 1 0 1] 3
[0 0 1 1 0 1 0] 3
[0 1 0 0 0 1 1] 3
[0 1 0 1 1 0 0] 3
[0 1 1 0 0 0 0] 2
[0 1 1 1 1 1 1] 6
[1 0 0 0 0 0 0] 1
[1 0 0 1 1 1 1] 5
[1 0 1 0 0 1 1] 4
[1 0 1 1 1 0 0] 4
[1 1 0 0 1 0 1] 4
[1 1 0 1 0 1 0] 4
[1 1 1 0 1 1 0] 5
[1 1 1 1 0 0 1] 5

Best error vector (minimum weight): [1 0 0 0 0 0 0] 1
We needed to search 128 error vectors.
</pre></div>
</div>
</div>
</div>
</section>
<section id="heuristic-approach-greedy-decoding">
<h3>3. Heuristic Approach: Greedy Decoding<a class="headerlink" href="#heuristic-approach-greedy-decoding" title="Link to this heading"></a></h3>
<p>Instead of checking all error vectors, we can approximate the solution using a greedy algorithm:</p>
<ul class="simple">
<li><p>Start with an initial guess (e.g., all zeros).</p></li>
<li><p>Iteratively flip bits to reduce the syndrome error.</p></li>
</ul>
<p>This is not guaranteed to find the optimal solution but can be faster in practice.</p>
<p>Observe that the number of steps varies with each run, and it can give solutions that do not minimize the weight.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Greedy decoding algorithm</span>
<span class="k">def</span> <span class="nf">greedy_decoder</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Start with no errors</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">steps</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">syndrome</span> <span class="o">=</span> <span class="n">compute_syndrome</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">syndrome</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
            <span class="k">break</span>  <span class="c1"># Decoded successfully</span>
        <span class="c1"># Find a bit to flip (choose one randomly for simplicity)</span>
        <span class="n">flip_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">syndrome</span> <span class="o">!=</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">e</span><span class="p">[</span><span class="n">flip_index</span><span class="p">]</span> <span class="o">^=</span> <span class="mi">1</span>  <span class="c1"># Flip the bit</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">steps</span>

<span class="c1"># Run the greedy decoder</span>
<span class="n">decoded_error</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">greedy_decoder</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Decoded error vector using heuristic:&quot;</span><span class="p">,</span> <span class="n">decoded_error</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of steps required:&quot;</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Decoded error vector using heuristic: [1 0 0 0 0 0 0]
Number of steps required: 2
</pre></div>
</div>
</div>
</div>
</section>
</section>
<span id="document-notebooks/css_code_steane"></span><section class="tex2jax_ignore mathjax_ignore" id="tutorial-fault-tolerant-quantum-computing-with-css-codes">
<h2>Tutorial - Fault-Tolerant Quantum Computing with CSS codes<a class="headerlink" href="#tutorial-fault-tolerant-quantum-computing-with-css-codes" title="Link to this heading"></a></h2>
<p>In this notebook we’ll explore how fault-tolerant quantum computing looks like at the <strong>circuit-level</strong>.</p>
<p>For our exploration we’ll introduce the <em>Steane Code</em>, proposed by Andrew Steane in 1996. It is a quantum code from the class of <em>Calderbank-Shor-Steane (CSS)</em> codes which was introduced in the lecture.</p>
<p>Our <strong>goal</strong> is to understand:</p>
<ul class="simple">
<li><p>How is a logical qubit prepared at the circuit-level?</p></li>
<li><p>How can we implement logical gates between those logical qubits?</p></li>
<li><p>How does the quantum error correction procedure looks like at the circuit-level?</p></li>
</ul>
<p>Let’s explore the Steane code! 🔭</p>
<section id="steane-code">
<h3>Steane Code<a class="headerlink" href="#steane-code" title="Link to this heading"></a></h3>
<p>The Steane code is a <span class="math notranslate nohighlight">\([[7,1,3]]\)</span> stabilizer code, which means that it encodes 7 physical qubits into 1 logical qubits. Its code distance is <span class="math notranslate nohighlight">\(d=3\)</span>, meaning that it will correct up to
$<span class="math notranslate nohighlight">\(t = \lfloor 3 - 1 /2 \rfloor = 1\)</span>$
errors.</p>
<section id="code-construction">
<h4>Code Construction<a class="headerlink" href="#code-construction" title="Link to this heading"></a></h4>
<p><strong>CSS codes:</strong></p>
<p>The class of Calderbank-Shor-Steane (CSS) codes provides a simple recipe of constructing quantum error correcting codes from classical <em>linear</em> codes.
In a linear <span class="math notranslate nohighlight">\([n,k]\)</span>-code <span class="math notranslate nohighlight">\(C\)</span>, the code space is defined by the kernel of a parity check matrix <span class="math notranslate nohighlight">\(H \in \mathbb{Z}_2^{n - k \times n}\)</span>.</p>
<p>Meaning that for a code word <span class="math notranslate nohighlight">\(x \in \mathbb{Z}_2^n\)</span>, we must have:</p>
<div class="math notranslate nohighlight">
\[Hx = 0.\]</div>
<p>Since we have to protect our quantum state from Pauli-<span class="math notranslate nohighlight">\(X\)</span> and Pauli-<span class="math notranslate nohighlight">\(Z\)</span> errors, CSS codes combine two classical linear codes <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span>. The respective parity check matrices <span class="math notranslate nohighlight">\(H_1\)</span> and <span class="math notranslate nohighlight">\(H_2\)</span> define the <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span> stabilizers. To emphasize this fact, we’ll denote the matrices as <span class="math notranslate nohighlight">\(H_X\)</span> and <span class="math notranslate nohighlight">\(H_Z\)</span>.</p>
<p>The rows of the parity check matrices define the stabilizer.</p>
<blockquote>
<div><p><strong>Example:</strong> If the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(H_X\)</span> is given as <span class="math notranslate nohighlight">\(1001\)</span> then the corresponding stabilizer is <span class="math notranslate nohighlight">\(X_1X_4 = X_1 \otimes I_2 \otimes I_3 \otimes X_4\)</span>.</p>
</div></blockquote>
<p>Since all stabilizers from the same parity check matrix necessarily commute, we need to make sure that rows from <span class="math notranslate nohighlight">\(H_X\)</span> and <span class="math notranslate nohighlight">\(H_Z\)</span> commute. This is ensured if the number of qubits targeted by both stabilizer types is even for each possible pair of stabilizers.</p>
<blockquote>
<div><p><strong>Example:</strong> <span class="math notranslate nohighlight">\(X_1X_2X_5X_6\)</span> and <span class="math notranslate nohighlight">\(Z_1Z_2Z_3Z_4\)</span> commute as they both target qubits 1 and 2 which is an even number of qubits.</p>
</div></blockquote>
<p><strong>Parity Check Matrix:</strong></p>
<p>For the Steane code, we have <span class="math notranslate nohighlight">\(H_X = H_Z = H\)</span> with</p>
<div class="math notranslate nohighlight">
\[\begin{split}H = \begin{bmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\end{split}\]</div>
<p><strong>Stabilizers:</strong></p>
<p>We can now define the generators of the stabilizer group corresponding to the Steane code based on <span class="math notranslate nohighlight">\(H\)</span>:</p>
<div class="math notranslate nohighlight">
\[S_X = \langle X_1X_2X_3X_4, X_2X_3X_5X_6, X_3X_4X_6X_7 \rangle\]</div>
<div class="math notranslate nohighlight">
\[S_Z = \langle Z_1Z_2Z_3Z_4, Z_2Z_3Z_5Z_6, Z_3Z_4Z_6Z_7 \rangle\]</div>
</section>
<section id="exercise-1">
<h4>Exercise 1<a class="headerlink" href="#exercise-1" title="Link to this heading"></a></h4>
<p>Given the stabilizers, write down a valid code state <span class="math notranslate nohighlight">\(|\psi \rangle = | \psi_1\rangle \otimes | \psi_2\rangle \otimes | \psi_3\rangle \otimes | \psi_4\rangle \otimes | \psi_5\rangle \otimes | \psi_6\rangle \otimes | \psi_7\rangle  \)</span> of the Steane code.</p>
<p>As a reminder, a valid code state is the simultaneous Eigenstate of all stabilizers such that:
$<span class="math notranslate nohighlight">\(S|\psi\rangle = |\psi\rangle \;\;\; \forall S \in S_X \cup S_Z\)</span>$</p>
<blockquote>
<div><p><strong>Tip:</strong> Any stabilizer can be decomposed into a product of generators. This means that only generators have to be considered when checking the stabilizing property.</p>
</div></blockquote>
</section>
<section id="visualizing-the-steane-code">
<h4>Visualizing the Steane Code<a class="headerlink" href="#visualizing-the-steane-code" title="Link to this heading"></a></h4>
<p>To think about the properties of quantum error correcting codes it is often beneficial to visualize them. In the picture below, the vertices represent the physical qubits. Each coloured face defines an <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizer.</p>
<p><img alt="Steane Code Plaquettes" src="_images/steane-code-stabilizers.png" /></p>
<p>Putting the stabilizers together we get triangle with three faces also called <em>plaquettes</em> in the literature.</p>
<p><img alt="Steane Code Lattice" src="_images/steane-code-lattice.png" /></p>
<p>Source: <a class="reference external" href="https://arthurpesah.me/blog/2023-01-31-stabilizer-formalism-1/">Arthur Pesah’s blog post on the stabilizer formalism</a>.</p>
</section>
<section id="excursion-stim-and-stabilizer-formalism">
<h4>Excursion: Stim and Stabilizer formalism<a class="headerlink" href="#excursion-stim-and-stabilizer-formalism" title="Link to this heading"></a></h4>
<p>To implement the Steane Code, we’ll use Stim, a stabilizer simulator developed by Google, which is used for quantum error corection research.</p>
<p>We’ll introduce the 3 most important objects, which are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PauliString</span></code>: Representation of a Pauli string such as <span class="math notranslate nohighlight">\(X_1X_4\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tableau</span></code>: A table holding the current stabilizers of a circuit.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Circuit</span></code>: Representation of quantum circuit similar to Qiskit.</p></li>
</ul>
<section id="pauli-strings">
<h5>Pauli Strings<a class="headerlink" href="#pauli-strings" title="Link to this heading"></a></h5>
<p>A Pauli string is an <span class="math notranslate nohighlight">\(n\)</span>-qubit operator formed by taking the tensor product of single-qubit Pauli operators:</p>
<div class="math notranslate nohighlight">
\[P = P_1 \otimes P_2 \otimes \cdots \otimes P_n, \quad \text{where } P_i \in \{I, X, Z, Y\}\]</div>
<p>For example, a two-qubit Pauli string might be <span class="math notranslate nohighlight">\(P = X \otimes Y\)</span>, often written as <span class="math notranslate nohighlight">\(XY\)</span>.</p>
<blockquote>
<div><p><strong>Note:</strong> We usually omit the identity gates, by adding indices. For example, for <span class="math notranslate nohighlight">\(P = X \otimes I \otimes Y\)</span> is written as <span class="math notranslate nohighlight">\(X_1Y_3\)</span>.</p>
</div></blockquote>
<p><strong>Efficient Encoding of Pauli Strings in Software:</strong></p>
<p>Stim is designed to allow the simulation of very large stabilizer codes, so an efficient representation on a computer is crucial.
There are 4 different single-qubit Pauli operators, so 2 bits are required to represent them. Stim uses the following encoding:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
enc(I) &amp;= 00 \\
enc(X) &amp;= 10 \\
enc(Z) &amp;= 01 \\
enc(Y) &amp;= 11
\end{align*}
\end{split}\]</div>
<p>This encoding is chosen to reflect the algebraic properties of Pauli operators, also called a <a class="reference external" href="https://en.wikipedia.org/wiki/Group_homomorphism"><strong>group homomorphism</strong></a>: <span class="math notranslate nohighlight">\(enc : (G_1,\cdot) \rightarrow (\mathbb{Z}_2^2,\oplus)\)</span>.</p>
<p>The first bit indicates the presence of an <span class="math notranslate nohighlight">\(X\)</span> operation, while the second bit indicates a <span class="math notranslate nohighlight">\(Z\)</span> operation. The <span class="math notranslate nohighlight">\(Y\)</span> operator, can be decomposed into <span class="math notranslate nohighlight">\(X \cdot Z\)</span> and has therefore both bits set to 1.</p>
<p>This enables multiplication of Pauli operators through simple bitwise operations. For two Pauli operators <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, their product (up to a global phase) is computed by:</p>
<div class="math notranslate nohighlight">
\[enc(A \cdot B) = enc(A) \oplus enc(B)\]</div>
<p>where <span class="math notranslate nohighlight">\(\oplus\)</span> represents bitwise XOR. For example:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
enc(X \cdot Y) &amp;= enc(X) \oplus enc(Y) \\
&amp;= 10 \oplus 11 \\
&amp;= 01 \\
&amp;= enc(Z)
\end{align*}
\end{split}\]</div>
<p>This matches the algebraic relation <span class="math notranslate nohighlight">\(XY = iZ\)</span> (ignoring the phase factor <span class="math notranslate nohighlight">\(i\)</span>).</p>
<p>Let’s explore Stim’s <a class="reference external" href="https://github.com/quantumlib/Stim/blob/main/doc/python_api_reference_vDev.md#stim.PauliString"><code class="docutils literal notranslate"><span class="pre">PauliString</span></code></a> API:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stim</span>

<span class="n">xx</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">PauliString</span><span class="p">(</span><span class="s2">&quot;+XX&quot;</span><span class="p">)</span>
<span class="n">zz</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">PauliString</span><span class="p">(</span><span class="s2">&quot;+ZZ&quot;</span><span class="p">)</span>

<span class="c1"># Pauli strings can be multiplied</span>
<span class="n">mul_res</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">*</span> <span class="n">zz</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Multiplication: XX * ZZ = &quot;</span><span class="p">,</span> <span class="n">mul_res</span><span class="p">)</span>

<span class="c1"># Pauli strings can be concatenated</span>
<span class="n">add_res</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">+</span> <span class="n">zz</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Addition: XX + ZZ = &quot;</span><span class="p">,</span> <span class="n">add_res</span><span class="p">)</span>

<span class="c1"># We can check if 2 Pauli strings commute</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;XX and ZZ commute: &quot;</span><span class="p">,</span> <span class="n">xx</span><span class="o">.</span><span class="n">commutes</span><span class="p">(</span><span class="n">zz</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="tableau">
<h5>Tableau<a class="headerlink" href="#tableau" title="Link to this heading"></a></h5>
<p>A tableau is the foundation of efficient simulation of stabilizer circuits. That is circuits, only composed of Clifford gates, mapping Pauli operators to other Pauli operators.</p>
<blockquote>
<div><p><strong>Reminder:</strong> a Clifford operator <span class="math notranslate nohighlight">\(C\)</span>, applied to a product of Pauli’s <span class="math notranslate nohighlight">\(P\)</span>, maps it to <span class="math notranslate nohighlight">\(CPC^{\dagger}\)</span> which is again a Pauli product.</p>
</div></blockquote>
<p>During execution of a quantum circuit consisting only of Clifford gates, we only need to update the stabilizer generator Pauli strings by applying the update rule above. With our efficient encoding, this can be done very fast.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define a Tableau simulator</span>
<span class="n">simulator</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">TableauSimulator</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Prepare GHZ state</span>
<span class="n">simulator</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">simulator</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">simulator</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">simulator</span><span class="o">.</span><span class="n">measure_many</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>While it is important to understand how the Tableau works, Stim’s Tableau is heavily optimized which increases it’s complexity. A nice introduction on Tableau simulation is given by Aaronson and Gottesman in <a class="reference external" href="https://arxiv.org/pdf/quant-ph/0406196">“Improved Simulation of Stabilizer Circuits”</a>.</p>
<p>For now, we are happy that we can apply gates to the Tableau and obtain correct measurements.</p>
</section>
<section id="circuit">
<h5>Circuit<a class="headerlink" href="#circuit" title="Link to this heading"></a></h5>
<p>Stim allows us to also define quantum circuits with a API like Qiskit or Cirq. Below we create the same 3 qubit circuit preparing a GHZ state.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>

<span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>We can print the circuit using the <code class="docutils literal notranslate"><span class="pre">diagram</span></code> method of <code class="docutils literal notranslate"><span class="pre">stim.Circuit</span></code>.</p>
<p>There are different options to print the circuit:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">timeline-text</span></code>: ASCII diagram</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timeline-svg</span></code>: SVG image</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timeline-svg-html</span></code>: Resizable SVG image</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timeline-3d-html</span></code>: A 3d model, in GLTF format embedded in HTML</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timeslice-svg</span></code>: Prints circuit between “TICK” operations (more on that later)</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeline-text&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can sample from the circuit by compiling a sampler</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sampler</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">compile_sampler</span><span class="p">()</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">shots</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As expected roughly half of our measurements are <span class="math notranslate nohighlight">\(00\)</span> and the other half is <span class="math notranslate nohighlight">\(11\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span>
</pre></div>
</div>
</div>
</div>
<p>We can also execute the circuit with a Tableau simulator:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reset all qubits</span>
<span class="n">simulator</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">simulator</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># All measurements are stored in the measurement record of the Tableau simulator</span>
<span class="n">simulator</span><span class="o">.</span><span class="n">current_measurement_record</span><span class="p">()[</span><span class="o">-</span><span class="mi">3</span><span class="p">::]</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="logical-operators-of-the-steane-code">
<h4>Logical Operators of the Steane Code<a class="headerlink" href="#logical-operators-of-the-steane-code" title="Link to this heading"></a></h4>
<p>The Steane code has exactly 6 stabilizer generators, imposing independent constraints on the logical qubit state:
$<span class="math notranslate nohighlight">\(S|\psi\rangle = |\psi\rangle \;\;\; \forall S \in S_X \cup S_Z\)</span>$</p>
<p>Intuitively, this means that for <span class="math notranslate nohighlight">\(7\)</span> qubits we have <strong>1 degree of freedom</strong> left, meaning that the Steane code encodes a single logical qubit.</p>
<blockquote>
<div><p>It can be <a class="reference external" href="https://arthurpesah.me/blog/2023-03-16-stabilizer-formalism-2/">shown</a>, that for <span class="math notranslate nohighlight">\(m\)</span> stabilizers and <span class="math notranslate nohighlight">\(n\)</span> qubits, the number of logical qubits is <span class="math notranslate nohighlight">\(k = n - m\)</span>.</p>
</div></blockquote>
<p>Assuming, that we have found a logical operator <span class="math notranslate nohighlight">\(O_L\)</span>, then applying it to the logical qubit should result in another valid code state.
We can express this condition as:</p>
<div class="math notranslate nohighlight">
\[O_L\ket{\psi} = O_LS\ket{\psi} = \ket{\psi}\]</div>
<p>Therefore <span class="math notranslate nohighlight">\(O_LS\)</span> must be a stabilizer and the following must hold</p>
<div class="math notranslate nohighlight">
\[O_LSO_L^{\dagger} = \hat{S} \in S_X \cup S_Z\]</div>
<p>As a reminder, the stabilizer generators for the Steane code are
$<span class="math notranslate nohighlight">\(S_X = \langle X_1X_2X_3X_4, X_2X_3X_5X_6, X_3X_4X_6X_7 \rangle\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(S_Z = \langle Z_1Z_2Z_3Z_4, Z_2Z_3Z_5Z_6, Z_3Z_4Z_6Z_7 \rangle\)</span>$</p>
<p>We can see that the operators</p>
<div class="math notranslate nohighlight">
\[X_L = X_5X_6X_7 \;\;\;\; Z_L = Z_5Z_6Z_7\]</div>
<p>satisfy the conditions above. We have found logical <span class="math notranslate nohighlight">\(X_L\)</span> and <span class="math notranslate nohighlight">\(Z_L\)</span> operators!</p>
<blockquote>
<div><p><strong>Note:</strong> Although it is custom to denote the Pauli string containing Pauli-<span class="math notranslate nohighlight">\(Z\)</span> as <span class="math notranslate nohighlight">\(Z_L\)</span>, the naming is completely arbitrary. We only care about the algebraic properties of the operators.</p>
</div></blockquote>
<section id="exercise-2">
<h5>Exercise 2<a class="headerlink" href="#exercise-2" title="Link to this heading"></a></h5>
<p><strong>(a)</strong> Verify in Stim, that the logical operators map the set of generators to itself and that <span class="math notranslate nohighlight">\(X_L\)</span> and <span class="math notranslate nohighlight">\(Z_L\)</span> anti-commute.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">stim</span> <span class="kn">import</span> <span class="n">PauliString</span>

<span class="n">steane_stabilizer</span> <span class="o">=</span> <span class="p">[</span>
  <span class="n">PauliString</span><span class="p">(</span><span class="s2">&quot;XXXXIII&quot;</span><span class="p">),</span>
  <span class="n">PauliString</span><span class="p">(</span><span class="s2">&quot;IXXIXXI&quot;</span><span class="p">),</span>
  <span class="n">PauliString</span><span class="p">(</span><span class="s2">&quot;IIIXXXX&quot;</span><span class="p">),</span>
  <span class="n">PauliString</span><span class="p">(</span><span class="s2">&quot;ZZZZIII&quot;</span><span class="p">),</span>
  <span class="n">PauliString</span><span class="p">(</span><span class="s2">&quot;IZZIZZI&quot;</span><span class="p">),</span>
  <span class="n">PauliString</span><span class="p">(</span><span class="s2">&quot;IIIZZZZ&quot;</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">log_x</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># TODO</span>
<span class="n">log_z</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># TODO</span>

<span class="c1"># Conjugate the stabilizers one by one with the logical observables and compare the lists</span>
<span class="n">conj_log_x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">conj_log_z</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">display</span><span class="p">(</span><span class="n">conj_log_x</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">conj_log_z</span><span class="p">)</span>

<span class="c1"># Logical operators anti-commute</span>
<span class="c1"># TODO</span>
</pre></div>
</div>
</div>
</div>
<p><strong>(b)</strong> Applying a stabilizer to a logical qubit does not change its state. This means that logical observables form equivalence classes modulus the stabilizers. Use Stim to find equivalent logical observables</p>
<p><img alt="Steane Logical Co-Sets" src="_images/steane-code-logical-cosets.png" /></p>
<p>Source: <a class="reference external" href="https://arthurpesah.me/blog/2023-01-31-stabilizer-formalism-1/">Arthur Pesah’s blog post on the stabilizer formalism</a>.</p>
<p><strong>(c) - Pen &amp; Paper</strong>
The Steane code is a CSS code, meaning that logical Clifford gates can be performed <em>transversally</em>. Verify that <span class="math notranslate nohighlight">\(H_L = H^{\otimes 7}\)</span> is a logical operator. Then show that it correspond to a logical Hadamard based on how it acts on <span class="math notranslate nohighlight">\(X_L\)</span> and <span class="math notranslate nohighlight">\(Z_L\)</span>.</p>
<blockquote>
<div><p><strong>Note:</strong> In the same manner it can be shown that <span class="math notranslate nohighlight">\(S_L = S^{\otimes 7}\)</span> implement the logical <span class="math notranslate nohighlight">\(S_L\)</span> operator.</p>
</div></blockquote>
</section>
</section>
</section>
<section id="quantum-computing-with-logical-qubits">
<h3>Quantum Computing with Logical Qubits<a class="headerlink" href="#quantum-computing-with-logical-qubits" title="Link to this heading"></a></h3>
<section id="state-initialization">
<h4>State Initialization<a class="headerlink" href="#state-initialization" title="Link to this heading"></a></h4>
<p>Quantum circuits usually expect their qubits to be initialized in state <span class="math notranslate nohighlight">\(\ket{0}\)</span>. Unfortunately, <span class="math notranslate nohighlight">\(\ket{0000000}\)</span> is not a valid code state.</p>
<blockquote>
<div><p><strong>Question</strong>: Which stabilizers do not stabilize this state?</p>
</div></blockquote>
<p>Therefore, an important, but usually costly, part of QEC is the logical qubit initialization. A naive approach is to prepare the physical qubits in state <span class="math notranslate nohighlight">\(\ket{0}\)</span> and measure all stabilizers.</p>
<blockquote>
<div><p><strong>Question:</strong> How many entangling gates are needed to measure all stabilizers of the Steane code naively in sequence?</p>
</div></blockquote>
<p>To allow for fault-tolerant preparation of the logical qubit, avoiding spreading of errors due to entangling gates, various efficient schemes have been developed.</p>
<p>In the following we provide code for a scheme proposed by <a class="reference external" href="https://www.nature.com/articles/srep19578">Goto</a>.</p>
<p>The scheme requires 8 CNOT gates to prepare the state, followed by a measurement of <span class="math notranslate nohighlight">\(Z_L\)</span> via 3 CNOT gates using an ancilla qubit. If the measured ancilla is in the state <span class="math notranslate nohighlight">\(|0\rangle\)</span> then we succesfully prepared the state <span class="math notranslate nohighlight">\(|0\rangle_L\)</span>, otherwise we reset all qubits and repeat the procedure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">encoding_circuit</span><span class="p">(</span><span class="n">log_qb_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Encoding scheme proposed by Goto 2015: https://www.nature.com/articles/srep19578</span>
<span class="sd">  To prepare the logical Steane qubit in state |0&gt;_L.</span>
<span class="sd">  </span>
<span class="sd">  The qubit index allows shifting the indices so that we can prepare multiple logical qubits</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  <span class="c1"># shift registers to target logical qubit with given index</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">log_qb_idx</span> <span class="o">*</span> <span class="mi">8</span>
  
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">6</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  
  <span class="c1"># Entangle with ancilla qubit and measure logical Pauli-Z</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">7</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">7</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="mi">7</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>

  <span class="k">return</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</div>
<p>The encoding circuit can be visualized in Stim by printing the <code class="docutils literal notranslate"><span class="pre">diagram</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeline-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Given the encoding scheme, we should verify if it actually prepares a state with the correct stabilizers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">to_tableau</span><span class="p">(</span><span class="n">ignore_measurement</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stabilizers&quot;</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">to_stabilizers</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We can see that the state prepared by the circuit is stabilized by
$<span class="math notranslate nohighlight">\(X_1X_2X_3X_4,\;\;X_2X_3X_5X_6,\;\;X_3X_4X_6X_7\)</span>$</p>
<p>What about the Pauli-<span class="math notranslate nohighlight">\(Z\)</span> stabilizers?</p>
<p>The <a class="reference external" href="https://www.nature.com/articles/srep19578">Goto scheme</a>, prepares the <span class="math notranslate nohighlight">\(|0\rangle_L\)</span> state by measuring only the <span class="math notranslate nohighlight">\(Z\)</span>-stabilizers. Since arbitrary Pauli-<span class="math notranslate nohighlight">\(Z\)</span> errors are in this case equivalent to no errors or single-qubit <span class="math notranslate nohighlight">\(Z\)</span> errors which can be corrected by the Steane code.</p>
<p>As a final sanity check, we can sample shots from the circuit and measure <span class="math notranslate nohighlight">\(Z_L\)</span>. In the absence of noise, we should prepare the state <span class="math notranslate nohighlight">\(|0\rangle_L\)</span> with 100% success rate.</p>
<p>To avoid code repetition, let’s first define a method that takes a circuit, samples from it, and returns the measurements</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">measure_logical_qubits</span><span class="p">(</span><span class="n">log_qubit_indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  
  <span class="k">for</span> <span class="n">log_qubit_index</span> <span class="ow">in</span> <span class="n">log_qubit_indices</span><span class="p">:</span>
    <span class="c1"># shift index</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">log_qubit_index</span> <span class="o">*</span> <span class="mi">8</span>
    <span class="c1"># final measurement</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">shots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
  <span class="c1"># compile a sampler and sample 10 shots</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">compile_sampler</span><span class="p">()</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
  
  <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
</div>
</div>
<section id="exercise-3">
<h5>Exercise 3<a class="headerlink" href="#exercise-3" title="Link to this heading"></a></h5>
<p>Given the helper function above, complete the circuit above to correctly compute the logical <span class="math notranslate nohighlight">\(Z_L\)</span> measurement result given the measurements of the physical qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># prepare |0&gt;_L</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">()</span>
<span class="c1"># append final measurement</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">measure_logical_qubits</span><span class="p">()</span>
<span class="c1"># sample from circuit</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># compute Z_L observable from measurement</span>
<span class="n">logical_measurement_output</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># TODO</span>
</pre></div>
</div>
</div>
</div>
<p>Note, that the first column of <code class="docutils literal notranslate"><span class="pre">r</span></code> corresponds to the ancilla qubit measurement and not the first qubit!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Logical measurement outcome: &quot;</span><span class="p">,</span> <span class="n">logical_measurement_output</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As there is no noise, the ancilla should always be measured in state <span class="math notranslate nohighlight">\(|0\rangle\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ancilla qubit measurement outcome: &quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="different-basis-state-preparation">
<h4>Different Basis State Preparation<a class="headerlink" href="#different-basis-state-preparation" title="Link to this heading"></a></h4>
<p>We can prepare the state <span class="math notranslate nohighlight">\(| 0 \rangle_L\)</span> with the method above. Next, we’ll want to prepare the logical qubit in different basis states</p>
<div class="math notranslate nohighlight">
\[ \{ |0\rangle_L, |1\rangle_L, |+\rangle_L, |-\rangle_L, |+i\rangle_L, |-i\rangle_L \} \]</div>
<p>This can easily be done by using the logical gates <span class="math notranslate nohighlight">\(X_L, Z_L, S_L\)</span>, and <span class="math notranslate nohighlight">\(H_L\)</span>, that we identified in the previous section.</p>
<section id="exercise-4">
<h5>Exercise 4<a class="headerlink" href="#exercise-4" title="Link to this heading"></a></h5>
<p>Complete the lines marked with <code class="docutils literal notranslate"><span class="pre">TODO</span></code> in the function below (Always add the index shift <code class="docutils literal notranslate"><span class="pre">s</span></code> to prepare for operations on multiple logical qubits!)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">log_qb_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Supported logical gates:</span>
<span class="sd">        - &quot;Z&quot;: Logical Z gate</span>
<span class="sd">        - &quot;X&quot;: Logical X gate</span>
<span class="sd">        - &quot;H&quot;: Logical Hadamard gate</span>
<span class="sd">        - &quot;S&quot;: Logical S (phase) gate</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        c (stim.Circuit): The stim Circuit object to append the logical gate to</span>
<span class="sd">        gate (str): The name of the logical gate to apply. Must be one of: &quot;Z&quot;, &quot;X&quot;, &quot;H&quot;, &quot;S&quot;</span>
<span class="sd">        log_qb_idx (int, optional): Index of the logical qubit to operate on. Used to offset the</span>
<span class="sd">            physical qubit indices when working with multiple logical qubits. Defaults to 0.</span>
<span class="sd">            Each logical qubit uses 8 physical qubits (7 data + 1 ancilla).</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        stim.Circuit: The modified circuit with the logical gate appended</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  <span class="c1"># shift registers to target logical qubit with given index</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">log_qb_idx</span> <span class="o">*</span> <span class="mi">8</span>
  
  <span class="k">match</span> <span class="n">gate</span><span class="p">:</span>
    <span class="k">case</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
      <span class="c1"># TODO</span>
      <span class="k">pass</span>
    <span class="k">case</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
      <span class="c1"># TODO</span>
      <span class="k">pass</span>
    <span class="k">case</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span>
      <span class="c1"># TODO</span>
      <span class="k">pass</span>
    <span class="k">case</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
      <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">case</span> <span class="s2">&quot;S_DAG&quot;</span><span class="p">:</span>
      <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;S_DAG&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Logical gate name &#39;</span><span class="si">{logical_gate}</span><span class="s2">&#39; undefined&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</div>
<p>We define a helper function to prepare the logical qubit in the Eigenstate of a given Stabilizer</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prepare_stab_eigenstate</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Generates a circuit preparing the Eigenstate of a given singe-qubit stabilizer&quot;&quot;&quot;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  
  <span class="k">match</span> <span class="n">stabilizer</span><span class="p">:</span>
    <span class="k">case</span> <span class="s2">&quot;+Z&quot;</span><span class="p">:</span> <span class="c1"># |0&gt;</span>
      <span class="k">pass</span>
    <span class="k">case</span> <span class="s2">&quot;-Z&quot;</span><span class="p">:</span> <span class="c1"># |1&gt;</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="s2">&quot;+X&quot;</span><span class="p">:</span> <span class="c1"># |+&gt;</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="s2">&quot;-X&quot;</span><span class="p">:</span> <span class="c1"># |-&gt;</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="s2">&quot;+Y&quot;</span><span class="p">:</span> <span class="c1"># |+i&gt;</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="s2">&quot;-Y&quot;</span><span class="p">:</span> <span class="c1"># |-i&gt;</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown stabilizer </span><span class="si">{</span><span class="n">stabilizer</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
  <span class="k">return</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s test the state preparation for our logical qubit when measuring in the <span class="math notranslate nohighlight">\(Z_L\)</span> basis</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># prepare |0&gt;_L</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">()</span>
<span class="c1"># apply a bit-flip</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="c1"># append final measurement</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">measure_logical_qubits</span><span class="p">()</span>
<span class="c1"># sample from circuit</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">logical_measurement_output</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Logical bit-flip measurement outcome: &quot;</span><span class="p">,</span> <span class="n">logical_measurement_output</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># prepare |0&gt;_L</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">()</span>
<span class="c1"># apply a logical Hadamard gate</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">prepare_stab_eigenstate</span><span class="p">(</span><span class="s2">&quot;-Z&quot;</span><span class="p">)</span>
<span class="c1"># append final measurement</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">measure_logical_qubits</span><span class="p">()</span>
<span class="c1"># sample from circuit</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># compute Z_L observable from measurement</span>
<span class="n">logical_measurement_output</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Logical Hadamard measurement outcome: &quot;</span><span class="p">,</span> <span class="n">logical_measurement_output</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># prepare |0&gt;_L</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">()</span>
<span class="c1"># apply a logical X by using logical HZH construction</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
<span class="c1"># append final measurement</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">measure_logical_qubits</span><span class="p">()</span>
<span class="c1"># sample from circuit</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># compute Z_L observable from measurement</span>
<span class="n">logical_measurement_output</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Logical bit-flip measurement outcome: &quot;</span><span class="p">,</span> <span class="n">logical_measurement_output</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Based on the results above, we can see that logical operators works as expected and that we prepare any state that we interested in.</p>
</section>
</section>
<section id="measuring-in-different-basis">
<h4>Measuring in different Basis<a class="headerlink" href="#measuring-in-different-basis" title="Link to this heading"></a></h4>
<p>To measure a qubit in a different basis we usually apply single-qubit rotations before the measurement in the <span class="math notranslate nohighlight">\(Z\)</span>-basis.</p>
<p>For example, if we want to measure in the <span class="math notranslate nohighlight">\(X\)</span>-basis we need to apply a Hadamard gate before the measurement since</p>
<div class="math notranslate nohighlight">
\[\langle \psi | H Z H | \psi \rangle = \langle \psi | X | \psi \rangle \]</div>
<section id="exercise-5">
<h5>Exercise 5<a class="headerlink" href="#exercise-5" title="Link to this heading"></a></h5>
<p>Complete the lines marked with <code class="docutils literal notranslate"><span class="pre">TODO</span></code> in the function below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rotate_to_measurement_basis</span><span class="p">(</span><span class="n">meas_basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Appends single-qubit rotations to a circuit to prepare measurement in specified basis&quot;&quot;&quot;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  
  <span class="k">match</span> <span class="n">meas_basis</span><span class="p">:</span>
    <span class="k">case</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="k">case</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
      <span class="c1"># TODO</span>
      <span class="k">pass</span>
    <span class="k">case</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;S_DAG&quot;</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified target basis not known&quot;</span><span class="p">)</span>
    
  <span class="k">return</span> <span class="n">c</span> 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># prepare |0&gt;_L</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">()</span>
<span class="c1"># rotate to X-basis</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">rotate_to_measurement_basis</span><span class="p">(</span><span class="n">meas_basis</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="c1"># append final measurement</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">measure_logical_qubits</span><span class="p">()</span>
<span class="c1"># sample from circuit</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># compute Z_L observable from measurement</span>
<span class="n">logical_measurement_output</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Logical bit-flip measurement outcome: &quot;</span><span class="p">,</span> <span class="n">logical_measurement_output</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="transversal-gates">
<h4>Transversal gates<a class="headerlink" href="#transversal-gates" title="Link to this heading"></a></h4>
<p>We have now a good understanding of how to manipulate a single logical qubit. To leverage quantum advantage in the future, we will also need to be able to entangle our logical qubits.</p>
<p>In this section we are going to implement a logical CNOT gate. Then, we’ll put everything together to prepare a logical GHZ state using 14 + 2 physical qubits:
$<span class="math notranslate nohighlight">\(\ket{GHZ}_L = \frac{1}{\sqrt{2}}\left(\ket{00}_L + \ket{11}_L\right)\)</span>$</p>
<p>In a first step, we prepare the state <span class="math notranslate nohighlight">\(|0\rangle_L \otimes |0\rangle_L\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># prepare |0&gt;_L x |0&gt;_L</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">(</span><span class="n">log_qb_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">(</span><span class="n">log_qb_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeline-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="logical-cnot-implementation">
<h5>Logical CNOT Implementation<a class="headerlink" href="#logical-cnot-implementation" title="Link to this heading"></a></h5>
<p>As shown in the lecture, CSS codes allow for transversal implementation of logical entangling gates such as the logical CNOT gate.
In the Steane code the logical transversal CNOT gate is simply the pairwise CNOT between physical qubits at the same index of their respective logical qubit.</p>
<p>Let’s write a method that implements the logical CNOT:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">logical_cnot</span><span class="p">(</span><span class="n">ctrl_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">target_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Implement a transversal CNOT by applying CNOT between physical qubits of the logical qubits</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">ctrl_idx</span> <span class="o">==</span> <span class="n">target_idx</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Control index cannot be equal target index&quot;</span><span class="p">)</span>
  
  <span class="n">offset_ctrl</span> <span class="o">=</span> <span class="n">ctrl_idx</span> <span class="o">*</span> <span class="mi">8</span>
  <span class="n">offset_target</span> <span class="o">=</span> <span class="n">target_idx</span> <span class="o">*</span> <span class="mi">8</span>
  
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">offset_ctrl</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">offset_target</span><span class="p">])</span>
  
  <span class="k">return</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</div>
<p>Before applying the logical CNOT, we flip the control logical qubit to be able to test our gate</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">+=</span> <span class="n">logical_cnot</span><span class="p">(</span><span class="n">ctrl_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">+=</span> <span class="n">measure_logical_qubits</span><span class="p">(</span><span class="n">log_qubit_indices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">c</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeline-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logical_measurement_output_qb1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">8</span><span class="p">]</span>
<span class="n">logical_measurement_output_qb2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">logical_measurement_output_qb1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">logical_measurement_output_qb2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="logical-bell-state">
<h4>Logical Bell State<a class="headerlink" href="#logical-bell-state" title="Link to this heading"></a></h4>
<p>Now, we have all tools to implement a logical Bell state!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># prepare |0&gt;_L x |0&gt;_L</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">(</span><span class="n">log_qb_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">encoding_circuit</span><span class="p">(</span><span class="n">log_qb_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Apply Hadamard to first qubit</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">logical_single_qubit_gate</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="n">log_qb_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># Apply logical CNOT</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">logical_cnot</span><span class="p">(</span><span class="n">ctrl_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Add final measurements</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">measure_logical_qubits</span><span class="p">(</span><span class="n">log_qubit_indices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Optionally display the circuit</span>
<span class="n">c</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeline-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># sample and extract states</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="n">logical_measurement_output_qb1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">8</span><span class="p">]</span>
<span class="n">logical_measurement_output_qb2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">logical_measurement_output_qb1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">logical_measurement_output_qb2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="optional-simulating-the-steane-code-on-noisy-hardware-quantinuum-experiment">
<h3>Optional: Simulating the Steane Code on noisy Hardware: Quantinuum Experiment<a class="headerlink" href="#optional-simulating-the-steane-code-on-noisy-hardware-quantinuum-experiment" title="Link to this heading"></a></h3>
<p>The Steane code has been realized in various experiments:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.science.org/doi/10.1126/science.1253742">Quantum computations on a topologically encoded qubit</a>, 2014, Nigg et al.</p></li>
<li><p><a class="reference external" href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.11.041058">Realization of Real-Time Fault-Tolerant Quantum Error Correction</a>, 2021</p></li>
<li><p><a class="reference external" href="https://arxiv.org/html/2404.02280v1">Demonstration of logical qubits and repeated error correction with better-than-physical error rates</a>, 2024</p></li>
</ul>
<p>In the following, we provide code to simulate parts of the experiment by Quantinuum in 2021, where they implemented a single logical qubit on their ion-trap device and applied multiple rounds of error correction to it.</p>
<p>This will hopefully give you a better understanding of how rounds of quantum error correction are actually implemented and how errors are handled. Please refer to the paper to learn more about the details of the experiment. Happy exploring!</p>
<section id="introducing-errors">
<h4>Introducing Errors<a class="headerlink" href="#introducing-errors" title="Link to this heading"></a></h4>
<section id="quantinuum-error-parameters">
<h5>Quantinuum error parameters<a class="headerlink" href="#quantinuum-error-parameters" title="Link to this heading"></a></h5>
<p>In their experiment, Quantinuum measured various error sources for their ion-trap device.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Error Channel</p></th>
<th class="head"><p>Probability</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Initilization</p></td>
<td><p>Bit flip</p></td>
<td><p><span class="math notranslate nohighlight">\(1.66 \cdot 10^{-6}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Measurement</p></td>
<td><p>Bit flip</p></td>
<td><p><span class="math notranslate nohighlight">\(2.4 \cdot  10^{-3}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Single-qubit gate</p></td>
<td><p>Depolarizing</p></td>
<td><p><span class="math notranslate nohighlight">\(7 \cdot 10^{-5}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Two-qubit gate</p></td>
<td><p>Depolarizing</p></td>
<td><p><span class="math notranslate nohighlight">\(3.1 \cdot 10^{-3}\)</span></p></td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> We excluded non-Pauli channels, such as leakage, as they cannot be handled by Stim.</p>
<p>Below, we define a helper function that allows us to inject the noise defined in the paper into our circuits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NoiseModel</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Applies noise to quantum circuits.</span>
<span class="sd">   </span>
<span class="sd">   Adds depolarizing noise after 1 and 2-qubit gates, measurement errors,</span>
<span class="sd">   and initialization errors based on typical superconducting qubit parameters.</span>
<span class="sd">   &quot;&quot;&quot;</span>
  
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_error</span> <span class="o">=</span> <span class="mf">1.66</span> <span class="o">*</span> <span class="mf">1e-6</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">meas_error</span> <span class="o">=</span> <span class="mf">2.4</span> <span class="o">*</span> <span class="mf">1e-3</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">depolarize1</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="mf">1e-5</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">depolarize2</span> <span class="o">=</span> <span class="mf">3.1</span> <span class="o">*</span> <span class="mf">1e-3</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">c</span>
    
    <span class="n">cn</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;CX&quot;</span><span class="p">:</span>
        <span class="n">cn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;S_DAG&quot;</span><span class="p">]:</span>
          <span class="n">cn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DEPOLARIZE1&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">targets_copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">depolarize1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
          <span class="n">cn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;X_ERROR&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">targets_copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">meas_error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
          <span class="n">cn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;X_ERROR&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">targets_copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_error</span><span class="p">)</span>
      
      <span class="k">else</span><span class="p">:</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">targets_copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">control</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">cn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CX&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">control</span><span class="p">,</span> <span class="n">target</span><span class="p">])</span>
            <span class="n">cn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DEPOLARIZE2&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">control</span><span class="p">,</span> <span class="n">target</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">depolarize2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cn</span>
        
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noise</span> <span class="o">=</span> <span class="n">NoiseModel</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="faulty-logical-state-preparation">
<h4>Faulty logical state preparation<a class="headerlink" href="#faulty-logical-state-preparation" title="Link to this heading"></a></h4>
<p>To test our noise model, we apply it to the Goto scheme. We expect to see some state preparation failures.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># prepare |0&gt;_L</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">noise</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">encoding_circuit</span><span class="p">())</span>
<span class="c1"># append final measurement</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">measure_logical_qubits</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s2">&quot;timeline-svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_shots</span> <span class="o">=</span> <span class="mi">100_000</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sample_from_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">num_shots</span><span class="p">)</span>

<span class="c1"># compute Z_L observable from measurement</span>
<span class="n">logical_measurement_output</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Measure how often the ancilla qubit is measured in state |0&gt;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success rate: &quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">num_shots</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="s2">&quot;%&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="syndrome-extraction">
<h4>Syndrome extraction<a class="headerlink" href="#syndrome-extraction" title="Link to this heading"></a></h4>
<p>After succesful state preparation, the logical qubit is idling and the physical qubits will accumulate errors. This will cuase the logical qubit to decohere if we don’t measure the stabilizers, effectively <strong>digitizing the noise</strong>, and tracking the changes in stabilizer measurements!</p>
<p>Below we first provide a function to measure all stabilizers of the code in a sequence.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">measure_all_syndromes</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Appends a circuit that measures all 6 stabilizers of the [[7,1,3]]-Steane code&quot;&quot;&quot;</span>
  
  <span class="c1"># indices for X-/Z-stabilizers</span>
  <span class="n">syndrome_qubits</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="c1"># 1st plaquette</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="c1"># 2nd plaquette</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># 3rd plaquette</span>
  <span class="p">]</span>
  <span class="c1"># indices for ancilla qubits</span>
  <span class="n">ancilla_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  <span class="c1"># measure X-stabilizers</span>
  <span class="k">for</span> <span class="n">ancilla</span><span class="p">,</span> <span class="n">data_qubits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ancilla_qubits</span><span class="p">,</span> <span class="n">syndrome_qubits</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_qubits</span><span class="p">:</span>
      <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">ancilla</span><span class="p">])</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="n">ancilla</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">ancilla</span><span class="p">)</span>
    
  <span class="c1"># measure Z-stabilizers</span>
  <span class="k">for</span> <span class="n">ancilla</span><span class="p">,</span> <span class="n">data_qubits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ancilla_qubits</span><span class="p">,</span> <span class="n">syndrome_qubits</span><span class="p">):</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="n">ancilla</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_qubits</span><span class="p">:</span>
      <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">ancilla</span><span class="p">,</span> <span class="n">data</span><span class="p">])</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="n">ancilla</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="n">ancilla</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">ancilla</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
<span class="n">c</span> <span class="o">+=</span> <span class="n">measure_all_syndromes</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeline-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This approach for syndrome extraction is problematic as it is clearly not fault-tolerant. For example, consider a <span class="math notranslate nohighlight">\(Z\)</span> error on one of the ancilla qubits. A single error can spread to 4 physical qubits during a single stabilizer measurement!</p>
<p><strong>Can we do better?</strong></p>
<p>A first approach could be to group the entangling gates, so that we measure the stabilizers in parallel. We can measure at most 3 stabilizers in parallel. This also reduces the time the physical qubits spent idling.</p>
<p>Furthermore, we need to consider the spreading of errors from the ancillas, so called <strong>hook errors</strong>. Since the Steane code is a distance <span class="math notranslate nohighlight">\(d=3\)</span> code, we can at most correct a single error and detect two errors.</p>
<p>A simple approach to detect hook errors is to add additional “flag” qubits, which measure parity checks on subsets of ancillas. In the following, we define circuits where the ancillas act themselves as flags for hook errors without the need for additional ancillas (Syndrome qubits reciprocally flag each other).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">measure_flagged_syndromes_xzz</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Extracts flagged syndrome measurements for stabilizers 1, 5, 6</span>
<span class="sd">  </span>
<span class="sd">  1: XXXXIII  (Z errors on first plaquette)</span>
<span class="sd">  5: IZZIZZI  (X errors on second plaquette)</span>
<span class="sd">  6: IIZZIZZ  (X errors on third plaquette)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
  <span class="c1"># correlate</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
  <span class="c1">#correlate</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

  <span class="c1"># measure ancillas and reset them</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xzz</span> <span class="o">=</span> <span class="n">measure_flagged_syndromes_xzz</span><span class="p">()</span>
<span class="n">xzz</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeline-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">measure_flagged_syndromes_zxx</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Extracts flagged syndrome measurements for stabilizers 2, 3, 4</span>
<span class="sd">  </span>
<span class="sd">  2: ZZZZIII  (X errors on first plaquette)</span>
<span class="sd">  3: IXXIXXI  (Z errors on second plaquette)</span>
<span class="sd">  4: IIXXIXX  (Z errors on third plaquette)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">()</span>
  
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
  <span class="c1"># correlate</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
  <span class="c1">#correlate</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

  <span class="c1"># measure ancillas and reset them</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">c</span> 
</pre></div>
</div>
</div>
</div>
<p>An example of hook errors with flags is shown in the picture below, taken from the Quantinuum paper:</p>
<p><img alt="Steane Hook Errors" src="_images/quantinuum-steane-hook-errors.png" /></p>
</section>
<section id="full-qec-cycle">
<h4>Full QEC cycle<a class="headerlink" href="#full-qec-cycle" title="Link to this heading"></a></h4>
<p>We are nearly ready to run our full QEC cycle. We can now come up with a protocol to reliably correct a single physical qubit error. Our flagged syndrome circuits can detect hook errors. To differentiate them from heigher weight Pauli errors, we combine flagged and unflagged syndrome extraction.</p>
<p>If the flagged syndrome circuits do not indicate an error, than we are done and the next QEC cycle starts. Otherwise, we know that an error occurred, but we need to measure the complete set of stabilizers to identify whether a hook error occurred.</p>
<p>This combination of conditional syndrome extraction is also known as <strong>adaptive syndrome extraction</strong> and can reduce average QEC cycle time significantly.</p>
<p>The adaptive QEC cycle is depicted in the picture below:</p>
<p><img alt="" src="_images/qec_cycle_with_flagged_syndromes.png" /></p>
<p>Unfortunately, Stim does not support conditional circuit execution, which means that we need to drive the <code class="docutils literal notranslate"><span class="pre">TableauSimulator</span></code> manually.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define a logger allowing us to print the progress of the execution of the QEC experiment</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="the-decoder">
<h4>The Decoder<a class="headerlink" href="#the-decoder" title="Link to this heading"></a></h4>
<p>The decoder is a simple two-stage <strong>Lookup Table Decoder (LUT)</strong>. This means that for each syndrome pattern there is a fixed rule on how to update the <strong>Pauli Frame</strong>, which indicates whether the logical qubit has been flipped or not.</p>
<p>The first stage is used to decode the unflagged syndromes and the second stage decodes the flagged syndromes.</p>
<p><span class="math notranslate nohighlight">\(X\)</span>/<span class="math notranslate nohighlight">\(Z\)</span>-type errors are handled separately, but since the stabilizers have the same structure we can use the same LUT decoder.</p>
<blockquote>
<div><p><strong>Note:</strong> We don’t provide the syndromes directly to the decoder but only whether the syndromes changed between QEC cycle rounds.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">unflagged_decoder</span><span class="p">(</span><span class="n">syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Given X-/Z-type stabilizer measurements. The syndromes are used to infer whether a logical error has occurred</span>
<span class="sd">  </span>
<span class="sd">  This is exactly the case, when there is a change in syndromes for the 2nd/3rd stabilizer</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">bad_syndrome_patterns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">bad_syndrome_patterns</span> <span class="o">==</span> <span class="n">syndromes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Unflagged decoder: Logical error detected!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">flagged_decoder</span><span class="p">(</span><span class="n">syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">flagged_syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Handle hook errors.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flagged_syndromes</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">syndromes</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flagged_syndromes</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">syndromes</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flagged_syndromes</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">syndromes</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">decoder</span><span class="p">(</span><span class="n">syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">flagged_syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
  
  <span class="n">pf</span> <span class="o">=</span> <span class="n">unflagged_decoder</span><span class="p">(</span><span class="n">syndromes</span><span class="p">)</span>
  <span class="n">pf_flag</span> <span class="o">=</span> <span class="n">flagged_decoder</span><span class="p">(</span><span class="n">syndromes</span><span class="p">,</span> <span class="n">flagged_syndromes</span><span class="p">)</span>
  
  <span class="k">return</span> <span class="n">pf</span><span class="p">,</span> <span class="n">pf_flag</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qec_cycle</span><span class="p">(</span><span class="n">simulator</span><span class="p">:</span> <span class="n">stim</span><span class="o">.</span><span class="n">TableauSimulator</span><span class="p">,</span> <span class="n">x_syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">z_syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pauli_frame</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="n">NoiseModel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Run a full QEC cycle for the [[7,1,3]]-Steane code by driving the Tableau simulator manually&quot;&quot;&quot;</span>
  
  <span class="c1"># track the delta of previous and current syndrome measurement</span>
  <span class="n">flag_diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># track delta of X-stabilizers</span>
  <span class="n">flag_diff_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># track delta of Z-stabilizers</span>
  
  <span class="c1"># first flagged syndrome extraction</span>
  <span class="n">simulator</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">measure_flagged_syndromes_xzz</span><span class="p">()))</span>
  <span class="c1"># measure first X-stabilizer, and second/third Z-stabilizer</span>
  <span class="n">fx0</span><span class="p">,</span> <span class="n">fz1</span><span class="p">,</span> <span class="n">fz2</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">current_measurement_record</span><span class="p">()[</span><span class="n">m_idx</span><span class="p">:</span><span class="n">m_idx</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
  <span class="c1"># update syndrome delta</span>
  <span class="n">flag_diff_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fx0</span> <span class="o">^</span> <span class="n">x_syndromes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">flag_diff_z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fz1</span> <span class="o">^</span> <span class="n">z_syndromes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">flag_diff_z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fz2</span> <span class="o">^</span> <span class="n">z_syndromes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
  <span class="c1"># shift measurement index</span>
  <span class="n">m_idx</span> <span class="o">+=</span> <span class="mi">3</span>
  <span class="c1"># print delta for debugging</span>
  <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Delta after 1st flagged measurement (XZZ): X </span><span class="si">{</span><span class="n">flag_diff_x</span><span class="si">}</span><span class="s2">, Z </span><span class="si">{</span><span class="n">flag_diff_z</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="c1"># if no syndrome changed continue with second round of flagged syndrome measurements</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag_diff_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag_diff_z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="c1"># second flagged syndrome extraction</span>
    <span class="n">simulator</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">measure_flagged_syndromes_zxx</span><span class="p">()))</span>
    <span class="c1"># measure first Z-stabilizer, and second/third X-stabilizer</span>
    <span class="n">fz0</span><span class="p">,</span> <span class="n">fx1</span><span class="p">,</span> <span class="n">fx2</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">current_measurement_record</span><span class="p">()[</span><span class="n">m_idx</span><span class="p">:</span><span class="n">m_idx</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
    <span class="c1"># update syndrome delta</span>
    <span class="n">flag_diff_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fz0</span> <span class="o">^</span> <span class="n">z_syndromes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">flag_diff_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fx1</span> <span class="o">^</span> <span class="n">x_syndromes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">flag_diff_x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fx2</span> <span class="o">^</span> <span class="n">x_syndromes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># shift measurement index</span>
    <span class="n">m_idx</span> <span class="o">+=</span> <span class="mi">3</span>
    <span class="c1"># print delta for debugging</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Delta after 2nd flagged measurement (ZXX): X </span><span class="si">{</span><span class="n">flag_diff_x</span><span class="si">}</span><span class="s2">, Z </span><span class="si">{</span><span class="n">flag_diff_z</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="c1"># re-measure all syndromes if flagged syndrome extraction indicates changes in syndromes</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flag_diff_z</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flag_diff_x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
    <span class="c1"># run full syndrome extraction</span>
    <span class="n">simulator</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">measure_all_syndromes</span><span class="p">()))</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">current_measurement_record</span><span class="p">()[</span><span class="n">m_idx</span><span class="p">:</span><span class="n">m_idx</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span>
    <span class="c1"># update syndromes</span>
    <span class="n">current_z_syndromes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># First 3 measurements Z-stabilizers </span>
    <span class="n">current_x_syndromes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">::],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Final 3 measurements X-stabilizers</span>
    <span class="c1"># compute delta</span>
    <span class="n">diff_x_syndromes</span> <span class="o">=</span> <span class="n">x_syndromes</span> <span class="o">^</span> <span class="n">current_x_syndromes</span>
    <span class="n">diff_z_syndromes</span> <span class="o">=</span> <span class="n">z_syndromes</span> <span class="o">^</span> <span class="n">current_z_syndromes</span>
    <span class="c1"># shift measurement index</span>
    <span class="n">m_idx</span> <span class="o">+=</span> <span class="mi">6</span>
    <span class="c1"># print new syndrome measurements</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Delta after unflagged measurement: X </span><span class="si">{</span><span class="n">diff_x_syndromes</span><span class="si">}</span><span class="s2">, Z </span><span class="si">{</span><span class="n">diff_z_syndromes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># call decoder to get updated pauli frame</span>
    <span class="n">pf_x</span><span class="p">,</span> <span class="n">pf_flag_x</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">(</span><span class="n">diff_x_syndromes</span><span class="p">,</span> <span class="n">flag_diff_x</span><span class="p">)</span>
    <span class="n">pf_z</span><span class="p">,</span> <span class="n">pf_flag_z</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">(</span><span class="n">diff_z_syndromes</span><span class="p">,</span> <span class="n">flag_diff_z</span><span class="p">)</span>
    
    <span class="c1"># update pauli frame</span>
    <span class="n">pauli_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pauli_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">pf_x</span> <span class="o">^</span> <span class="n">pf_flag_x</span>
    <span class="n">pauli_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pauli_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">pf_z</span> <span class="o">^</span> <span class="n">pf_flag_z</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pauli frame: Z: </span><span class="si">{</span><span class="n">pauli_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, X: </span><span class="si">{</span><span class="n">pauli_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># update syndromes</span>
    <span class="n">x_syndromes</span> <span class="o">=</span> <span class="n">current_x_syndromes</span>
    <span class="n">z_syndromes</span> <span class="o">=</span> <span class="n">current_z_syndromes</span>
  
  <span class="k">return</span> <span class="n">simulator</span><span class="p">,</span> <span class="n">x_syndromes</span><span class="p">,</span> <span class="n">z_syndromes</span><span class="p">,</span> <span class="n">pauli_frame</span><span class="p">,</span> <span class="n">m_idx</span>
</pre></div>
</div>
</div>
</div>
<p>For the final round of quantum error correction, we measure all physical qubits simultaneously in the <span class="math notranslate nohighlight">\(Z\)</span>-basis.</p>
<p>Given the measurement results, we compute the syndrome measurements as well as the logical observable by classically XORing the bits.</p>
<p>Depending on the chosen measurement basis, we need to modify the syndromes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">destructive_logical_measurement</span><span class="p">(</span><span class="n">simulator</span><span class="p">:</span> <span class="n">stim</span><span class="o">.</span><span class="n">TableauSimulator</span><span class="p">,</span> <span class="n">meas_basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">x_syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">z_syndromes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">pauli_frame</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="n">NoiseModel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Perform final destructive measurement where all physical qubits are measured.</span>
<span class="sd">  </span>
<span class="sd">  Returns a single bit, corresponding to the logical qubit measurement in the specified measurement basis.</span>
<span class="sd">  A final set of syndromes can be computed depending on the measurement basis.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  
  <span class="c1"># Measure all seven physical qubits of our logical qubit destructively</span>
  <span class="n">simulator</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">measure_logical_qubits</span><span class="p">()))</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">current_measurement_record</span><span class="p">()[</span><span class="n">m_idx</span><span class="p">:</span><span class="n">m_idx</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span>
  
  <span class="c1"># Compute the logical observable</span>
  <span class="n">log_obs</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
  
  <span class="c1"># Compute syndromes</span>
  <span class="n">s1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># First plaquette</span>
  <span class="n">s2</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="c1"># Second plaquette</span>
  <span class="n">s3</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">r</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># Third plaquette</span>
  <span class="n">syndromes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

  <span class="k">match</span> <span class="n">meas_basis</span><span class="p">:</span>
    <span class="k">case</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
      <span class="n">syndrome_diff</span> <span class="o">=</span> <span class="n">syndromes</span> <span class="o">^</span> <span class="n">x_syndromes</span>
    <span class="k">case</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
      <span class="n">syndrome_diff</span> <span class="o">=</span> <span class="n">syndromes</span> <span class="o">^</span> <span class="n">x_syndromes</span>
      <span class="n">syndrome_diff</span> <span class="o">=</span> <span class="n">syndromes</span> <span class="o">^</span> <span class="n">z_syndromes</span>
    <span class="k">case</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
      <span class="n">syndrome_diff</span> <span class="o">=</span> <span class="n">syndromes</span> <span class="o">^</span> <span class="n">z_syndromes</span>
    <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown measurement basis </span><span class="si">{</span><span class="n">meas_basis</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>

  <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Delta final round: </span><span class="si">{</span><span class="n">syndrome_diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  
  <span class="c1"># Get final corrections from the unflagged decoder</span>
  <span class="n">final_correction</span> <span class="o">=</span> <span class="n">unflagged_decoder</span><span class="p">(</span><span class="n">syndrome_diff</span><span class="p">)</span>
  
  <span class="c1"># Update the logical obs</span>
  <span class="n">log_obs</span> <span class="o">=</span> <span class="n">log_obs</span> <span class="o">^</span> <span class="n">final_correction</span>
  
  <span class="c1"># Finally, apply correction based on measurement basis</span>
  <span class="k">match</span> <span class="n">meas_basis</span><span class="p">:</span>
    <span class="k">case</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
      <span class="n">log_obs</span> <span class="o">=</span> <span class="n">log_obs</span> <span class="o">^</span> <span class="n">pauli_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">case</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span>
      <span class="n">log_obs</span> <span class="o">=</span> <span class="n">log_obs</span> <span class="o">^</span> <span class="n">pauli_frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">pauli_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;log : </span><span class="si">%s</span><span class="s2">, pf: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">log_obs</span><span class="p">,</span> <span class="n">pauli_frame</span><span class="p">)</span>
    <span class="k">case</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
      <span class="n">log_obs</span> <span class="o">=</span> <span class="n">log_obs</span> <span class="o">^</span> <span class="n">pauli_frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      
  <span class="k">return</span> <span class="n">log_obs</span>
   
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">expected_result</span><span class="p">(</span><span class="n">measure_output</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">stabilizer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">meas_basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Evaluate if measurement corresponds to the expected measurement result for a given stabilizer and measurement basis.&quot;&quot;&quot;</span>

  <span class="n">pauli_measurement</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">PauliString</span><span class="p">(</span><span class="n">meas_basis</span><span class="p">)</span>
  <span class="n">pauli_stabilizer</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">PauliString</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">)</span> 
  <span class="n">commute</span> <span class="o">=</span> <span class="n">pauli_stabilizer</span><span class="o">.</span><span class="n">commutes</span><span class="p">(</span><span class="n">pauli_measurement</span><span class="p">)</span>
  
  <span class="k">if</span> <span class="ow">not</span> <span class="n">commute</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Anti-commuting stabilzers, measurement is random&quot;</span><span class="p">)</span>
  
  <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">pauli_measurement</span> <span class="o">*</span> <span class="n">pauli_stabilizer</span><span class="p">)</span><span class="o">.</span><span class="n">sign</span>
  
  <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">measure_output</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">measure_output</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can put everything together and run the whole QEC cycle!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">steane_code_exp</span><span class="p">(</span><span class="n">initial_state</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;+Z&quot;</span><span class="p">,</span> <span class="n">meas_basis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">num_cycles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shots</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">NoiseModel</span><span class="p">()):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Runs an error correction experiment for the Steane [[7,1,3]]-code.</span>
<span class="sd">  </span>
<span class="sd">  The quantum state is represented by the state of the stim TableauSimulator.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
  
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shots</span><span class="p">):</span>
    <span class="n">simulator</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">TableauSimulator</span><span class="p">()</span>
    
    <span class="n">m_idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># shift measurement index</span>
    
    <span class="c1"># state preparation (3 attempts)</span>
    <span class="c1"># prepare the logical |0&gt;_L state and verify with ancilla</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
      <span class="n">simulator</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">encoding_circuit</span><span class="p">()))</span>
      <span class="n">state_prep_ancilla</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">current_measurement_record</span><span class="p">()[</span><span class="n">m_idx</span><span class="p">]</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;State preparation ancilla: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">state_prep_ancilla</span><span class="p">))</span>
      <span class="n">m_idx</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">state_prep_ancilla</span><span class="p">:</span>
        <span class="k">break</span>
      
    <span class="c1"># apply single qubit gate to prepare correct state</span>
    <span class="n">simulator</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">prepare_stab_eigenstate</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)))</span>
    
    <span class="c1"># run QEC cycles</span>
    <span class="n">x_syndromes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">z_syndromes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># Pauli frame tracks which logical correction to apply</span>
    <span class="c1"># Pauli Frame = [Apply X_L?, Apply Z_L?] </span>
    <span class="n">pauli_frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cycles</span><span class="p">):</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- QEC cycle </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="n">simulator</span><span class="p">,</span> <span class="n">x_syndromes</span><span class="p">,</span> <span class="n">z_syndromes</span><span class="p">,</span> <span class="n">pauli_frame</span><span class="p">,</span> <span class="n">m_idx</span> <span class="o">=</span> <span class="n">qec_cycle</span><span class="p">(</span><span class="n">simulator</span><span class="p">,</span> <span class="n">x_syndromes</span><span class="p">,</span> <span class="n">z_syndromes</span><span class="p">,</span> <span class="n">pauli_frame</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span>

    <span class="c1"># Rotate to correct logical measurement basis</span>
    <span class="n">simulator</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">rotate_to_measurement_basis</span><span class="p">(</span><span class="n">meas_basis</span><span class="o">=</span><span class="n">meas_basis</span><span class="p">)))</span>
    
    <span class="c1"># Perform final destructive logical measurement</span>
    <span class="n">final_measurement</span> <span class="o">=</span> <span class="n">destructive_logical_measurement</span><span class="p">(</span><span class="n">simulator</span><span class="p">,</span> <span class="n">meas_basis</span><span class="p">,</span> <span class="n">x_syndromes</span><span class="p">,</span> <span class="n">z_syndromes</span><span class="p">,</span> <span class="n">pauli_frame</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span>
    
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final measurement: </span><span class="si">{</span><span class="n">final_measurement</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">success</span> <span class="o">=</span> <span class="n">expected_result</span><span class="p">(</span><span class="n">final_measurement</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">meas_basis</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Success: </span><span class="si">{</span><span class="n">success</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
    
  <span class="k">return</span> <span class="n">results</span>
  
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Uncomment to follow QEC cycle execution</span>
<span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

<span class="n">noise</span> <span class="o">=</span> <span class="n">NoiseModel</span><span class="p">()</span>
<span class="n">noise</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">steane_code_exp</span><span class="p">(</span><span class="n">num_cycles</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;+Y&quot;</span><span class="p">,</span> <span class="n">meas_basis</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="n">noise</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="simulating-logical-error-rates-for-steane-code-for-each-basis">
<h4>Simulating Logical Error Rates for Steane Code for each Basis<a class="headerlink" href="#simulating-logical-error-rates-for-steane-code-for-each-basis" title="Link to this heading"></a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shots</span> <span class="o">=</span> <span class="mi">2048</span>
<span class="n">cycles_sweep</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">basis_sweep</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">]</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">NoiseModel</span><span class="p">()</span>
<span class="n">noise</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">basis</span> <span class="ow">in</span> <span class="n">basis_sweep</span><span class="p">:</span>
  <span class="n">cycle_results</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">cycles</span> <span class="ow">in</span> <span class="n">cycles_sweep</span><span class="p">:</span>
    <span class="n">exp_results</span> <span class="o">=</span> <span class="n">steane_code_exp</span><span class="p">(</span><span class="n">num_cycles</span><span class="o">=</span><span class="n">cycles</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;+</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">meas_basis</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="n">noise</span><span class="p">)</span>
    <span class="n">cycle_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp_results</span><span class="p">)</span><span class="o">/</span><span class="n">shots</span><span class="p">)</span>
  <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle_results</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Steane Code Logical Error Rate vs. QEC cycles&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;QEC Cycles&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Logical Error Rate&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">basis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">basis_sweep</span><span class="p">):</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">cycles_sweep</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Basis&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<span id="document-notebooks/surface_code_threshold"></span><section class="tex2jax_ignore mathjax_ignore" id="tutorial-estimating-the-surface-code-threshold">
<h2>Tutorial - Estimating the Surface Code Threshold<a class="headerlink" href="#tutorial-estimating-the-surface-code-threshold" title="Link to this heading"></a></h2>
<p>In this notebook, we will estimate the threshold of the Surface Code, for a simple phenomenological circuit-noise model.</p>
<section id="python-dependencies">
<h3>Python Dependencies<a class="headerlink" href="#python-dependencies" title="Link to this heading"></a></h3>
<p>To run the Jupyter Notebook locally, you’ll need the following dependencies:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>stim~<span class="o">=</span><span class="m">1</span>.14
numpy~<span class="o">=</span><span class="m">1</span>.0<span class="w">  </span><span class="c1"># require for PyMatching</span>
scipy
pymatching
matplotlib
</pre></div>
</div>
<p>If not already installed in your environmnet you can install them with</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>stim~<span class="o">=</span><span class="m">1</span>.14<span class="w"> </span>numpy~<span class="o">=</span><span class="m">1</span>.0<span class="w"> </span>scipy<span class="w"> </span>pymatching<span class="w"> </span>matplotlib
</pre></div>
</div>
</section>
<section id="the-surface-code">
<h3>The Surface Code<a class="headerlink" href="#the-surface-code" title="Link to this heading"></a></h3>
<p>As discussed in the lecture, the Surface Code is a stabilizer code with code distance <span class="math notranslate nohighlight">\(d\)</span>, <span class="math notranslate nohighlight">\(d^2\)</span> data qubits, and <span class="math notranslate nohighlight">\(d^2-1\)</span> syndrome measurement qubits, embedded in a 2D-plane.</p>
<p>The stabilizers of the code have weight 4 (interior) or 2 (boundary) depending on their location on the surface. In the picture below, a distance <span class="math notranslate nohighlight">\(d=5\)</span> Surface Code is shown. The red squares depict the <span class="math notranslate nohighlight">\(X\)</span>-type stabilizers, and the blue squares depict the <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizers.</p>
<p><img alt="Surface Code" src="_images/surface-code.svg" /></p>
<p><strong>Source:</strong> https://errorcorrectionzoo.org/c/rotated_surface</p>
<p>To measure the syndromes, the code requires only local operation between neighboring qubits since each syndrome qubit measures only its neighboring data qubits.</p>
</section>
<section id="surface-code-circuit-in-stim">
<h3>Surface Code Circuit in Stim<a class="headerlink" href="#surface-code-circuit-in-stim" title="Link to this heading"></a></h3>
<p>We will use the stabilizer simulator <a class="reference external" href="https://github.com/quantumlib/Stim"><code class="docutils literal notranslate"><span class="pre">Stim</span></code></a> to simulate the circuit code execution and the circuit noise.</p>
<p>Stim allows us to load a set of pre-defined quantum circuits for well-known quantum error correction codes such as the Surface Code.</p>
<p>We’ll start by generating a distance <span class="math notranslate nohighlight">\(d=3\)</span> Surface Code quantum circuits with 3 rounds of syndrome measurements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">stim</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
  <span class="s2">&quot;surface_code:rotated_memory_x&quot;</span><span class="p">,</span> 
  <span class="n">rounds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
  <span class="n">distance</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeline-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>For <span class="math notranslate nohighlight">\(d=3\)</span>, we expect the circuit to have 9 data qubits and 8 ancilla qubits to measure the stabilizers, so a total of 15 qubits. The cirucit generated above contains a few idle wires (corresponding to unused qubits).</p>
<p>A better way to see which qubits are actually utilized is to print a <strong>timeslice diagram</strong> of the circuit. A timeslice diagram depicts the parts of the circuit executed between two <code class="docutils literal notranslate"><span class="pre">TICK</span></code> operations.</p>
<p><code class="docutils literal notranslate"><span class="pre">stim</span></code> automatically injects <code class="docutils literal notranslate"><span class="pre">TICK</span></code> operations so that we can easily follow the code circuit execution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeslice-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can see that in each round of syndrome measurement, 4 blocks of parallel CNOT gates are applied. In each block, 6 CNOTs are executed - 4 for the stabilizers in the interior of the surface and 2 for the stabilizers at the boundary measuring 2 data qubits.</p>
<p><strong>Note:</strong> The CNOT gates are executed in a specific order to avoid <strong>hook errors</strong>, which would spread low-weight Pauli errors, to higher weight Pauli errors, making fault-tolerant operations impossible!</p>
<p>After each round, the ancillas are measured, extracting the stabilizer Eigenvalues, followed by a reset operation to re-use them for the next round of error detection.</p>
<section id="circuit-metadata">
<h4>Circuit Metadata<a class="headerlink" href="#circuit-metadata" title="Link to this heading"></a></h4>
<p>In the circuit above, we can see two other annotations, besides the <code class="docutils literal notranslate"><span class="pre">TICK</span></code> operation, which do not correspond to quantum gates operating on the qubits.</p>
<p>The first 16 instructions of the circuit use the <code class="docutils literal notranslate"><span class="pre">QUBIT_COORDS(x,</span> <span class="pre">y)</span> <span class="pre">qubit_index</span></code> annotation to provide Stim information about the qubit’s location in space. This information is utilized by various tools to visualize the circuit execution such as the <code class="docutils literal notranslate"><span class="pre">timeslice</span></code> visualizer.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The second annotiation is the <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> annotation which is discussed in the next section.</p>
</section>
<section id="detectors">
<h4>Detectors<a class="headerlink" href="#detectors" title="Link to this heading"></a></h4>
<p>We can see that Stim appended to the end of each QEC cycle a bunch of <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> statements.</p>
<p>A detector is a parity check, based on a set of measurements in the <strong>measurement record</strong> denoted as <code class="docutils literal notranslate"><span class="pre">rec</span></code>. Under noiseless execution, the <strong>parity of the detector should never change</strong>.</p>
<p>The latest measurement in the measurement recored is accessible through <code class="docutils literal notranslate"><span class="pre">rec[-1]</span></code>.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> can be assigned a location in space-time via a triplet of coordinates (<span class="math notranslate nohighlight">\(x,y,z\)</span>), which can later be used to display a space-time graph.</p>
<p>If we print the instructions for the first QEC cycle, we see that 4 detectors have been added. Those are used for the <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizer parity checks, detecting Pauli-<span class="math notranslate nohighlight">\(X\)</span> errors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instructions for the first QEC cycle</span>
<span class="n">circuit</span><span class="p">[</span><span class="mi">17</span><span class="p">:</span><span class="mi">37</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>What about the <span class="math notranslate nohighlight">\(X\)</span>-type stabilizers?</p>
<p>Since at the beginning of the circuit we prepared our qubits in the <span class="math notranslate nohighlight">\(\ket{1}\)</span> state, they are already Eigenvectors of all <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizers resulting in a deterministic measurement (<span class="math notranslate nohighlight">\(Z\)</span>-type stabilizers have an even amount of Pauli-<span class="math notranslate nohighlight">\(Z\)</span> operators cancelling out the phase-flip of <span class="math notranslate nohighlight">\(-1\)</span> for single physical qubits).</p>
<p><strong>Example:</strong> <span class="math notranslate nohighlight">\(ZZZZ\ket{1}\ket{1}\ket{1}\ket{1} = (-1)^4 \ket{1}\ket{1}\ket{1}\ket{1} = \ket{1}\ket{1}\ket{1}\ket{1}\)</span></p>
<p>For the <span class="math notranslate nohighlight">\(X\)</span>-type stabilizers, we require an initial measurement round projecting them randomly onto one of the 2 Eigenspaces <span class="math notranslate nohighlight">\(+1\)</span>/<span class="math notranslate nohighlight">\(-1\)</span>. Subsequent measurements, in the absence of noise, should always yield the same Eigenvalues when measuring the stabilizers.</p>
<p>Therefore, we can add additional <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> statements for the <span class="math notranslate nohighlight">\(X\)</span>-type stabilizers after the second round of measurements as shown below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">[</span><span class="mi">37</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>In the second round, we bitwise XOR the measurement results of the first round, with the measurements of the second round.
This way, <code class="docutils literal notranslate"><span class="pre">DETECTOR</span></code> events inform the decoder about changes in the syndromes in the presence of noise.</p>
<p><strong>Note:</strong> The <code class="docutils literal notranslate"><span class="pre">SHIFT_COORDS</span></code> instruction can be used to shift the <span class="math notranslate nohighlight">\(z\)</span>-index (time) by 1, which allows us to to reuse the same detector coordinates in every QEC cycle.</p>
</section>
<section id="final-measurement-round">
<h4>Final Measurement Round<a class="headerlink" href="#final-measurement-round" title="Link to this heading"></a></h4>
<p>At the end of the circuit, all physical data qubits are measured destructively in the <span class="math notranslate nohighlight">\(X\)</span>-basis, and detectors computing <span class="math notranslate nohighlight">\(Z\)</span>-type stabilizer parities are defined.</p>
<p>Finally, we define the logical observable measurement as the parity of physical qubits <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(8\)</span>, and <span class="math notranslate nohighlight">\(15\)</span>, corresponding to a logical <span class="math notranslate nohighlight">\(X_L\)</span> measurement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="p">[</span><span class="mi">60</span><span class="p">::]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="detectors-in-the-absence-of-noise">
<h4>Detectors in the Absence of Noise<a class="headerlink" href="#detectors-in-the-absence-of-noise" title="Link to this heading"></a></h4>
<p>Without any noise in the circuit, our detectors and the logical observable should always measure the same parities.</p>
<p>We can put this to the test by, compiling a <code class="docutils literal notranslate"><span class="pre">sampler</span></code> which will simulate the circuit and collect detector events.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define a detector sampler</span>
<span class="n">sampler</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">compile_detector_sampler</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Sample detection events and logical observable</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">detection_events</span><span class="p">,</span> <span class="n">observable_flips</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">shots</span><span class="p">,</span> <span class="n">separate_observables</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Below we can see that the detection events never change parity</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">detection_events</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The same applies to the observable</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">observable_flips</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="noisy-surface-code-circuits">
<h4>Noisy Surface Code Circuits<a class="headerlink" href="#noisy-surface-code-circuits" title="Link to this heading"></a></h4>
<p>Now, that we understand how the Surface Code circuit looks like and how detectors behave, we can explore what happens when noise is added to the mix.</p>
<p>Stim doesn’t support a noise model, like the ones Qiskit or Cirq support, but we can easily generate the same Surface Code circuit with noisy gates injected.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noisy_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
  <span class="s2">&quot;surface_code:rotated_memory_x&quot;</span><span class="p">,</span> 
  <span class="n">rounds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
  <span class="n">distance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
  <span class="n">after_clifford_depolarization</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
  <span class="n">after_reset_flip_probability</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
  <span class="n">before_measure_flip_probability</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
  <span class="n">before_round_data_depolarization</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The cirucit contains now noise operations, simulating qubit reset, measurement and gate errors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noisy_circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeline-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With the noise, we observe for the first time logical errors after measuring the logical observable</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">shots</span> <span class="o">=</span> <span class="mi">10_000</span>

<span class="n">sampler</span> <span class="o">=</span> <span class="n">noisy_circuit</span><span class="o">.</span><span class="n">compile_detector_sampler</span><span class="p">()</span>
<span class="n">detection_events</span><span class="p">,</span> <span class="n">observable_flips</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">shots</span><span class="p">,</span> <span class="n">separate_observables</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Success rate after 1 QEC cycle: </span><span class="si">{</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">observable_flips</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">shots</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2"> %&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We also observe detection events in the measured data, indicating the presence of errors:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">detection_events</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="the-detector-error-model-dem">
<h3>The Detector Error Model (DEM)<a class="headerlink" href="#the-detector-error-model-dem" title="Link to this heading"></a></h3>
<p>Our goal is to decode the Surface Code. In this section, we introduce a useful abstraction, called the <strong>detector error model (DEM)</strong> which we will use for decoding.</p>
<p>Given a set of measurement parities, defined through detectors and logical observables in the circuit, the detector error model informs the decoder with which probability any of the checks fails due to an error.</p>
<p>For our noisy Surface Code circuit, we can compile a detector model and print the DEM model representation</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dem</span> <span class="o">=</span> <span class="n">noisy_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dem</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The first instruction</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">error</span><span class="p">(</span><span class="mf">0.00193118</span><span class="p">)</span> <span class="n">D0</span> <span class="n">D2</span>
</pre></div>
</div>
<p>tells us, that there is some error mechanism in our circuit, that occurs with probability <span class="math notranslate nohighlight">\(0.00193118\)</span> and that will flip the parities of both detectors <code class="docutils literal notranslate"><span class="pre">D0</span></code> and <code class="docutils literal notranslate"><span class="pre">D2</span></code>, defined as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">detector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="n">D0</span>
<span class="n">detector</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="n">D2</span>
</pre></div>
</div>
<p>in our Surface Code circuit. As a reminder: Detectors are directly associated with stabilizer measurements. This means, that the error probability tells us with which probability a stabilizer measurement will fail given the circuit-level noise model.</p>
<section id="example-dem-for-repetition-code">
<h4>Example: DEM for Repetition Code<a class="headerlink" href="#example-dem-for-repetition-code" title="Link to this heading"></a></h4>
<p>Since our noisy Surface Code has many source of errors, retracing the source of error probabilities in the DEM is not a simple task.</p>
<p>Instead, let’s continue our analysis for the <span class="math notranslate nohighlight">\(X\)</span>-flip repetition code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetition_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    X_ERROR(0.1) 0 1 2</span>
<span class="s2">    CNOT 0 3 1 3 1 4 2 4 </span>
<span class="s2">    MR 3 4</span>
<span class="s2">    DETECTOR(0,0,0) rec[-1]</span>
<span class="s2">    DETECTOR(0,0,0) rec[-2]</span>
<span class="s2">  &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetition_circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeline-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The corresponding DEM has the following form</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dem</span> <span class="o">=</span> <span class="n">repetition_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dem</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Unsurprisingly, there are three possible errors affecting our detectors. Since both detectors measure the second qubit they will be flipped with probability <span class="math notranslate nohighlight">\(0.1\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">error</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="n">D0</span> <span class="n">D1</span>
</pre></div>
</div>
<p>Adding Pauli-<span class="math notranslate nohighlight">\(Z\)</span> errors to our circuit does not affect the DEM as the repetition code cannot detect them:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetition_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    X_ERROR(0.1) 0 1 2</span>
<span class="s2">    Z_ERROR(0.1) 0 1 2</span>
<span class="s2">    CNOT 0 3 1 3 1 4 2 4 </span>
<span class="s2">    MR 3 4</span>
<span class="s2">    DETECTOR(0,0,0) rec[-1]</span>
<span class="s2">    DETECTOR(0,0,0) rec[-2]</span>
<span class="s2">  &quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">dem</span> <span class="o">=</span> <span class="n">repetition_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dem</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Replacing the Pauli-<span class="math notranslate nohighlight">\(X\)</span> and Pauli-<span class="math notranslate nohighlight">\(Z\)</span> errors by depolarizing noise, results in the following DEM:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetition_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    DEPOLARIZE1(0.1) 0 1 2</span>
<span class="s2">    CNOT 0 3 1 3 1 4 2 4 </span>
<span class="s2">    MR 3 4</span>
<span class="s2">    DETECTOR(0,0,0) rec[-1]</span>
<span class="s2">    DETECTOR(0,0,0) rec[-2]</span>
<span class="s2">  &quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">dem</span> <span class="o">=</span> <span class="n">repetition_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">dem</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>For depolarizing noise with probability <span class="math notranslate nohighlight">\(p\)</span>, Stim applies a given Pauli gate with  probability:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(I\)</span>: <span class="math notranslate nohighlight">\((1-p)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span>: <span class="math notranslate nohighlight">\(\frac{p}{3}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(Y\)</span>: <span class="math notranslate nohighlight">\(\frac{p}{3}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(Z\)</span>: <span class="math notranslate nohighlight">\(\frac{p}{3}\)</span></p></li>
</ul>
<p>Therefore, we have a probability of <span class="math notranslate nohighlight">\(\frac{2p}{3}\)</span> that our detectors are flipped as we only need to take into account Pauli-<span class="math notranslate nohighlight">\(X\)</span> and Pauli-<span class="math notranslate nohighlight">\(Y\)</span> errors.</p>
</section>
<section id="dem-model-and-the-tanner-graph">
<h4>DEM model and the Tanner Graph<a class="headerlink" href="#dem-model-and-the-tanner-graph" title="Link to this heading"></a></h4>
<p>The detector errror model represents a weighted graph, where the nodes are parity checks and the weights represent independent error probabilities affecting the checks.</p>
<p>This representation is very natural for decoders operating on a Tanner graph such as the <strong>Minimum-Weight Perfect Matching</strong> decoder introduced in the lecture.</p>
<p>To further emphasize the relationship, we can visualize the DEM of a larger repetition code using Stim:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
    <span class="s2">&quot;repetition_code:memory&quot;</span><span class="p">,</span>
    <span class="n">rounds</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">distance</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
    <span class="n">before_round_data_depolarization</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span>
    <span class="n">before_measure_flip_probability</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;timeline-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dem</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="n">dem</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;matchgraph-svg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The matching graph is a 2D space-time graph. The <span class="math notranslate nohighlight">\(x\)</span>-axis represents space and the <span class="math notranslate nohighlight">\(y\)</span>-axis time.</p>
<p>At each time step, we count 8 vertices, representing the 8 detectors. Furthermore, we have two invisible boundary nodes, for matching errors on the outer qubits, which are only measured by a single detector.</p>
<p>For analyzing the Surface Code DEM, it is usually simpler to print the graph in 3D</p>
<p><strong>Exercise 1:</strong> Test different error mechanisms and see how they affect the connectivity in the DEM graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noisy_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
  <span class="s2">&quot;surface_code:rotated_memory_x&quot;</span><span class="p">,</span> 
  <span class="n">rounds</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> 
  <span class="n">distance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
  <span class="c1"># before_round_data_depolarization=0.001,</span>
  <span class="n">after_reset_flip_probability</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
  <span class="n">before_measure_flip_probability</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>

<span class="n">dem</span> <span class="o">=</span> <span class="n">noisy_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">()</span>
<span class="n">dem</span><span class="o">.</span><span class="n">diagram</span><span class="p">(</span><span class="s1">&#39;matchgraph-3d&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="dem-model-for-decoder-research-and-reproducibility">
<h4>DEM model for Decoder Research and Reproducibility<a class="headerlink" href="#dem-model-for-decoder-research-and-reproducibility" title="Link to this heading"></a></h4>
<p>Besides being a powerful abstraction, a DEM model is also very useful for sharing noise models.</p>
<p>DEM model errors can be measured on a real device and loaded into Stim, making Stim a powerful tool for evaluating decoders even without access to actual hardware.</p>
<p>DEM models for Google’s recent paper: <a class="reference external" href="https://arxiv.org/html/2408.13687v1#S11"><em>Quantum Error Correction Below the Surface Code Threshold</em></a> can be found on <a class="reference external" href="https://zenodo.org/records/13273331">Zenodo</a></p>
</section>
</section>
<section id="decoding-errors-minimum-weight-perfect-matching">
<h3>Decoding Errors: Minimum-Weight Perfect Matching<a class="headerlink" href="#decoding-errors-minimum-weight-perfect-matching" title="Link to this heading"></a></h3>
<p>Given a DEM model, it is straightforward to feed the graph and detector events to a minimum-weight perfect matching decoder.</p>
<p>In this tutorial, we are going to use a MWPM implementation called <a class="reference external" href="https://arxiv.org/abs/2105.13082"><code class="docutils literal notranslate"><span class="pre">PyMatching</span></code></a>, developed by Oscar Higgots.</p>
<p>We’ll begin by instantiating a noisy repetition circuit in Stim:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instantiate noisy repetition code</span>
<span class="n">noisy_repetition_circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
    <span class="s2">&quot;repetition_code:memory&quot;</span><span class="p">,</span>
    <span class="n">rounds</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">distance</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
    <span class="n">before_round_data_depolarization</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span>
    <span class="n">before_measure_flip_probability</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># Instantiate a sampler to sample detector events </span>
<span class="n">sampler</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">compile_detector_sampler</span><span class="p">()</span>

<span class="c1"># Sample detection events and observable flips</span>
<span class="n">num_shots</span> <span class="o">=</span> <span class="mi">10_000</span>
<span class="n">detection_events</span><span class="p">,</span> <span class="n">observable_flips</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">num_shots</span><span class="p">,</span> <span class="n">separate_observables</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Success rate after 25 QEC cycles: </span><span class="si">{</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">observable_flips</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_shots</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2"> %&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we import <code class="docutils literal notranslate"><span class="pre">PyMatching</span></code> and use its bindings to construct a graph from our DEM and return predictions given detection events.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pymatching</span>

<span class="c1"># generate DEM for noisy circuit</span>
<span class="n">detector_error_model</span> <span class="o">=</span> <span class="n">noisy_repetition_circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">(</span><span class="n">decompose_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Istantiate MWPM decoder</span>
<span class="n">matcher</span> <span class="o">=</span> <span class="n">pymatching</span><span class="o">.</span><span class="n">Matching</span><span class="o">.</span><span class="n">from_detector_error_model</span><span class="p">(</span><span class="n">detector_error_model</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can print some metadata about the decoder</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of detectors:&quot;</span><span class="p">,</span> <span class="n">matcher</span><span class="o">.</span><span class="n">num_detectors</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of nodes:&quot;</span><span class="p">,</span> <span class="n">matcher</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of edges: &quot;</span><span class="p">,</span> <span class="n">matcher</span><span class="o">.</span><span class="n">num_edges</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we are ready to decode our sampled data!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">predictions</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">decode_batch</span><span class="p">(</span><span class="n">detection_events</span><span class="p">)</span>
<span class="c1"># print(predictions)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we need to count the decoding mistakes</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Count the mistakes.</span>
<span class="n">num_errors</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">shot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shots</span><span class="p">):</span>
    <span class="n">actual_for_shot</span> <span class="o">=</span> <span class="n">observable_flips</span><span class="p">[</span><span class="n">shot</span><span class="p">]</span>
    <span class="n">predicted_for_shot</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[</span><span class="n">shot</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">actual_for_shot</span><span class="p">,</span> <span class="n">predicted_for_shot</span><span class="p">):</span>
        <span class="n">num_errors</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of errors for </span><span class="si">{</span><span class="n">num_shots</span><span class="si">}</span><span class="s2"> shots: </span><span class="si">{</span><span class="n">num_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="estimating-the-repetition-code-threshold">
<h3>Estimating the Repetition Code Threshold<a class="headerlink" href="#estimating-the-repetition-code-threshold" title="Link to this heading"></a></h3>
<p>In order to calculate the threshold of a code for a fixed noise model and decoder, we need to evaluate the decoder at different code distances <span class="math notranslate nohighlight">\(d\)</span> and noise-levels <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>We start by writing a function that automates the steps we performed above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_logical_errors</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="p">,</span> <span class="n">num_shots</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Sample the circuit.</span>
    <span class="n">sampler</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">compile_detector_sampler</span><span class="p">()</span>
    <span class="n">detection_events</span><span class="p">,</span> <span class="n">observable_flips</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">num_shots</span><span class="p">,</span> <span class="n">separate_observables</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Configure a decoder using the circuit.</span>
    <span class="n">detector_error_model</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">detector_error_model</span><span class="p">(</span><span class="n">decompose_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">matcher</span> <span class="o">=</span> <span class="n">pymatching</span><span class="o">.</span><span class="n">Matching</span><span class="o">.</span><span class="n">from_detector_error_model</span><span class="p">(</span><span class="n">detector_error_model</span><span class="p">)</span>

    <span class="c1"># Run the decoder.</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">decode_batch</span><span class="p">(</span><span class="n">detection_events</span><span class="p">)</span>

    <span class="c1"># Count the mistakes.</span>
    <span class="n">num_errors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">shot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_shots</span><span class="p">):</span>
        <span class="n">actual_for_shot</span> <span class="o">=</span> <span class="n">observable_flips</span><span class="p">[</span><span class="n">shot</span><span class="p">]</span>
        <span class="n">predicted_for_shot</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[</span><span class="n">shot</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">actual_for_shot</span><span class="p">,</span> <span class="n">predicted_for_shot</span><span class="p">):</span>
            <span class="n">num_errors</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">num_errors</span>
</pre></div>
</div>
</div>
</div>
<p>The function returns the number of logical errors for <code class="docutils literal notranslate"><span class="pre">num_shots</span></code>. From that, we can compute the <strong>logical error rate (LER)</strong> per shot needed for our threshold evaluation.</p>
<p>Next, let’s run our threshold estimation for our repetition code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">num_shots</span> <span class="o">=</span> <span class="mi">10_000</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- Code distance:&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">noise</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]:</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">stim</span><span class="o">.</span><span class="n">Circuit</span><span class="o">.</span><span class="n">generated</span><span class="p">(</span>
            <span class="s2">&quot;repetition_code:memory&quot;</span><span class="p">,</span>
            <span class="n">rounds</span><span class="o">=</span><span class="n">d</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
            <span class="n">distance</span><span class="o">=</span><span class="n">d</span><span class="p">,</span>
            <span class="n">before_round_data_depolarization</span><span class="o">=</span><span class="n">noise</span><span class="p">)</span>
        <span class="n">num_errors_sampled</span> <span class="o">=</span> <span class="n">count_logical_errors</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">num_shots</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decoding errors at noise level </span><span class="si">{</span><span class="n">noise</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">num_errors_sampled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
        <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_errors_sampled</span> <span class="o">/</span> <span class="n">num_shots</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;d=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;physical error rate&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;logical error rate per shot&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The results look very promising. Based on our simulation, the threshold for the repetition code is around <span class="math notranslate nohighlight">\(p=0.4\)</span>!</p>
<p>For physical noise levels <span class="math notranslate nohighlight">\(\le p\)</span> we observe a significant decrease of the LER, consistent with the threshold theorem.</p>
<p>Unfortunately, the repetition code is not as good as the graph might indicate!</p>
<p>There are several problems with our result:</p>
<ul class="simple">
<li><p>The repetition code doesn’t consider <span class="math notranslate nohighlight">\(Z\)</span>-type errors</p></li>
<li><p>We didn’t introduce any reset or measurement errors</p></li>
<li><p>Our noise model is missing important error processes such as for example <em>leakage</em>, where the qubit escapes its computational subspace and leaks to higher energy states such as <span class="math notranslate nohighlight">\(\ket{2}, \ket{3}, ...\)</span>.</p></li>
</ul>
<p>Nevertheless, we were able to estimate the code threshold with a few lines of code, demonstrating the usefulness of Stim :-)</p>
<p>Next, we are going to evaluate the Surface Code under a slightly more realistic noise model to get an idea of the threshold value of a <em>real</em> quantum code.</p>
</section>
<section id="exercise-estimating-the-threshold-of-the-surface-code">
<h3>Exercise: Estimating the Threshold of the Surface Code<a class="headerlink" href="#exercise-estimating-the-threshold-of-the-surface-code" title="Link to this heading"></a></h3>
<p><strong>Exercise 2:</strong> Re-use the code for the repetition code to evaluate the Surface Code threshold. This time introduce reset and measurement errors as well depolarizing errors before the QEC cycles.</p>
<p><strong>Tip 1:</strong> The threshold for the Surface Code is significantly lower than the one for the repetition code. Use a noise range between <span class="math notranslate nohighlight">\([0.002, 0.009]\)</span> to find the threshold.</p>
<p><strong>Tip 2:</strong> Observe the number of shots needed to sample a logical error and adjust the number of shots accordingly</p>
<p><strong>Exercise 3:</strong> The error suppression factor <span class="math notranslate nohighlight">\(\Lambda = \frac{\varepsilon_d}{\varepsilon_{d+2}}\)</span> is an important metric to see if our code effectively suppresses the error.</p>
<p>The LER is denoted as <span class="math notranslate nohighlight">\(\varepsilon_d\)</span>, at a fixed code distance <span class="math notranslate nohighlight">\(d\)</span> and physical error rate <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>Calculate <span class="math notranslate nohighlight">\(\Lambda\)</span> at <span class="math notranslate nohighlight">\(p=2 \times 10^{-3}\)</span> and compare it to the theoretical estimate <span class="math notranslate nohighlight">\(p_{thr}/p\)</span>.</p>
<p><strong>Tip:</strong> You can use the <code class="docutils literal notranslate"><span class="pre">results</span></code> list object for your calculations.</p>
<section id="references">
<h4>References<a class="headerlink" href="#references" title="Link to this heading"></a></h4>
<p>To learn more about Stim:</p>
<ul class="simple">
<li><p>Read the <a class="reference external" href="https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"><code class="docutils literal notranslate"><span class="pre">Getting</span> <span class="pre">Started</span> <span class="pre">Tutorial</span></code></a> which forms the basis for this notebook.</p></li>
<li><p>Check out the paper <a class="reference external" href="https://quantum-journal.org/papers/q-2021-07-06-497/"><code class="docutils literal notranslate"><span class="pre">Stim:</span> <span class="pre">A</span> <span class="pre">fast</span> <span class="pre">stabilizer</span> <span class="pre">circuit</span> <span class="pre">simulator</span></code></a> to learn about Stim’s internals and how it is leveraging <a class="reference external" href="https://www.intel.com/content/www/us/en/support/articles/000005779/processors.html">SIMD instructions</a> to squeeze the maximum performance out of our CPUs.</p></li>
</ul>
<p>To learn more about the Surface Code:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1208.0928">Paper</a> introducing the surface code and logical gates by Fowler et al.</p></li>
<li><p>Google’s Surface Code experiment: <a class="reference external" href="https://arxiv.org/html/2408.13687v1#S11"><code class="docutils literal notranslate"><span class="pre">Quantum</span> <span class="pre">error</span> <span class="pre">correction</span> <span class="pre">below</span> <span class="pre">the</span> <span class="pre">surface</span> <span class="pre">code</span> <span class="pre">threshold</span></code></a> contains a lot of details about different noise simulation techniques and other decoder types.</p></li>
</ul>
<p>To learn more about QEC codes, visit the QEC Zoo: https://errorcorrectionzoo.org/ !</p>
</section>
</section>
</section>
<span id="document-qmc_fin"></span><section class="tex2jax_ignore mathjax_ignore" id="quantum-monte-carlo-and-quantum-finance">
<h2>Quantum Monte Carlo and quantum finance<a class="headerlink" href="#quantum-monte-carlo-and-quantum-finance" title="Link to this heading"></a></h2>
<section id="option-pricing-on-a-quantum-computer">
<h3>Option pricing on a quantum computer<a class="headerlink" href="#option-pricing-on-a-quantum-computer" title="Link to this heading"></a></h3>
<p><a class="reference download internal" download="" href="_downloads/0e1cb2e11af93ed4b7f071f4f39794f4/Quantum_option_pricing.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
<section id="quantum-amplitude-estimation-applications-to-derivative-pricing">
<h3>Quantum Amplitude Estimation – Applications to Derivative Pricing<a class="headerlink" href="#quantum-amplitude-estimation-applications-to-derivative-pricing" title="Link to this heading"></a></h3>
<p><a class="reference download internal" download="" href="_downloads/d5128287eee5efe48db69f4324e09b2a/amplitude_estimation.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
</section>
<span id="document-notebooks/option_pricing"></span><section class="tex2jax_ignore mathjax_ignore" id="pricing-a-european-call-option-on-a-quantum-computer">
<h2>Pricing a European call option on a quantum computer<a class="headerlink" href="#pricing-a-european-call-option-on-a-quantum-computer" title="Link to this heading"></a></h2>
<p>This notebook is based on the work of M. Q. Hlatshwayo, NQCC.</p>
<p>A call option is a financial contract in which the holder (buyer) has the right (but not the obligation) to buy a specified quantity of a security at a specified price (strike price) within a fixed period of time (until its expiration).</p>
<p>For the writer (seller) of a call option, it represents an obligation to sell the underlying security at the strike price if the option is exercised. The call option writer is paid a premium for taking on the risk associated with the obligation.</p>
<p>Suppose a European call option with strike price <span class="math notranslate nohighlight">\(K\)</span> and an underlying asset whose spot price at maturity <span class="math notranslate nohighlight">\(S_T\)</span> follows a given distribution.
The corresponding payoff function is defined as:</p>
<div class="math notranslate nohighlight">
\[f(S_T) = \max(S_T - K, 0)\]</div>
<p>In the following, a quantum algorithm based on amplitude estimation is used to estimate the expected payoff, i.e., the fair price before discounting, for the option:</p>
<div class="math notranslate nohighlight">
\[\mathbb{E}\left[f(S_T) \right] \approx \frac{1}{N} \sum_{i=1}^{N} f\left(S_T^{(i)}\right). \]</div>
<p>The approximation of the objective function and a general introduction to option pricing and risk analysis on quantum computers are given in the following papers:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.nature.com/articles/s41534-019-0130-6">Quantum Risk Analysis. Woerner, Egger. 2018.</a></p></li>
<li><p><a class="reference external" href="https://quantum-journal.org/papers/q-2020-07-06-291/">Option Pricing using Quantum Computers. Stamatopoulos et al. 2019.</a></p></li>
</ul>
<section id="encoding-the-probability-distribution">
<h3>Encoding the probability distribution<a class="headerlink" href="#encoding-the-probability-distribution" title="Link to this heading"></a></h3>
<p>We construct a circuit to load a log-normal random distribution into a quantum state.
The distribution is truncated to a given interval <span class="math notranslate nohighlight">\([x_{min}, x_{max}]\)</span> and discretized using <span class="math notranslate nohighlight">\(2^n\)</span> grid points, where <span class="math notranslate nohighlight">\(n\)</span> denotes the number of qubits used.
The unitary operator corresponding to the circuit implements the following:</p>
<div class="math notranslate nohighlight">
\[\big|0\rangle_{n} \mapsto \big|\psi\rangle_{n} = \sum_{i=0}^{2^n-1} \sqrt{p_i}\big|i\rangle_{n},\]</div>
<p>where <span class="math notranslate nohighlight">\(p_i\)</span> denote the probabilities corresponding to the truncated and discretized distribution and where <span class="math notranslate nohighlight">\(i\)</span> is mapped to the right interval using the affine map:</p>
<div class="math notranslate nohighlight">
\[ \{0, \ldots, 2^n-1\} \ni i \mapsto \frac{x_{max} - x_{min}}{2^n - 1} * i + x_{min} \in [x_{min}, x_{max}].\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">qiskit_finance.circuit.library</span> <span class="kn">import</span> <span class="n">LogNormalDistribution</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">AncillaRegister</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">LinearAmplitudeFunction</span><span class="p">,</span> <span class="n">QFT</span><span class="p">,</span> <span class="n">GroverOperator</span>
<span class="kn">from</span> <span class="nn">qiskit_algorithms</span> <span class="kn">import</span> <span class="n">EstimationProblem</span><span class="p">,</span> <span class="n">IterativeAmplitudeEstimation</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_distribution</span>
<span class="kn">from</span> <span class="nn">qiskit.primitives</span> <span class="kn">import</span> <span class="n">StatevectorSampler</span> <span class="k">as</span> <span class="n">Sampler</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># number of qubits to represent the stock price</span>
<span class="n">num_uncertainty_qubits</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># parameters for considered random distribution</span>
<span class="n">S</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># initial spot price</span>
<span class="n">vol</span> <span class="o">=</span> <span class="mf">0.4</span>  <span class="c1"># volatility of 40%</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># annual interest rate of 4%</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">/</span> <span class="mi">365</span>  <span class="c1"># 40 days to maturity</span>

<span class="c1"># resulting parameters for log-normal distribution</span>
<span class="n">mu</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">vol</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">T</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="n">vol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>

<span class="c1"># lowest and highest value considered for the spot price; in between, an equidistant discretization is considered.</span>
<span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mean</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">stddev</span><span class="p">)</span>
<span class="n">high</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">stddev</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># construct A operator for QAE for the payoff function by</span>
<span class="c1"># composing the uncertainty model and the objective</span>
<span class="n">uncertainty_model</span> <span class="o">=</span> <span class="n">LogNormalDistribution</span><span class="p">(</span>
    <span class="n">num_uncertainty_qubits</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># view circuit </span>
<span class="n">uncertainty_model</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0f353999f1c36b173de0e56c44069a7cf0cdf63c4b05cf16649988a8f56eea6a.png" src="_images/0f353999f1c36b173de0e56c44069a7cf0cdf63c4b05cf16649988a8f56eea6a.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># view detailed circuit in terms of basis gates</span>
<span class="n">uncertainty_model</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/7f135987213831143848ff2b87d095b6bccf629f72f3fe53e6c34bc382b555f9.png" src="_images/7f135987213831143848ff2b87d095b6bccf629f72f3fe53e6c34bc382b555f9.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="c1"># plot probability distribution</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">uncertainty_model</span><span class="o">.</span><span class="n">values</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">uncertainty_model</span><span class="o">.</span><span class="n">probabilities</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Spot Price at Maturity $S_T$ (EUR)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Probability ($\%$)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/b7ccf8bf6e31cf49b12e8ee49177525860e36590193f537455f8de8c6a90cfc2.png" src="_images/b7ccf8bf6e31cf49b12e8ee49177525860e36590193f537455f8de8c6a90cfc2.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set the strike price (should be within the low and the high value of the uncertainty)</span>
<span class="n">strike_price</span> <span class="o">=</span> <span class="mf">1.896</span>

<span class="c1"># plot exact payoff function (evaluated on the grid of the uncertainty model)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">uncertainty_model</span><span class="o">.</span><span class="n">values</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">strike_price</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;ro-&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Payoff Function&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Spot Price at Maturity $S_T$ (EUR)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Payoff Amount (EUR)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/983f731ca9bf5e9adb04491be1be14a00ef3e991e412d1ac046d77ff8a6f4900.png" src="_images/983f731ca9bf5e9adb04491be1be14a00ef3e991e412d1ac046d77ff8a6f4900.png" />
</div>
</div>
<p>The payoff function equals zero as long as the spot price at maturity <span class="math notranslate nohighlight">\(S_T\)</span> is less than the strike price <span class="math notranslate nohighlight">\(K\)</span> and then increases linearly.
The implementation uses a comparator, that flips an ancilla qubit from <span class="math notranslate nohighlight">\(\big|0\rangle\)</span> to <span class="math notranslate nohighlight">\(\big|1\rangle\)</span> if <span class="math notranslate nohighlight">\(S_T \geq K\)</span>, and this ancilla is used to control the linear part of the payoff function.</p>
<p>Eventually, we are interested in the probability of measuring <span class="math notranslate nohighlight">\(\big|1\rangle\)</span> in the last qubit. Recall that</p>
<div class="math notranslate nohighlight">
\[ \mathbb{P}(\textrm{measure 1}) = \mathbb{E}[f(X)] = \sum_{i=0}^{2^n-1}f(i)p_i.\]</div>
<p>For more details on the implementation, we refer to:</p>
<p><a class="reference external" href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.LinearAmplitudeFunction">LinearAmplitudeFunction | IBM Qiskit Documentation</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set the approximation scaling for the payoff function</span>
<span class="n">c_approx</span> <span class="o">=</span> <span class="mf">0.25</span>

<span class="c1"># setup piecewise linear objective function</span>
<span class="n">breakpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">low</span><span class="p">,</span> <span class="n">strike_price</span><span class="p">]</span>
<span class="n">slopes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">f_min</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">f_max</span> <span class="o">=</span> <span class="n">high</span> <span class="o">-</span> <span class="n">strike_price</span>
<span class="n">european_call_objective</span> <span class="o">=</span> <span class="n">LinearAmplitudeFunction</span><span class="p">(</span>
    <span class="n">num_uncertainty_qubits</span><span class="p">,</span>
    <span class="n">slopes</span><span class="p">,</span>
    <span class="n">offsets</span><span class="p">,</span>
    <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">),</span>
    <span class="n">image</span><span class="o">=</span><span class="p">(</span><span class="n">f_min</span><span class="p">,</span> <span class="n">f_max</span><span class="p">),</span>
    <span class="n">breakpoints</span><span class="o">=</span><span class="n">breakpoints</span><span class="p">,</span>
    <span class="n">rescaling_factor</span><span class="o">=</span><span class="n">c_approx</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># view payoff function circuit</span>
<span class="n">european_call_objective</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/9e2a31dc91d9118a18cc3567b6c9b7ffc5ab2eafc06276af757427e5519e3369.png" src="_images/9e2a31dc91d9118a18cc3567b6c9b7ffc5ab2eafc06276af757427e5519e3369.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># view payoff function circuit</span>
<span class="n">function_circuit</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span>
<span class="n">function_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/db5266744d324385665a73eae9cb55c9e6df93a06acec9da49b48e77a32bae56.png" src="_images/db5266744d324385665a73eae9cb55c9e6df93a06acec9da49b48e77a32bae56.png" />
</div>
</div>
</section>
<section id="combining-the-distribution-and-payoff-circuits">
<h3>Combining the distribution and payoff circuits<a class="headerlink" href="#combining-the-distribution-and-payoff-circuits" title="Link to this heading"></a></h3>
<p>We combine the circuits for the underlying distribution and the payoff function, respectively. The <span class="math notranslate nohighlight">\(q\)</span> qubit contains the expected value of the payoff. We add a measurement operator for <span class="math notranslate nohighlight">\(q\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># construct A operator for QAE for the payoff function by</span>
<span class="c1"># composing the uncertainty model and the objective</span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">num_qubits</span>
<span class="n">num_clbits</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">qreg</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">num_uncertainty_qubits</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="n">qreg2</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="n">qreg3</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">-</span><span class="n">num_uncertainty_qubits</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="n">creg</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">num_clbits</span><span class="p">,</span> <span class="s1">&#39;creg&#39;</span><span class="p">)</span>
<span class="n">european_call</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg</span><span class="p">,</span> <span class="n">qreg2</span><span class="p">,</span> <span class="n">qreg3</span><span class="p">)</span>
<span class="n">european_call</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uncertainty_model</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_uncertainty_qubits</span><span class="p">))</span>
<span class="n">european_call</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">european_call_objective</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="n">european_call</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/7664478dd822002b0129c9b32715f73325ab8a83ed630b1c2a73cb269ff8e244.png" src="_images/7664478dd822002b0129c9b32715f73325ab8a83ed630b1c2a73cb269ff8e244.png" />
</div>
</div>
<p>We can add a measurement to the objective qubit, in order to run the combined circuit and calculate the average <span class="math notranslate nohighlight">\(\hat p\)</span>. The average is scaled back from the <span class="math notranslate nohighlight">\([0,1]\)</span> interval to the original <span class="math notranslate nohighlight">\([x_{min}, x_{max}]\)</span> interval.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add a measurement to the objective qubit</span>
<span class="n">measured_european_call</span> <span class="o">=</span> <span class="n">european_call</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">measured_european_call</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">creg</span><span class="p">)</span>
<span class="n">measured_european_call</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qreg2</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>
<span class="c1"># draw the circuit</span>
<span class="n">measured_european_call</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2e128744a8cb1842892dea288139817b050b8f0767cb4578f37e6acd4561f198.png" src="_images/2e128744a8cb1842892dea288139817b050b8f0767cb4578f37e6acd4561f198.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run on local simulator</span>
<span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">()</span>
<span class="n">n_shots</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">measured_european_call</span><span class="p">],</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">creg</span><span class="o">.</span><span class="n">get_int_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_distribution</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/9287e76589832fd113ee8f799bb8bf21b5a368d32dd4c7156a161cfa3003c739.png" src="_images/9287e76589832fd113ee8f799bb8bf21b5a368d32dd4c7156a161cfa3003c739.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p_hat</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">n_shots</span>
<span class="n">p_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hat</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p_hat</span><span class="p">)</span><span class="o">/</span><span class="n">n_shots</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;raw estimated average:</span><span class="se">\t</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">p_hat</span><span class="p">,</span> <span class="s2">&quot;, standard deviation:</span><span class="se">\t</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">p_std</span><span class="p">)</span>

<span class="n">expectation</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">p_hat</span><span class="p">)</span>
<span class="n">upper</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">p_hat</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">p_std</span><span class="p">)</span>
<span class="n">lower</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">p_hat</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p_std</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;estimation of expected payoff:</span><span class="se">\t</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">expectation</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;lower confidence bound:</span><span class="se">\t</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">lower</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;upper confidence bound:</span><span class="se">\t</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">upper</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>raw estimated average:	0.3653 , standard deviation:	0.0048
estimation of expected payoff:	0.1440
lower confidence bound:	0.1215
upper confidence bound:	0.1665
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># evaluate exact expected value (normalized to the [0, 1] interval)</span>
<span class="n">exact_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uncertainty_model</span><span class="o">.</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;exact expected value from discretization:</span><span class="se">\t</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">exact_value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>exact expected value from discretization:	0.1623
</pre></div>
</div>
</div>
</div>
</section>
<section id="amplitude-estimation">
<h3>Amplitude estimation<a class="headerlink" href="#amplitude-estimation" title="Link to this heading"></a></h3>
<section id="convergence-rate-of-classical-monte-carlo">
<h4>Convergence rate of Classical Monte Carlo<a class="headerlink" href="#convergence-rate-of-classical-monte-carlo" title="Link to this heading"></a></h4>
<p>The standard Monte Carlo method for pricing consists in approximating the expected payoff <span class="math notranslate nohighlight">\(\mu = \mathbb{E}[f(S_T)]\)</span> as
$<span class="math notranslate nohighlight">\( \mu \approx \tilde{\mu}_N = \frac1{N} \sum_{i=1}^{N} f\left(S_T^{(i)} \right)\)</span>$</p>
<p>where <span class="math notranslate nohighlight">\(S_T^{(i)},  i=1,...,N \)</span> are independent, identically distributed samples from the probability distribution of the underlying asset <span class="math notranslate nohighlight">\(S\)</span> at the expiration time <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>A consequence of the central limit theorem is that the estimation error of the Monte Carlo method satisfies
$<span class="math notranslate nohighlight">\( \left|\tilde{\mu}_N-\mu \right| \sim \mathcal{O}\left(\frac1{\sqrt{N}}\right). \)</span>$</p>
</section>
<section id="id1">
<h4>Amplitude estimation<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<p>Quantum amplitude estimation (QAE) is a quantum algorithm that provides an alternative to classical Monte Carlo in order to compute approximate expectations of random variables.</p>
<p>Suppose we are able to construct a circuit that implements an operator acting on an (n+1) qubit register as follows
$<span class="math notranslate nohighlight">\(
    \mathcal{U}|0\rangle_{n+1} = \sqrt{1 - a}\ket{\psi_0}_n \ket{0}+ \sqrt{a}\ket{\psi_1}_n\ket{1},
\)</span><span class="math notranslate nohighlight">\(
where \)</span>a\in [0,1]<span class="math notranslate nohighlight">\( is an unknown quantity associated with the value \)</span>\mu<span class="math notranslate nohighlight">\( which we intend to estimate (e.g., an appropriate re-scaling of \)</span>\mu<span class="math notranslate nohighlight">\( to the interval \)</span>[0,1]$).</p>
<p>Then, QAE can be used to obtain an estimate of <span class="math notranslate nohighlight">\(a\)</span> through repeated controlled applications of the grover operator
$<span class="math notranslate nohighlight">\(
    Q = \mathcal{U} S_0 \mathcal{U}^{\dagger}S_{\Psi_0}
\)</span>$
and an inverse quantum Fourier transform.</p>
<p>For further details on the algorithm, the reader is refered to <a class="reference external" href="https://arxiv.org/abs/quant-ph/0005055">Quantum Amplitude Amplification and Estimation. Brassard et. al.</a></p>
<p>It can be shown that, with high probability (<span class="math notranslate nohighlight">\(8/\pi^2 \approx 81\%\)</span>), the estimate <span class="math notranslate nohighlight">\(\tilde{a}_M\)</span> provided by QAE satisfies
$<span class="math notranslate nohighlight">\(
\left| \tilde{a}_M-a\right| \le \frac{2\pi\sqrt{a(1-a)}}{M} + \frac{\pi^2}{M^2}  \sim \mathcal{O}\left(\frac{1}{M}\right),
\)</span><span class="math notranslate nohighlight">\(
where \)</span>M=2^m<span class="math notranslate nohighlight">\(, and \)</span>m$ is the number of ancilla qubits used by the algorithm.</p>
<p>That is, QAE provides a quadratic speedup over classical Monte Carlo.</p>
<p>QAE can be applied to the circuit constructed above, which encodes the expected payoff into the amplitude of the objective qubit. To this end, we decompose the circuit into basis gates:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">european_call</span> <span class="o">=</span> <span class="n">european_call</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Then, the QAE circuit can be constructed (you can look at the provided code <code class="docutils literal notranslate"><span class="pre">ae_circuit.py</span></code> to see how this is done).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AECircuit</span><span class="p">(</span><span class="n">QuantumCircuit</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_preparation_circuit</span><span class="p">,</span> <span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">objective_qubit</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_preparation_circuit</span> <span class="o">=</span> <span class="n">state_preparation_circuit</span> <span class="c1"># The cirtuit implementing operator A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span> <span class="o">=</span> <span class="n">num_ancilla_qubits</span> <span class="c1"># Number of ancilla qubits (m in IQAE paper)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_state_qubits</span> <span class="o">=</span> <span class="n">state_preparation_circuit</span><span class="o">.</span><span class="n">num_qubits</span> <span class="c1"># Number of qubits in circuit A (n+1 in the IQAE paper)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_qubit</span> <span class="o">=</span> <span class="n">objective_qubit</span> <span class="c1"># Index of the objective qubit within the circuit A (0&lt;=objective_qubit&lt;=num_state_qubits) </span>
   
        <span class="c1"># Initialize circuit </span>
        <span class="n">ancilla_register</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ancilla&quot;</span><span class="p">)</span>
        <span class="n">state_register</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_state_qubits</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;state&quot;</span><span class="p">)</span>
        <span class="n">classical_register</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;creg&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">ancilla_register</span><span class="p">,</span>
            <span class="n">state_register</span><span class="p">,</span>
            <span class="n">classical_register</span>
        <span class="p">)</span>
        
        <span class="c1"># Hadamard gates on the ancilla qubits</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">ancilla_register</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            
        <span class="c1"># Circuit A on the state and objective qubits</span>
        <span class="n">A_gate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_preparation_circuit</span><span class="o">.</span><span class="n">to_gate</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;$A$&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_gate</span><span class="p">,</span> <span class="n">state_register</span><span class="p">[:])</span>
       
        <span class="bp">self</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        
        <span class="c1"># Powers of Q</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groverOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_preparation_circuit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_qubit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ancilla_qubits</span><span class="p">):</span>
            <span class="n">Qj</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">to_gate</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;$Q^</span><span class="se">{{</span><span class="si">{</span><span class="mi">2</span><span class="o">**</span><span class="n">j</span><span class="si">}</span><span class="se">}}</span><span class="s2">$&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Controlled version of Q^{2j}</span>
            <span class="c1"># Apply the controlled Q^{2j} gate on state and objective qubits, controlled by the j-th ancilla qubit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qj</span><span class="p">,</span> <span class="p">[</span><span class="n">ancilla_register</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">state_register</span><span class="p">[:])</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
       
        <span class="c1"># Inverse QFT</span>
        <span class="n">QFT_gate</span> <span class="o">=</span> <span class="n">QFT</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_swaps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">to_gate</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;$QFT^\dagger$&quot;</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">QFT_gate</span><span class="p">,</span> <span class="n">ancilla_register</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        
        <span class="c1"># Measure the ancilla qubits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">ancilla_register</span><span class="p">,</span> <span class="n">classical_register</span><span class="p">)</span>
       
    <span class="k">def</span> <span class="nf">groverOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_preparation_circuit</span><span class="p">,</span> <span class="n">objective_qubit</span><span class="p">):</span>
        <span class="c1"># construct the grover operator</span>
        <span class="n">oracle</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">state_preparation_circuit</span><span class="o">.</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="n">state_preparation_circuit</span><span class="o">.</span><span class="n">num_ancillas</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">oracle</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">objective_qubit</span><span class="p">)</span>
        <span class="n">oracle</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">objective_qubit</span><span class="p">)</span>
        <span class="n">oracle</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">objective_qubit</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">GroverOperator</span><span class="p">(</span><span class="n">oracle</span><span class="p">,</span> <span class="n">state_preparation_circuit</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">Q</span>
    
<span class="n">num_ancilla_qubits</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">qae</span> <span class="o">=</span> <span class="n">AECircuit</span><span class="p">(</span><span class="n">state_preparation_circuit</span><span class="o">=</span><span class="n">european_call</span><span class="p">,</span> <span class="n">num_ancilla_qubits</span><span class="o">=</span><span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">objective_qubit</span><span class="o">=</span><span class="n">num_uncertainty_qubits</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qae</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>454840
</pre></div>
</div>
</div>
</div>
</section>
<section id="run-qae-on-local-simulator">
<h4>Run QAE on local simulator<a class="headerlink" href="#run-qae-on-local-simulator" title="Link to this heading"></a></h4>
<p>We can run QAE on our local simulator, and check that the estimator it produces is close to the MC estimator.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run on local simulator</span>
<span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">()</span>
<span class="n">n_shots</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">qae</span><span class="p">],</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">creg</span><span class="o">.</span><span class="n">get_int_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># QAE post-processing</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">num_ancilla_qubits</span> <span class="c1"># Number of grid points = 2^num_ancilla_qubits</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="n">theta_estimates</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">M</span>
<span class="n">estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_estimates</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
<span class="n">probabilities</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>

<span class="c1"># Combine duplicates</span>
<span class="n">new_estimates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">estimates</span><span class="p">))</span>
<span class="n">new_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">[</span><span class="n">estimates</span><span class="o">==</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">new_estimates</span><span class="p">]</span>
<span class="n">estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_estimates</span><span class="p">)</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_probabilities</span><span class="p">)</span>

<span class="n">p_mode</span> <span class="o">=</span> <span class="n">estimates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)]</span> <span class="c1"># Extract estimate with highest probability</span>
<span class="n">qae_expected_payoff</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">p_mode</span><span class="p">)</span> <span class="c1"># Re-scale estimate to get expected payoff</span>
<span class="n">qae_expected_payoff</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>np.float64(0.17487657133764406)
</pre></div>
</div>
</div>
</div>
<p>We can compute the accuracy of QAE as a function of quantum samples</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">estimate_ae</span><span class="p">(</span><span class="n">num_ancilla_qubits</span><span class="p">):</span>
    <span class="c1"># Construct QAE circuit</span>
    <span class="n">qae</span> <span class="o">=</span> <span class="n">AECircuit</span><span class="p">(</span><span class="n">state_preparation_circuit</span><span class="o">=</span><span class="n">european_call</span><span class="p">,</span> <span class="n">num_ancilla_qubits</span><span class="o">=</span><span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">objective_qubit</span><span class="o">=</span><span class="n">num_uncertainty_qubits</span><span class="p">)</span>
    
    <span class="c1"># Run on local simulator</span>
    <span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">()</span>
    <span class="n">n_shots</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">qae</span><span class="p">],</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">creg</span><span class="o">.</span><span class="n">get_int_counts</span><span class="p">()</span>
    
    <span class="c1"># Post-processing </span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">num_ancilla_qubits</span> <span class="c1"># Number of grid points = 2^num_ancilla_qubits</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">theta_estimates</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">M</span>
    <span class="n">estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_estimates</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
    <span class="n">probabilities</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>

    <span class="c1"># Combine duplicates</span>
    <span class="n">new_estimates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">estimates</span><span class="p">))</span>
    <span class="n">new_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">[</span><span class="n">estimates</span><span class="o">==</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">new_estimates</span><span class="p">]</span>
    <span class="n">estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_estimates</span><span class="p">)</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_probabilities</span><span class="p">)</span>

    <span class="n">p_mode</span> <span class="o">=</span> <span class="n">estimates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)]</span> <span class="c1"># Extract estimate with highest probability</span>
    <span class="k">return</span> <span class="n">p_mode</span>

<span class="n">ancillas_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">qae_estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">estimate_ae</span><span class="p">(</span><span class="n">num_ancilla_qubits</span><span class="p">)</span> <span class="k">for</span> <span class="n">num_ancilla_qubits</span> <span class="ow">in</span> <span class="n">ancillas_range</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot results</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ancillas_range</span><span class="p">)</span>
<span class="n">qae_expected_payoffs</span> <span class="o">=</span> <span class="n">qae_estimates</span>

<span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ancillas_range</span><span class="p">),</span> <span class="n">qae_expected_payoffs</span><span class="p">,</span> <span class="s2">&quot;.-&quot;</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># QAE estimates</span>

<span class="c1"># Confidence intervals</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ancillas_range</span><span class="p">)</span>
<span class="n">confidence_intervals</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qae_estimates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">qae_estimates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="n">M</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">qae_estimates</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">confidence_intervals</span><span class="p">),</span> <span class="n">qae_estimates</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">confidence_intervals</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;$M=2^m$&quot;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;QAE estimates&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/645d4eeeeb12b17bc5cc470b80221493bebc41eb373e6ea949a6890f9b74d9d7.png" src="_images/645d4eeeeb12b17bc5cc470b80221493bebc41eb373e6ea949a6890f9b74d9d7.png" />
</div>
</div>
<p><strong>Some thoughts</strong></p>
<p>Look at the depth of the QAE circuit. Is this algorithm NISQ-ready?</p>
<p>There are some more advanced versions of QAE, which attempt to reduce the required circuit depth without compromising accuracy. We refer the interested reader to</p>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1904.10246">Amplitude estimation without phase estimation. Suzuki et. al.</a>,</p></li>
<li><p><a class="reference external" href="https://arxiv.org/pdf/2003.02417">Faster Amplitude Estimation. Nakaji.</a>,</p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/1912.05559">Iterative Quantum Amplitude Estimation. Grinko et. al.</a>.</p></li>
</ul>
</section>
<section id="iterative-quantum-amplitude-estimation">
<h4>Iterative quantum amplitude estimation<a class="headerlink" href="#iterative-quantum-amplitude-estimation" title="Link to this heading"></a></h4>
<p><a class="reference external" href="https://arxiv.org/abs/1912.05559">Iterative quantum amplitude estimation (IQAE)</a> uses the same ideas as canonical QAE while reducing the while reducing circuit depth and the required number of ancillas.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">qiskit_algorithms</span></code> module implements the method <a class="reference external" href="https://qiskit-community.github.io/qiskit-algorithms/stubs/qiskit_algorithms.IterativeAmplitudeEstimation.html"><code class="docutils literal notranslate"><span class="pre">IterativeAmplitudeEstimation</span></code></a>, which can be used to estimate the expected payoff as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_aer.primitives</span> <span class="kn">import</span> <span class="n">Sampler</span>

<span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.05</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">EstimationProblem</span><span class="p">(</span>
    <span class="n">state_preparation</span><span class="o">=</span><span class="n">european_call</span><span class="p">,</span>
    <span class="n">objective_qubits</span><span class="o">=</span><span class="p">[</span><span class="n">num_uncertainty_qubits</span><span class="p">],</span>
    <span class="n">post_processing</span><span class="o">=</span><span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">iae</span> <span class="o">=</span> <span class="n">IterativeAmplitudeEstimation</span><span class="p">(</span>
    <span class="n">epsilon_target</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="p">(</span><span class="n">run_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;shots&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">iae</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>

<span class="n">conf_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">confidence_interval_processed</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exact value:        </span><span class="se">\t</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">exact_value</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estimated value:    </span><span class="se">\t</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">estimation_processed</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Confidence interval:</span><span class="se">\t</span><span class="s2">[</span><span class="si">%.4f</span><span class="s2">, </span><span class="si">%.4f</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">conf_int</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Exact value:        	0.1623
Estimated value:    	0.1676
Confidence interval:	[0.1615, 0.1737]
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<span id="document-notebooks/option_pricing_tutorial"></span><hr class="docutils" />
<section class="tex2jax_ignore mathjax_ignore" id="tutorial-pricing-a-european-call-option-using-quantum-computing">
<h2>Tutorial - Pricing a European call option using quantum computing<a class="headerlink" href="#tutorial-pricing-a-european-call-option-using-quantum-computing" title="Link to this heading"></a></h2>
<p>Welcome!👋👋 This tutorial notebook is designed such that you will get to work hands-on with pricing a European call option using quantum computing algorithms. It is structured in the following 4 sections:</p>
<ol class="arabic simple" start="0">
<li><p>Reminder - what is a European call option?</p></li>
<li><p>Asset distributions and payoff function</p></li>
<li><p>Classical Monte Carlo on a QC</p></li>
<li><p>Quantum Amplitude Estimation (QAE)</p></li>
</ol>
<p>If you have any questions or need assistance, dont hesitate to find either one of us in the room and we’ll try and help you! 🤗</p>
<p>Authors: Björn Löfdahl, Victorio Úbeda Sosa, Wilhelm Ågren</p>
<hr class="docutils" />
<section id="reminder-what-is-a-european-call-option">
<h3>0. Reminder - what is a European call option?<a class="headerlink" href="#reminder-what-is-a-european-call-option" title="Link to this heading"></a></h3>
<p>A call option is a financial contract in which the holder (buyer) has the right (but not the obligation) to buy a specified quantity of a security at a specified price (strike price) within a fixed period of time (until its expiration/maturity). For a European call option the holder can only exercise the option at expiry/maturity.</p>
<p>For the writer (seller) of a call option, it represents an obligation to sell the underlying security at the strike price if the option is exercised. The call option writer is paid a premium for taking on the risk associated with the obligation (this is however omitted here as it only offsets the payoff by the premium price).</p>
<p>Suppose a European call option with strike price <span class="math notranslate nohighlight">\(K\)</span> and and underlying asset whose spot price at maturity <span class="math notranslate nohighlight">\(S_T\)</span> follows a given distribution, then the corresponding payoff function for the holder is defined as</p>
<div class="math notranslate nohighlight">
\[
\phi(S_T) = \max(S_T - K, 0).
\]</div>
<p>For an investor to profit from a European call option, the spot price at maturity <span class="math notranslate nohighlight">\(S_T\)</span> has to be high enough above the strike price to cover the cost of the option premium.</p>
<section id="simple-example">
<h4>Simple example<a class="headerlink" href="#simple-example" title="Link to this heading"></a></h4>
<p>Assume that Bob is the writer for a European call option with <a class="reference external" href="https://www.avanza.se/aktier/om-aktien.html/1284389/ionq">IonQ</a> (NYSE: IONQ) as the underlying with spot price <span class="math notranslate nohighlight">\(S_0=€30\)</span>. The contract has maturity time <span class="math notranslate nohighlight">\(T\)</span> of 30 days from today, strike price <span class="math notranslate nohighlight">\(K=€35\)</span>, with a premium of <span class="math notranslate nohighlight">\(€5\)</span> per contract. In this simple example we disregard all brokerage and assume that Bob does not already own the underlying asset (referred to as a naked call option).</p>
<p>Is this premium too high? Is it too low? Is it perhaps a fair price? 🤔</p>
<p>Alice is interested in buying this call option but is unsure whether Bob has a fair premium on the contract. However, Alice strongly believes that IonQ will be trading for <span class="math notranslate nohighlight">\(€50\)</span> in 30 days (i.e. at maturity <span class="math notranslate nohighlight">\(T\)</span>). Fast forward 30 days and in this case Alices’ beliefs turned out to be true, thus she will make <span class="math notranslate nohighlight">\(S_T - K - \text{premium} = 50 - 35 - 5 = €10\)</span> per contract.</p>
<p>If IonQ would be worth less than the strike price <span class="math notranslate nohighlight">\(K\)</span> at maturity <span class="math notranslate nohighlight">\(T\)</span> then the option is not exercised and expires worthless. The holder (Alice) loses the premium and the writer (Bob) profits on the premium.</p>
<p>Why would Bob want to write this specific call option? Based on the strike price <span class="math notranslate nohighlight">\(K=€35\)</span> and the premium <span class="math notranslate nohighlight">\(€5\)</span> we know that Bob makes money if IonQ is trading for less than <span class="math notranslate nohighlight">\(€40\)</span> at maturity (<span class="math notranslate nohighlight">\(\text{premium} -(S_T - K) = 5 - (40 - 35)\)</span>). If <span class="math notranslate nohighlight">\(S_T=€38\)</span> then Bob makes <span class="math notranslate nohighlight">\(5 - (38 -35) = €2\)</span> per contract. So Bob would only really want to write this call option because he believes that IonQ will not be worth much more in the future.</p>
<p>In our simple case above Alice accepted the premium (the price of the option) based solely on her strong belief that IonQ would be worth much more in the future. But could she in some way have made a better decision on whether or not the premium of the call option was fair?</p>
<p>Yes, she herself could have estimated a fair price of the call option based on e.g. the current spot price <span class="math notranslate nohighlight">\(S_t\)</span>, the desired strike price <span class="math notranslate nohighlight">\(K\)</span>, the time to maturity <span class="math notranslate nohighlight">\(T\)</span>, the risk-free rate <span class="math notranslate nohighlight">\(r\)</span>, the assets implied volatility <span class="math notranslate nohighlight">\(\sigma\)</span> by, and a prediction on the value of the underlying at maturity, by estimating the discounted expected payoff</p>
<div class="math notranslate nohighlight">
\[
v = e^{-rT}\mathbb{E}[\phi(S_T)] = e^{-rT}\mathbb{E}[\max(S_T - K, 0)].
\]</div>
<p>So what should be the fair price of the European call option? Let’s estimate it using quantum computing! 🚀</p>
</section>
</section>
<section id="asset-distributions-and-payoff-function">
<h3>1. Asset distributions and payoff function<a class="headerlink" href="#asset-distributions-and-payoff-function" title="Link to this heading"></a></h3>
<p>The first step in estimating a fair price for the European call option is to encode/load the distribution of the underlying asset on to a quantum circuit. Assume that the underlying asset can be described by the Geometric Brownian Motion</p>
<div class="math notranslate nohighlight">
\[
dS_t = rS_tdt + \sigma S_tdW_t
\]</div>
<p>and that we follow the Black &amp; Scholes model such that the spot price at time <span class="math notranslate nohighlight">\(S_t\)</span> is described by the following log-normal distribution</p>
<div class="math notranslate nohighlight">
\[
ln\Bigl( \frac{S_T}{S_t} \Bigr) \sim N\Bigl( (r - \frac{1}{2}\sigma^2)T, \, \sigma \sqrt{T} \Bigr)
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> is the annual drift rate of S and we denote <span class="math notranslate nohighlight">\(\sigma'\)</span> as its scaled volatility, such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\mu = (r - \frac{\sigma^2}{2})&amp; T + \log(S_0)\\
\sigma' =\, &amp; \sigma \sqrt{T}
\end{align}
\end{split}\]</div>
<p>Because we will be working with quantum circuits in this tutorial, we will have to create an equidistant discretization of the distribution on to <span class="math notranslate nohighlight">\(2^n\)</span> grid points, where <span class="math notranslate nohighlight">\(n\)</span> is the number of qubits of our quantum circuit. To be able to do this we also have to limit the range of the distribution to some interval, e.g., between 3 standard deviations of its mean</p>
<div class="math notranslate nohighlight">
\[
x \sim N(\mu, \sigma') \in [\mu - 3\sigma', \mu + 3\sigma'].
\]</div>
<section id="exercise">
<h4>📝 Exercise<a class="headerlink" href="#exercise" title="Link to this heading"></a></h4>
<p>Now we want you to:</p>
<ol class="arabic simple">
<li><p>Classically create the distribution that we just defined, and sample from it on an equidistant interval.</p></li>
<li><p>Change the variables around and see how the distribution of the spot price at maturity <span class="math notranslate nohighlight">\(S_T\)</span> changes.</p></li>
<li><p>What happens if the asset has a large initial spot price <span class="math notranslate nohighlight">\(S_0 &gt; 10\)</span> with a relatively high volatility <span class="math notranslate nohighlight">\(\sigma &gt; 0.2\)</span>?</p>
<ul class="simple">
<li><p>Hint: perhaps we have too few qubits to represent such a “wide” distribution?</p></li>
</ul>
</li>
</ol>
<p>Some help to get you started:</p>
<ul class="simple">
<li><p>To calculate <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> refer to the above equations.</p></li>
<li><p>To create an equidistant range with <span class="math notranslate nohighlight">\(2^n\)</span> grid points you can use the <code class="docutils literal notranslate"><span class="pre">np.linspace</span></code> method.</p></li>
<li><p>Normalizing the distribution in this context means that the probabilities should sum to 1.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

<span class="n">n_uncertainty_qubits</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># change this also if you want to :)</span>
<span class="n">n_qubit_states</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_uncertainty_qubits</span>

<span class="n">S</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># initial spot price</span>
<span class="n">volatility</span> <span class="o">=</span> <span class="mf">0.4</span>  <span class="c1"># implied volatility</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># risk-free market rate</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">/</span> <span class="mi">365</span>  <span class="c1"># time to maturity</span>

<span class="n">mu</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># this should be the annualized drift rate of S</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># this should be the scaled volatility</span>

<span class="c1"># Some properties of the log-normal distribution</span>
<span class="c1"># https://en.wikipedia.org/wiki/Log-normal_distribution</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>

<span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">mean</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">std_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">high</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">std_dev</span>

<span class="c1"># Scipy log-normal distribution</span>
<span class="c1"># https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.lognorm.html</span>
<span class="n">lognorm_scale</span> <span class="o">=</span> <span class="n">S</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">T</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">xx</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># create an equidistant interval from `low` to `high` with `n_qubit_states` grid points</span>
<span class="n">yy</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lognorm_scale</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span>
<span class="n">yy</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># normalize the pdf</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.05</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">,</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$ln \frac</span><span class="si">{S_T}{S_t}</span><span class="s2"> \sim N((r - \frac</span><span class="si">{1}{2}</span><span class="s2">\sigma^2)T, \sigma\sqrt</span><span class="si">{T}</span><span class="s2">)$&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Spot price at maturity $S_T$ (€)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Probability ($\%$)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="encode-the-distribution-onto-a-quantum-circuit">
<h4>Encode the distribution onto a quantum circuit<a class="headerlink" href="#encode-the-distribution-onto-a-quantum-circuit" title="Link to this heading"></a></h4>
<p>Next we need to construct a circuit to load the log-normal distribution into a quantum state. The distribution as defined before is truncated to the given interval <span class="math notranslate nohighlight">\([\mu - 3\sigma, \mu + 3\sigma]\)</span> and discretized using <span class="math notranslate nohighlight">\(2^n\)</span> grid points, where <span class="math notranslate nohighlight">\(n\)</span> denotes the number of qubits we are using. The unitary operator <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> coresponding to the circuit can be represented as</p>
<div class="math notranslate nohighlight">
\[
\mathcal{A}\ket{0}_n = \sum_{i=0}^{2^n - 1} \sqrt{p_i}\ket{i}_n
\]</div>
<p>where <span class="math notranslate nohighlight">\(\ket{i}_n\)</span> is the <span class="math notranslate nohighlight">\(i^{th}\)</span> state, <span class="math notranslate nohighlight">\(p_i\)</span> represents the probability of measuring the <span class="math notranslate nohighlight">\(i^{th}\)</span> discretized grid.</p>
<p>We can use a pre-defined circuit from the <code class="docutils literal notranslate"><span class="pre">qiskit-finance</span></code> library which calculates the same probabilities as we did above and then initalizes a circuit with gates that encode the probabilities for the states. It uses the <a class="reference external" href="https://github.com/Qiskit/qiskit/blob/5f3f59469fcd9edae2feb80f74026265ebceb29a/qiskit/circuit/library/data_preparation/initializer.py#L33C7-L33C17">Initialize</a> class from the main <code class="docutils literal notranslate"><span class="pre">qiskit</span></code> library to create a circuit with gates that represent the provided probabilities.</p>
</section>
<section id="id1">
<h4>📝 Exercise<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<p>No we want you to:</p>
<ol class="arabic simple">
<li><p>Change the number of qubits (defined in the code cell above) and see how the depth of the circuit changes.</p>
<ul class="simple">
<li><p>What happens to the depth? Is this a sustainable behaviour?</p></li>
</ul>
</li>
<li><p>Look at the types of gates and try and think about what would happen if the hardware we wanted to run on only supported a certain set of (native) basis gates. Do you think the circuit would be deeper? Shallower? What are you thoughts?</p>
<ul class="simple">
<li><p>You will get to explore this practically later in the tutorial, but it is good to start thinking about already.</p></li>
</ul>
</li>
<li><p>Verify that the quantum circuit has implemented the expected distribution (the one you made in the code cell above).</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_finance.circuit.library</span> <span class="kn">import</span> <span class="n">LogNormalDistribution</span>

<span class="n">uncertainty_model</span> <span class="o">=</span> <span class="n">LogNormalDistribution</span><span class="p">(</span>
    <span class="n">n_uncertainty_qubits</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">decomposed_uncertainy_model</span> <span class="o">=</span> <span class="n">uncertainty_model</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Depth of the P(X) circuit: </span><span class="si">{</span><span class="n">decomposed_uncertainy_model</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">n_uncertainty_qubits</span><span class="si">}</span><span class="s2"> qubits)&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">uncertainty_model</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">))</span>
<span class="n">display</span><span class="p">(</span><span class="n">decomposed_uncertainy_model</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">))</span>

<span class="c1"># Verify that the circuit encodes the same probability distribution.</span>
<span class="c1"># You should see the exact same distribution as above when we used `scipy.stats.lognorm.pdf`.</span>

<span class="n">xx</span> <span class="o">=</span> <span class="n">uncertainty_model</span><span class="o">.</span><span class="n">values</span>
<span class="n">yy</span> <span class="o">=</span> <span class="n">uncertainty_model</span><span class="o">.</span><span class="n">probabilities</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.05</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">,</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$ln \frac</span><span class="si">{S_T}{S_t}</span><span class="s2"> \sim N((r - \frac</span><span class="si">{1}{2}</span><span class="s2">\sigma^2)T, \sigma\sqrt</span><span class="si">{T}</span><span class="s2">)$&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Spot price at maturity $S_T$ (€)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Probability ($\%$)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="encoding-the-payoff-function">
<h3>Encoding the payoff function<a class="headerlink" href="#encoding-the-payoff-function" title="Link to this heading"></a></h3>
<p>Next step is to encode the payoff function onto a quantum circuit. Remember that the payoff function is defined as</p>
<div class="math notranslate nohighlight">
\[
f(X) = \max(X - K, 0)
\]</div>
<p>and since we have a equidistant discretized grid for the random variable <span class="math notranslate nohighlight">\(X\)</span> on <span class="math notranslate nohighlight">\(\{0, 1, \dots, 2^n - 1\}\)</span> we can define an operator <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> as</p>
<div class="math notranslate nohighlight">
\[
\mathcal{F}\ket{i}_n\ket{0} = \sqrt{1 - f(i)}\ket{i}_n\ket{0} + \sqrt{f(i)}\ket{i}_n\ket{1}
\]</div>
<p>where it is required that the function <span class="math notranslate nohighlight">\(f(x) \mapsto [0, 1]\)</span>. Applying the operator <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> to our distribution operator <span class="math notranslate nohighlight">\(\mathcal{A}\ket{0}_n\ket{0}\)</span> yields</p>
<div class="math notranslate nohighlight">
\[
\mathcal{F}\mathcal{A}\ket{0}_n\ket{0} = \dots \ket{0} + \sum_{i=0}^{2^n-1}\sqrt{f(i)}\sqrt{p_i}\ket{i}_n\ket{1}
\]</div>
<p>where we get that the probability of measuring <span class="math notranslate nohighlight">\(\ket{1}\)</span> in the final qubit is</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=0}^{2^n-1} f(i)p_i = \mathbb{E}[f(X)].
\]</div>
<p>However, we have a problem, because our payoff function does not currently map to the <span class="math notranslate nohighlight">\([0, 1]\)</span> interval. To fix this we can rescale it as</p>
<div class="math notranslate nohighlight">
\[
\hat{f}(X) = \frac{f(\phi(X))}{f(X_{\max})},\,\, \text{with}\,\,\phi(X) = X_{\min} + X * \frac{X_{\max} - X_{\min}}{2^n - 1}.
\]</div>
<section id="id2">
<h4>📝 Exercise<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<p>No we want you to:</p>
<ol class="arabic simple">
<li><p>Set a desired strike price <span class="math notranslate nohighlight">\(K\)</span></p></li>
<li><p>Implement the payoff function <span class="math notranslate nohighlight">\(f(X)\)</span> classically</p></li>
</ol>
<p>Some help:</p>
<ul class="simple">
<li><p>Set the strike price based on your belief on how the underlying assets value will evolve until the time to maturity.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">np.maximum</span></code> method can be used to get the largest of two values.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">K</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># define a strike price</span>

<span class="n">xx</span> <span class="o">=</span> <span class="n">uncertainty_model</span><span class="o">.</span><span class="n">values</span>
<span class="n">yy</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># implement the payoff function</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Payoff function $\phi(S_T) = \max(S_T - K, 0)$&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Spot price at maturity $S_T$ (€)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Payoff amount (€)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.05</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">,</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Now we want to implement this function on a quantum circuit. The <a class="reference external" href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.LinearAmplitudeFunction">LinearAmplitudeFunction</a> in the qiskit circuit library uses <a class="reference external" href="https://github.com/Qiskit/qiskit/blob/main/qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py#L27">PiecewiseLinearPauliRotations</a> to implement the piecewise linear function which is our payoff function.</p>
</section>
<section id="id3">
<h4>📝 Exercise<a class="headerlink" href="#id3" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Set the slopes of the piecewise payoff function.</p></li>
<li><p>Set the minimum and maximum value that the payoff function can have.</p></li>
</ol>
<p>Some help:</p>
<ul class="simple">
<li><p>Look at the above plot of the payoff function and try and figure out which two lines together make up the payoff function.</p>
<ul>
<li><p>Hint: At the strike price <span class="math notranslate nohighlight">\(K\)</span> we start making money, before that, we profit nothing (payoff=0).</p></li>
</ul>
</li>
<li><p>What is the minimum amount of money that we can make? Think logically 😊</p></li>
<li><p>The maximum amount of money we can make depends on the highest value in our equidistant range.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">LinearAmplitudeFunction</span>

<span class="c1"># approximation scaling for the payoff function, determines accuracy in the Taylor approximation.</span>
<span class="c1"># https://www.nature.com/articles/s41534-019-0130-6</span>
<span class="n">c_approx</span> <span class="o">=</span> <span class="mf">0.25</span>

<span class="c1"># piecewise linear with breakpoints on x_min and when S_T &gt;= K.</span>
<span class="n">breakpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
<span class="n">slopes</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># set the slopes of the piecewise linear payoff function</span>
<span class="n">offsets</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">f_min</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># set the minimum value that the payoff function can have</span>
<span class="n">f_max</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># set the maximum value that the payoff function can have</span>
<span class="n">european_call_objective</span> <span class="o">=</span> <span class="n">LinearAmplitudeFunction</span><span class="p">(</span>
    <span class="n">num_state_qubits</span><span class="o">=</span><span class="n">n_uncertainty_qubits</span><span class="p">,</span>
    <span class="n">slope</span><span class="o">=</span><span class="n">slopes</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
    <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">),</span>
    <span class="n">image</span><span class="o">=</span><span class="p">(</span><span class="n">f_min</span><span class="p">,</span> <span class="n">f_max</span><span class="p">),</span>
    <span class="n">breakpoints</span><span class="o">=</span><span class="n">breakpoints</span><span class="p">,</span>
    <span class="n">rescaling_factor</span><span class="o">=</span><span class="n">c_approx</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">decomposed_european_call_objective</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Depth of the f(x) circuit: </span><span class="si">{</span><span class="n">decomposed_european_call_objective</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">n_uncertainty_qubits</span><span class="si">}</span><span class="s2"> qubits)&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">decomposed_european_call_objective</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="wait-now-we-are-working-with-more-qubits-than-we-originally-specified-for-p-x">
<h4>Wait, now we are working with more qubits than we originally specified for <span class="math notranslate nohighlight">\(P(X)\)</span>.. ❓<a class="headerlink" href="#wait-now-we-are-working-with-more-qubits-than-we-originally-specified-for-p-x" title="Link to this heading"></a></h4>
<p>For each qubit in our <span class="math notranslate nohighlight">\(P(X)\)</span> circuit we need an equal amount of qubits as ancilla qubits for the payoff function circuit, plus one extra qubit which encodes the value that we are trying to estimate in its <span class="math notranslate nohighlight">\(\ket{1}\)</span> state.</p>
</section>
<section id="id4">
<h4>📝 Exercise<a class="headerlink" href="#id4" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>For a circuit with <span class="math notranslate nohighlight">\(n\)</span> qubits for the <span class="math notranslate nohighlight">\(P(X)\)</span> circuit, how many total qubits would we need to construct the full circuit with both <span class="math notranslate nohighlight">\(P(X)\)</span> and the payoff function circuit?</p>
<ul class="simple">
<li><p>Hint: change the number of qubits for <span class="math notranslate nohighlight">\(P(X)\)</span> and see how the number of qubits changes for the payoff function circuit.</p></li>
</ul>
</li>
</ol>
</section>
<section id="now-we-need-to-add-the-p-x-distribution-circuit-to-before-the-payoff-function">
<h4>Now we need to add the <span class="math notranslate nohighlight">\(P(X)\)</span> distribution circuit to before the payoff function<a class="headerlink" href="#now-we-need-to-add-the-p-x-distribution-circuit-to-before-the-payoff-function" title="Link to this heading"></a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">AncillaRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span>

<span class="n">n_payoff_qubits</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">num_qubits</span>
<span class="n">n_cl_bits</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">qreg_s</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="n">n_uncertainty_qubits</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
<span class="n">qreg_target</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">)</span>
<span class="n">qreg_a</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="n">n_payoff_qubits</span> <span class="o">-</span> <span class="n">n_uncertainty_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="n">creg</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">n_cl_bits</span><span class="p">,</span> <span class="s2">&quot;creg&quot;</span><span class="p">)</span>

<span class="n">european_call</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qreg_s</span><span class="p">,</span> <span class="n">qreg_target</span><span class="p">,</span> <span class="n">qreg_a</span><span class="p">)</span>
<span class="n">european_call</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uncertainty_model</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_uncertainty_qubits</span><span class="p">))</span>
<span class="n">european_call</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">european_call_objective</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_payoff_qubits</span><span class="p">))</span>

<span class="n">measured_european_call</span> <span class="o">=</span> <span class="n">european_call</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">measured_european_call</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">creg</span><span class="p">)</span>
<span class="n">measured_european_call</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qreg_target</span><span class="p">,</span> <span class="n">creg</span><span class="p">)</span>

<span class="n">decomposed_european_call</span> <span class="o">=</span> <span class="n">european_call</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">decomposed_measured_european_call</span> <span class="o">=</span> <span class="n">measured_european_call</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Depth of the P(X) + f operations circuit: </span><span class="si">{</span><span class="n">decomposed_measured_european_call</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">decomposed_measured_european_call</span><span class="o">.</span><span class="n">num_qubits</span><span class="si">}</span><span class="s2"> qubits)&quot;</span><span class="p">)</span>

<span class="n">display</span><span class="p">(</span><span class="n">measured_european_call</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">))</span>
<span class="n">display</span><span class="p">(</span><span class="n">decomposed_measured_european_call</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="do-you-see-any-potential-issues-with-the-circuit-depth">
<h4>Do you see any potential issues with the circuit depth?<a class="headerlink" href="#do-you-see-any-potential-issues-with-the-circuit-depth" title="Link to this heading"></a></h4>
<p>What would happen to the depth if we had to apply the payoff function circuit <span class="math notranslate nohighlight">\(f(x)\)</span> multiple times?</p>
</section>
</section>
<hr class="docutils" />
<section id="classical-monte-carlo-on-a-qc">
<h3>2. Classical Monte Carlo on a QC<a class="headerlink" href="#classical-monte-carlo-on-a-qc" title="Link to this heading"></a></h3>
<p>If we sample multiple times from the circuit that we have defined above then we can get an estimate of the expected payoff, however, <strong>this is just classical monte carlo but performed using quantum circuits.</strong></p>
<p>There is no potential speed-up involved by doing this, but doing this step might be helpful for you to see and understand the gains with doing actual Quantum Monte Carlo (also referred to as Quantum Amplitude Estimation), which you will get to do soon in this tutorial.</p>
<section id="estimate-the-expected-payoff-for-the-european-call-option">
<h4>Estimate the expected payoff for the European call option<a class="headerlink" href="#estimate-the-expected-payoff-for-the-european-call-option" title="Link to this heading"></a></h4>
<p>Now you will perform classical monte carlo using the quantum circuit that you created above. We are specifically interested in the probability of measuring the <span class="math notranslate nohighlight">\(\ket{1}\)</span> state in the target qubit</p>
<div class="math notranslate nohighlight">
\[
\mathbb{P}(\text{measure  } 1) = \mathbb{E}[f(X)] = \sum_{i=0}^{2^n-1}f(i)p_i
\]</div>
<p>and with probability <span class="math notranslate nohighlight">\(1 - \delta\)</span>, the estimate <span class="math notranslate nohighlight">\(\tilde{\mu}\)</span> satisfies <span class="math notranslate nohighlight">\(|\mu - \tilde{\mu}| &lt; \epsilon\)</span> with</p>
<div class="math notranslate nohighlight">
\[
|\mu - \tilde{\mu}| \leq \phi^{-1}\Bigl( 1 - \frac{\delta}{2} \Bigr)\frac{\text{Var}(f(S_T))}{\sqrt{N}} \sim \mathcal{O}\Bigl( \frac{1}{\sqrt{N}} \Bigr)
\]</div>
</section>
<section id="id5">
<h4>📝 Exercise<a class="headerlink" href="#id5" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Determine how many samples you want to take.</p>
<ul class="simple">
<li><p>Try both a small - and a large amount, and see how the estimation and its confidence bound changes.</p></li>
</ul>
</li>
<li><p>Rescale the estimated value to its original interval <span class="math notranslate nohighlight">\([x_{\min}, x_{\max}]\)</span>.</p>
<ul class="simple">
<li><p>Hint: the circuit used for implementing the objective function has a method called <a class="reference external" href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.LinearAmplitudeFunction#post_processing">post_processing</a> that can be used to map the scaled results to its original domain.</p></li>
</ul>
</li>
<li><p>Define a confidence bound on the estimated value.</p>
<ul class="simple">
<li><p>Hint: assume a confidence bound on <span class="math notranslate nohighlight">\([\mu - 2\sigma, \mu + 2\sigma]\)</span> and use the same method as above to rescale to the correct interval.</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.primitives</span> <span class="kn">import</span> <span class="n">StatevectorSampler</span> <span class="k">as</span> <span class="n">Sampler</span>

<span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">()</span>
<span class="n">n_shots</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># how many samples do you want to take for your MC?</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">measured_european_call</span><span class="p">,</span> <span class="p">],</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="n">quasi_dist_dict</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">creg</span><span class="o">.</span><span class="n">get_int_counts</span><span class="p">()</span>
<span class="n">quasi_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">quasi_dist_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">quasi_dist_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">quasi_dist</span> <span class="o">/</span> <span class="n">quasi_dist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">([</span><span class="s2">&quot;|0&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;|1&gt;&quot;</span><span class="p">],</span> <span class="n">dist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Probability of measuring either $|0&gt;$ or $|1&gt;$&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Quasi-probability ($\%$)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">p_hat</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">p_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hat</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_hat</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_shots</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Raw estimated mu=</span><span class="si">{</span><span class="n">p_hat</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">, std=</span><span class="si">{</span><span class="n">p_std</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">mc_expectation</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># estimated value</span>
<span class="n">mc_lower_conf</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># lower confidence bound</span>
<span class="n">mc_upper_conf</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># upper confidence bound</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimation of the expected payoff:</span><span class="se">\t\t</span><span class="si">{</span><span class="n">mc_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">exact_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uncertainty_model</span><span class="o">.</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">uncertainty_model</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">K</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exact expected value from discretization:</span><span class="se">\t</span><span class="si">{</span><span class="n">exact_value</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Confidence bound on estimation:</span><span class="se">\t\t</span><span class="s2">(</span><span class="si">{</span><span class="n">mc_lower_conf</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">mc_upper_conf</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="quantum-amplitude-estimation-qae">
<h3>3. Quantum Amplitude Estimation (QAE)<a class="headerlink" href="#quantum-amplitude-estimation-qae" title="Link to this heading"></a></h3>
<p>Remember that the standard Monte Carlo method for pricing consists in approximating the expected payoff <span class="math notranslate nohighlight">\(\mu = \mathbb{E}[f(S_T)]\)</span> as</p>
<div class="math notranslate nohighlight">
\[
\mu \approx \tilde{\mu}_N = \frac{1}{N}\sum_{i=1}^Nf \Bigl( S_T^{(i)} \Bigr)
\]</div>
<p>where <span class="math notranslate nohighlight">\(S_T^{(i)},\, i=1,\dots,N\)</span> are i.i.d samples from the probability distribution of the underlying asset <span class="math notranslate nohighlight">\(S\)</span> at the expiration time <span class="math notranslate nohighlight">\(T\)</span>. Note that a consequence of the central limit theorem is that the estimation error of the classical Monte Carlo method satisfies</p>
<div class="math notranslate nohighlight">
\[
|\mu - \tilde{\mu}| \sim \mathcal{O}\Bigl( \frac{1}{\sqrt{N}} \Bigr)
\]</div>
<p>and the posed question is whether or not the estimation error rate can be improved on?</p>
<p>Quantum Amplitude Estimation (QAE) is a quantum algorithm that provides an alternative to the classical Monte Carlo in order to compute approximate expectations of random variables.</p>
<p>Suppose we are able to construct a circuit that implements a state preparation operator <span class="math notranslate nohighlight">\(\mathcal{U}\)</span> acting on an <span class="math notranslate nohighlight">\((n+1)\)</span> qubit register as follows</p>
<div class="math notranslate nohighlight">
\[
\mathcal{U}\ket{0}_{n+1} = \sqrt{1 - a}\ket{\psi_0}_n \ket{0}+ \sqrt{a}\ket{\psi_1}_n\ket{1}
\]</div>
<p>where <span class="math notranslate nohighlight">\(a\in[0, 1]\)</span> is an unknonwn quantity associated with the value <span class="math notranslate nohighlight">\(\mu\)</span> which we want to estimate (e.g. an appropriate re-scaling of <span class="math notranslate nohighlight">\(\mu\)</span> to the interval <span class="math notranslate nohighlight">\([0, 1]\)</span>).</p>
<p>Then, QAE can be used to obtain an estimate of <span class="math notranslate nohighlight">\(a\)</span> through repeated controlled applications of the <a class="reference external" href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.GroverOperator">Grover operator</a></p>
<div class="math notranslate nohighlight">
\[
\mathcal{Q} = \mathcal{U}S_0\mathcal{U}^{\dagger}S_{\Psi_0}
\]</div>
<p>together with an inverse <a class="reference external" href="https://courses.physics.illinois.edu/phys498cmp/sp2022/QC/QFT.html">Quantum Fourier Transform (QFT)</a>, where <span class="math notranslate nohighlight">\(S_0\)</span> is the zero reflection and <span class="math notranslate nohighlight">\(S_{\Psi_0}\)</span> is the phase oracle in the Grover operator. For further details on the algorithm, please refer to <a class="reference external" href="https://arxiv.org/abs/quant-ph/0005055">Quantum Amplitude Amplification and Estimation. Brassard et al., 2000</a>.</p>
<p>It can be showed that, with high probability <span class="math notranslate nohighlight">\((8/\pi^2 \approx 81\%)\)</span>, the estimate <span class="math notranslate nohighlight">\(\tilde{a}_M\)</span> provided by the QAE satisfies</p>
<div class="math notranslate nohighlight">
\[
|a - \tilde{a}_M| \leq \frac{2\pi\sqrt{a(1-a)}}{M} + \frac{\pi^2}{M^2} \sim \mathcal{O}\Bigl( \frac{1}{M} \Bigr)
\]</div>
<p>where <span class="math notranslate nohighlight">\(M=2^m\)</span>, and <span class="math notranslate nohighlight">\(m\)</span> is the number of ancilla qubits used by the algorithm (which determines how many repetitions of the operator <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> should be applied). Comparing this to classical Monte Carlo and we can see that QAE provides a (theoretical) quadratic speedup.</p>
<hr class="docutils" />
<p>Quantum Amplitude Estimation can be applied to our circuit that we performed classical Monte Carlo on, and doing QAE should theoretically improve our estimation on the fair price of the European call option.</p>
<p>So lets apply QAE and see if we get a better result than classical Monte Carlo! 🚀🚀</p>
<section id="id6">
<h4>📝 Exercise<a class="headerlink" href="#id6" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Pick <span class="math notranslate nohighlight">\(m\)</span>, i.e., the number of repetitions of <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>.</p>
<ul class="simple">
<li><p>How is the depth of the circuit impacted by the choice of <span class="math notranslate nohighlight">\(m\)</span>?</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define QAE circuit</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">AncillaRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">QFT</span><span class="p">,</span> <span class="n">GroverOperator</span>
<span class="k">class</span> <span class="nc">AECircuit</span><span class="p">(</span><span class="n">QuantumCircuit</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_preparation_circuit</span><span class="p">,</span> <span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">objective_qubit</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_preparation_circuit</span> <span class="o">=</span> <span class="n">state_preparation_circuit</span> <span class="c1"># The cirtuit implementing operator A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span> <span class="o">=</span> <span class="n">num_ancilla_qubits</span> <span class="c1"># Number of ancilla qubits (m in IQAE paper)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_state_qubits</span> <span class="o">=</span> <span class="n">state_preparation_circuit</span><span class="o">.</span><span class="n">num_qubits</span> <span class="c1"># Number of qubits in circuit A (n+1 in the IQAE paper)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_qubit</span> <span class="o">=</span> <span class="n">objective_qubit</span> <span class="c1"># Index of the objective qubit within the circuit A (0&lt;=objective_qubit&lt;=num_state_qubits) </span>
   
        <span class="c1"># Initialize circuit </span>
        <span class="n">ancilla_register</span> <span class="o">=</span> <span class="n">AncillaRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ancilla&quot;</span><span class="p">)</span>
        <span class="n">state_register</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_state_qubits</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;state&quot;</span><span class="p">)</span>
        <span class="n">classical_register</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;creg&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">ancilla_register</span><span class="p">,</span>
            <span class="n">state_register</span><span class="p">,</span>
            <span class="n">classical_register</span>
        <span class="p">)</span>
        
        <span class="c1"># Hadamard gates on the ancilla qubits</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">ancilla_register</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            
        <span class="c1"># Circuit A on the state and objective qubits</span>
        <span class="n">A_gate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_preparation_circuit</span><span class="o">.</span><span class="n">to_gate</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;$A$&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_gate</span><span class="p">,</span> <span class="n">state_register</span><span class="p">[:])</span>
       
        <span class="bp">self</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        
        <span class="c1"># Powers of Q</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groverOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_preparation_circuit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_qubit</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ancilla_qubits</span><span class="p">):</span>
            <span class="n">Qj</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">to_gate</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;$Q^</span><span class="se">{{</span><span class="si">{</span><span class="mi">2</span><span class="o">**</span><span class="n">j</span><span class="si">}</span><span class="se">}}</span><span class="s2">$&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Controlled version of Q^{2j}</span>
            <span class="c1"># Apply the controlled Q^{2j} gate on state and objective qubits, controlled by the j-th ancilla qubit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qj</span><span class="p">,</span> <span class="p">[</span><span class="n">ancilla_register</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">state_register</span><span class="p">[:])</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
       
        <span class="c1"># Inverse QFT</span>
        <span class="n">QFT_gate</span> <span class="o">=</span> <span class="n">QFT</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancilla_qubits</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_swaps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">to_gate</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;$QFT^\dagger$&quot;</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">QFT_gate</span><span class="p">,</span> <span class="n">ancilla_register</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        
        <span class="c1"># Measure the ancilla qubits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">ancilla_register</span><span class="p">,</span> <span class="n">classical_register</span><span class="p">)</span>
       
    <span class="k">def</span> <span class="nf">groverOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_preparation_circuit</span><span class="p">,</span> <span class="n">objective_qubit</span><span class="p">):</span>
        <span class="c1"># construct the grover operator</span>
        <span class="n">oracle</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">state_preparation_circuit</span><span class="o">.</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="n">state_preparation_circuit</span><span class="o">.</span><span class="n">num_ancillas</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">oracle</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">objective_qubit</span><span class="p">)</span>
        <span class="n">oracle</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">objective_qubit</span><span class="p">)</span>
        <span class="n">oracle</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">objective_qubit</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">GroverOperator</span><span class="p">(</span><span class="n">oracle</span><span class="p">,</span> <span class="n">state_preparation_circuit</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">Q</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># The number of Q repetitions (number of ancilla qubits)</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">m</span>
<span class="n">n_ancilla_qubits</span> <span class="o">=</span> <span class="n">m</span>
<span class="n">qae</span> <span class="o">=</span> <span class="n">AECircuit</span><span class="p">(</span>
    <span class="n">state_preparation_circuit</span><span class="o">=</span><span class="n">decomposed_european_call</span><span class="p">,</span>
    <span class="n">num_ancilla_qubits</span><span class="o">=</span><span class="n">n_ancilla_qubits</span><span class="p">,</span>
    <span class="n">objective_qubit</span><span class="o">=</span><span class="n">n_uncertainty_qubits</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">decomposed_qae</span> <span class="o">=</span> <span class="n">qae</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Depth of the full QAE circuit: </span><span class="si">{</span><span class="n">decomposed_qae</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">decomposed_qae</span><span class="o">.</span><span class="n">num_qubits</span><span class="si">}</span><span class="s2"> qubits) (</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2"> ancilla qubits)&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qae</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Recall from the lecture that quantum amplitude estimation uses a combination of phase estimation and amplitude amplification in order to get an estimate of <span class="math notranslate nohighlight">\(\mu\)</span>, specifically, because of the inverse QFT, what we are measuring from the quantum circuit is a number <span class="math notranslate nohighlight">\(\tilde{q} \in \{0, 1, \dots, 2^m - 1\}\)</span> that we have to map to the actual estimate through</p>
<div class="math notranslate nohighlight">
\[
\tilde{\mu} = \sin^2\Bigl( \frac{\pi \tilde{q}}{2^m} \Bigr).
\]</div>
<p>Now you should run the QAE circuit that was constructed above. <strong>Note that in a world with perfect quantum computers, with no errors, we would only have to run this circuit once.</strong></p>
<p>However, we do not (yet?) live in such a world, and thus we have to sample <span class="math notranslate nohighlight">\(\tilde{q}\)</span> multiple times.</p>
</section>
<section id="id7">
<h4>📝 Exercise<a class="headerlink" href="#id7" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Define how many times you want to sample/measure from the QAE circuit.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">()</span>
<span class="n">n_shots</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># how many samples do you want to take for the estimation?</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">qae</span><span class="p">],</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id8">
<h4>📝 Exercise<a class="headerlink" href="#id8" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Calculate the angles based on the measured values <span class="math notranslate nohighlight">\(\tilde{q}\)</span>:</p>
<ul class="simple">
<li><p>Hint: the formula for the angle is <span class="math notranslate nohighlight">\(\frac{\pi \tilde{q}}{2^m}\)</span></p></li>
</ul>
</li>
<li><p>Calculate the estimates based on the angles:</p>
<ul class="simple">
<li><p>Hint: the formula for the estimate is <span class="math notranslate nohighlight">\(\tilde{\mu} = \sin^2\Bigl( \frac{\pi \tilde{q}}{2^m} \Bigr)\)</span></p></li>
<li><p>Optional: round it to a suitable number of decimals (e.g. 15)</p></li>
</ul>
</li>
<li><p>Determine which estimate has the highest probability and then post-process it.</p>
<ul class="simple">
<li><p>Hint: you can use the <code class="docutils literal notranslate"><span class="pre">np.argmax</span></code> method to get the index with the largest value.</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># QAE Post-processing</span>
<span class="c1">#</span>

<span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">creg</span><span class="o">.</span><span class="n">get_int_counts</span><span class="p">()</span>
<span class="n">qq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

<span class="n">theta_estimates</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># Calculate the angles</span>
<span class="n">estimates</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># Calculate the estimates</span>

<span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="n">probabilities</span> <span class="o">/</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="c1"># Combine any estimate or probability duplicates (because sin is periodic)</span>
<span class="n">unique_estimates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">estimates</span><span class="p">))</span>
<span class="n">unique_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">[</span><span class="n">estimates</span><span class="o">==</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">unique_estimates</span><span class="p">]</span>
<span class="n">qae_estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_estimates</span><span class="p">)</span>
<span class="n">qae_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_probabilities</span><span class="p">)</span>

<span class="n">qae_p_mode</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># Extract the estimate with the highest probability</span>
<span class="n">qae_expectation</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">qae_p_mode</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;                   Exact            MC             QAE&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">70</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expectation:      </span><span class="si">{</span><span class="n">exact_value</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">        </span><span class="si">{</span><span class="n">mc_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">         </span><span class="si">{</span><span class="n">qae_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Diff  (abs):        N/A          </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exact_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mc_expectation</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">         </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exact_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">qae_expectation</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Diff    (%):        N/A          </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exact_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mc_expectation</span><span class="p">)</span><span class="o">/</span><span class="n">mc_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">         </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exact_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">qae_expectation</span><span class="p">)</span><span class="o">/</span><span class="n">qae_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="what-if-we-wanted-to-run-this-qmc-circuit-on-a-specific-backend">
<h4>What if we wanted to run this QMC circuit on a specific backend?<a class="headerlink" href="#what-if-we-wanted-to-run-this-qmc-circuit-on-a-specific-backend" title="Link to this heading"></a></h4>
<p>If you for example wanted to run this circuit on the Helmi QC then you would have to transpile the circuit to be compatible with the native gate set of the target backend.</p>
<p>Qiskit has a method for (attempting) translating (<a class="reference external" href="https://docs.quantum.ibm.com/api/qiskit/transpiler">transpiling</a>) your circuit with your gates to the target gate set, this method is called <a class="reference external" href="https://docs.quantum.ibm.com/api/qiskit/compiler#qiskit.compiler.transpile">transpile</a> and composes 6 different stages (each of which can be read about in detail on the provided link).</p>
<p>The 5th stage in the transpilation process is called <a class="reference external" href="https://docs.quantum.ibm.com/api/qiskit/transpiler#optimization-stage">optimization</a> and can be controlled by the user by specifying what optimization level you want to have. The optimization stage is necessary in order to manage increased circuit depths due to the transpilation process potentially adding a lot of gates in order to both: map the source gates to the target gate set, but also to match the target hardware qubit topology. We have discussed circuit depth quite a bit in this tutorial, and one way to (potentially) cope with extremely deep circuits is through transpilation optimization.</p>
<p>The user can specify what optimization level they want to run with:</p>
<ol class="arabic simple" start="0">
<li><p>no optimization</p></li>
<li><p>light optimization</p></li>
<li><p>heavy optimization</p></li>
<li><p>even heavier optimization</p></li>
</ol>
<p>and the default level is 2. The higher the optimization level, the more optimized circuits, at the expense of longer transpilation times. <strong>Important to note is that the transpilation process is stochastic and will thus generate circuits with e.g. varying depth and gate layout even for the same source circuit.</strong></p>
</section>
<section id="id9">
<h4>📝 Exercise<a class="headerlink" href="#id9" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Decide on a set of native gates that you want to have as target for the transpilation process.</p>
<ul class="simple">
<li><p>If you have the time, you could try and find the specifications of a real QPU and its native gate set and use that. Here is a <a class="reference external" href="https://docs.quantum.ibm.com/guides/native-gates">link</a> for the IBM QPUs.</p></li>
</ul>
</li>
<li><p>Set your desired optimization level and see how the depth of the circuit changes as you change the optimization level.</p>
<ul class="simple">
<li><p>How many gates can you remove from the original (extremely deep) QAE circuit by optimizing it?</p></li>
</ul>
</li>
<li><p>Can you find a gate set that you can’t transpile the circuit to? Why do you think that is?</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="n">backend_native_gates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># the native gates of the target backend</span>
<span class="n">optimization_level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># your desired optimization level [0, 3]</span>

<span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span>
    <span class="n">circuits</span><span class="o">=</span><span class="n">qae</span><span class="p">,</span>
    <span class="n">basis_gates</span><span class="o">=</span><span class="n">backend_native_gates</span><span class="p">,</span>
    <span class="n">optimization_level</span><span class="o">=</span><span class="n">optimization_level</span><span class="p">,</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="o">.</span><span class="n">depth</span><span class="p">())</span>

<span class="c1"># You can most likely not display this circuit since the transpilation process</span>
<span class="c1"># decomposes any grouped gates, meaning, it will try and draw ~100_000 gates...</span>
<span class="c1"># display(transpiled_circuit.draw(&quot;mpl&quot;))</span>
</pre></div>
</div>
</div>
</div>
<p>That’s all we had prepared for you today, well done! 🎉💫🌟</p>
<p>Hopefully you had the time to get a better understanding of how quantum amplitude estimation can be used in finance for pricing options, and also that you had the time to reflect on the suitability of these algorithms in the NISQ era.</p>
</section>
</section>
<hr class="docutils" />
<section id="code-solutions">
<h3>Code solutions<a class="headerlink" href="#code-solutions" title="Link to this heading"></a></h3>
<p>If you are stuck on a problem or you want to compare your code to our code, look here. 😎</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># Log-normal distribution (classically)</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

<span class="n">n_uncertainty_qubits</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">n_qubit_states</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_uncertainty_qubits</span>

<span class="n">S</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># initial spot price</span>
<span class="n">volatility</span> <span class="o">=</span> <span class="mf">0.4</span>  <span class="c1"># implied volatility</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># risk-free market rate</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">/</span> <span class="mi">365</span>  <span class="c1"># time to maturity</span>

<span class="n">mu</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">volatility</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">T</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="n">volatility</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

<span class="c1"># Some properties of the log-normal distribution</span>
<span class="c1"># https://en.wikipedia.org/wiki/Log-normal_distribution</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">variance</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>

<span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">mean</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">std_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">high</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">std_dev</span>

<span class="c1"># Scipy log-normal distribution</span>
<span class="c1"># https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.lognorm.html</span>
<span class="n">lognorm_scale</span> <span class="o">=</span> <span class="n">S</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">T</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_qubit_states</span><span class="p">)</span>
<span class="n">yy</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lognorm_scale</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span>
<span class="n">yy</span> <span class="o">=</span> <span class="n">yy</span> <span class="o">/</span> <span class="n">yy</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.05</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">,</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$ln \frac</span><span class="si">{S_T}{S_t}</span><span class="s2"> \sim N((r - \frac</span><span class="si">{1}{2}</span><span class="s2">\sigma^2)T, \sigma\sqrt</span><span class="si">{T}</span><span class="s2">)$&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Spot price at maturity $S_T$ (€)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Probability ($\%$)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># Encoding the payoff function (classically)</span>
<span class="c1">#</span>

<span class="n">K</span> <span class="o">=</span> <span class="mf">1.713</span>  <span class="c1"># this can be whatever..</span>

<span class="n">xx</span> <span class="o">=</span> <span class="n">uncertainty_model</span><span class="o">.</span><span class="n">values</span>
<span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">xx</span> <span class="o">-</span> <span class="n">K</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Payoff function $\phi(S_T) = \max(S_T - K, 0)$&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Spot price at maturity $S_T$ (€)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Payoff amount (€)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.05</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">,</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># Encoding the payoff function (QC)</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">LinearAmplitudeFunction</span>

<span class="c1"># approximation scaling for the payoff function, determines accuracy in the Taylor approximation.</span>
<span class="c1"># https://www.nature.com/articles/s41534-019-0130-6</span>
<span class="n">c_approx</span> <span class="o">=</span> <span class="mf">0.25</span>

<span class="n">breakpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
<span class="n">slopes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">offsets</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">f_min</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">f_max</span> <span class="o">=</span> <span class="n">high</span> <span class="o">-</span> <span class="n">K</span>
<span class="n">european_call_objective</span> <span class="o">=</span> <span class="n">LinearAmplitudeFunction</span><span class="p">(</span>
    <span class="n">num_state_qubits</span><span class="o">=</span><span class="n">n_uncertainty_qubits</span><span class="p">,</span>
    <span class="n">slope</span><span class="o">=</span><span class="n">slopes</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
    <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">),</span>
    <span class="n">image</span><span class="o">=</span><span class="p">(</span><span class="n">f_min</span><span class="p">,</span> <span class="n">f_max</span><span class="p">),</span>
    <span class="n">breakpoints</span><span class="o">=</span><span class="n">breakpoints</span><span class="p">,</span>
    <span class="n">rescaling_factor</span><span class="o">=</span><span class="n">c_approx</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">decomposed_european_call_objective</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">reps</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Depth of the f(x) circuit: </span><span class="si">{</span><span class="n">decomposed_european_call_objective</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">n_uncertainty_qubits</span><span class="si">}</span><span class="s2"> qubits)&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">decomposed_european_call_objective</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># Performing classical MC on a QC</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">qiskit.primitives</span> <span class="kn">import</span> <span class="n">StatevectorSampler</span> <span class="k">as</span> <span class="n">Sampler</span>

<span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">()</span>
<span class="n">n_shots</span> <span class="o">=</span> <span class="mi">100_000</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">measured_european_call</span><span class="p">,</span> <span class="p">],</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="n">quasi_dist_dict</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">creg</span><span class="o">.</span><span class="n">get_int_counts</span><span class="p">()</span>
<span class="n">quasi_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">quasi_dist_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">quasi_dist_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">quasi_dist</span> <span class="o">/</span> <span class="n">quasi_dist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">([</span><span class="s2">&quot;|0&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;|1&gt;&quot;</span><span class="p">],</span> <span class="n">dist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Probability of measuring either $|0&gt;$ or $|1&gt;$&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Quasi-probability ($\%$)&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">p_hat</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">p_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_hat</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_hat</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_shots</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Raw estimated mu=</span><span class="si">{</span><span class="n">p_hat</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">, std=</span><span class="si">{</span><span class="n">p_std</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">expectation</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">p_hat</span><span class="p">)</span>
<span class="n">lower_conf</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">p_hat</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p_std</span><span class="p">)</span>
<span class="n">upper_conf</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">p_hat</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p_std</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimation of the expected payoff:</span><span class="se">\t\t</span><span class="si">{</span><span class="n">expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">exact_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uncertainty_model</span><span class="o">.</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">uncertainty_model</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">K</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exact expected value from discretization:</span><span class="se">\t</span><span class="si">{</span><span class="n">exact_value</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Confidence bound on estimation:</span><span class="se">\t\t</span><span class="s2">(</span><span class="si">{</span><span class="n">lower_conf</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">upper_conf</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># QAE Post-processing</span>
<span class="c1">#</span>

<span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">creg</span><span class="o">.</span><span class="n">get_int_counts</span><span class="p">()</span>
<span class="n">qq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

<span class="n">theta_estimates</span> <span class="o">=</span> <span class="n">qq</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">M</span>
<span class="n">estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_estimates</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>

<span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="n">probabilities</span> <span class="o">/</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="c1"># Combine any estimate or probability duplicates (because sin is periodic)</span>
<span class="n">unique_estimates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">estimates</span><span class="p">))</span>
<span class="n">unique_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">[</span><span class="n">estimates</span><span class="o">==</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">unique_estimates</span><span class="p">]</span>
<span class="n">qae_estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_estimates</span><span class="p">)</span>
<span class="n">qae_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_probabilities</span><span class="p">)</span>

<span class="n">qae_p_mode</span> <span class="o">=</span> <span class="n">qae_estimates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">qae_probabilities</span><span class="p">)]</span>
<span class="n">qae_expectation</span> <span class="o">=</span> <span class="n">european_call_objective</span><span class="o">.</span><span class="n">post_processing</span><span class="p">(</span><span class="n">qae_p_mode</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;                   Exact            MC             QAE&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">70</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expectation:      </span><span class="si">{</span><span class="n">exact_value</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">        </span><span class="si">{</span><span class="n">mc_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">         </span><span class="si">{</span><span class="n">qae_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Diff  (abs):        N/A          </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exact_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mc_expectation</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">         </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exact_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">qae_expectation</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Diff    (%):        N/A          </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exact_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mc_expectation</span><span class="p">)</span><span class="o">/</span><span class="n">mc_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">         </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">exact_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">qae_expectation</span><span class="p">)</span><span class="o">/</span><span class="n">qae_expectation</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># Transpiling and optimizing quantum circuits using qiskit</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="n">backend_native_gates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;ry&quot;</span><span class="p">,</span> <span class="s2">&quot;cx&quot;</span><span class="p">]</span>
<span class="n">optimization_level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span>
    <span class="n">circuits</span><span class="o">=</span><span class="n">qae</span><span class="p">,</span>
    <span class="n">basis_gates</span><span class="o">=</span><span class="n">backend_native_gates</span><span class="p">,</span>
    <span class="n">optimization_level</span><span class="o">=</span><span class="n">optimization_level</span><span class="p">,</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="o">.</span><span class="n">depth</span><span class="p">())</span>

<span class="c1"># You can most likely not display this circuit since the transpilation process</span>
<span class="c1"># decomposes any grouped gates, meaning, it will try and draw ~100_000 gates...</span>
<span class="c1"># display(transpiled_circuit.draw(&quot;mpl&quot;))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://www.nature.com/articles/s41534-019-0130-6">Quantum Risk Analysis. Woerner, Egger. 2018.</a></p></li>
<li><p><a class="reference external" href="https://quantum-journal.org/papers/q-2020-07-06-291/">Option Pricing using Quantum Computers. Stamatopoulos et al. 2019.</a></p></li>
<li><p><a class="reference external" href="https://www.chebfun.org/examples/applics/EuropeanCall.html">Pricing of a European call option. Pachon, Ricardo. 2014.</a></p></li>
</ul>
</section>
</section>
<span id="document-qsip"></span><section class="tex2jax_ignore mathjax_ignore" id="qsip-quantum-sweden-innovation-platform">
<h2>QSIP - Quantum Sweden Innovation Platform<a class="headerlink" href="#qsip-quantum-sweden-innovation-platform" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/17eb483d22c0ff5a13d127ae2a1eca59/QSIP_QAS24_20241203.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-notebooks/flight_scheduling_optimization_qaoa"></span><section class="tex2jax_ignore mathjax_ignore" id="tutorial-solving-flight-scheduling-optimization-using-qaoa">
<h2>Tutorial - Solving Flight Scheduling Optimization using QAOA<a class="headerlink" href="#tutorial-solving-flight-scheduling-optimization-using-qaoa" title="Link to this heading"></a></h2>
<p>Quantum computing has introduced a new approach for solving complex optimization problems. Notably, the <strong>Quantum Approximate Optimization Algorithm (QAOA)</strong> – a hybrid (quantum-classical) – has emerged as a promising candidate.
In this tutorial, we will see how QAOA can be applied to solve a real-world optimization problem, specifically, the tail-assignment problem – with <strong>Qiskit</strong>.</p>
<section id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Link to this heading"></a></h3>
<p>Before starting this tutorial, be sure you have the following installed:</p>
<ul class="simple">
<li><p>Qiskit SDK v1.0 or later, with visualization support ( <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">'qiskit[visualization]'</span></code> )</p></li>
<li><p>Qiskit Runtime v0.22 or later (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">qiskit-ibm-runtime</span></code>)</p></li>
<li><p>Qiskit AER v0.15.0 or later (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">qiskit-aer</span></code>)</p></li>
</ul>
</section>
<section id="the-tail-assignment-problem">
<h3>The Tail-Assignment Problem<a class="headerlink" href="#the-tail-assignment-problem" title="Link to this heading"></a></h3>
<p>The tail-assignment problem is a complex combinatorial optimization challenge arising in the airline industry, specifically in aircraft scheduling tasks. The objective is to assign a specific aircraft (identified by its tail number), also called a <em>route</em>, to a sequence of flights while:</p>
<ol class="arabic simple">
<li><p><strong>Satisfying operational constraints</strong> (e.g., maintenance schedules, turnaround times, crew availability).</p></li>
<li><p><strong>Minimizing operational costs</strong> (e.g., fuel usage, delay penalties).</p></li>
</ol>
<section id="why-is-it-hard">
<h4>Why Is It Hard?<a class="headerlink" href="#why-is-it-hard" title="Link to this heading"></a></h4>
<p>The tail-assignment problem is classified as <strong>NP-hard</strong>. This means that as the number of flights and aircraft increases, finding an optimal solution becomes computationally infeasible for traditional algorithms due to exponential growth in complexity. A common classical approach to this problem is <strong>column generation</strong>, which breaks the problem into smaller subproblems to make it manageable.</p>
</section>
<section id="mathematical-formulation">
<h4>Mathematical Formulation<a class="headerlink" href="#mathematical-formulation" title="Link to this heading"></a></h4>
<p>The tail-assignment problem can be formulated as the following integer linear program:</p>
<div class="amsmath math notranslate nohighlight" id="equation-0ae12518-d9a8-4756-842a-8191ba7721a4">
<span class="eqno">(1)<a class="headerlink" href="#equation-0ae12518-d9a8-4756-842a-8191ba7721a4" title="Permalink to this equation"></a></span>\[\begin{equation}
    \min\sum_{r\in R}c_rx_r,
\end{equation}\]</div>
<p>Such that</p>
<div class="amsmath math notranslate nohighlight" id="equation-9cfd3a79-24bc-4baa-a1af-4ea31f24b6a6">
<span class="eqno">(2)<a class="headerlink" href="#equation-9cfd3a79-24bc-4baa-a1af-4ea31f24b6a6" title="Permalink to this equation"></a></span>\[\begin{align}
    \sum_{r\in R}A_{fr}x_r =1,\quad &amp;\forall f\in F,\\
    x_r\in\{0,1\},\quad &amp;\forall r\in R,
\end{align}\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(R\)</span>: The set of all possible routes (sequences of flights assigned to an aircraft).</p></li>
<li><p><span class="math notranslate nohighlight">\(c_r\)</span>: The cost associated with route <span class="math notranslate nohighlight">\(r\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(F\)</span>: The set of all activities (e.g., individual flights or sequences of flights).</p></li>
<li><p><span class="math notranslate nohighlight">\(A_{fr}\)</span>: A binary indicator; <span class="math notranslate nohighlight">\(A_{fr} = 1\)</span> if activity <span class="math notranslate nohighlight">\(f\)</span> is part of route <span class="math notranslate nohighlight">\(r\)</span>, and <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p></li>
<li><p><span class="math notranslate nohighlight">\(x_r\)</span>: A binary decision variable; <span class="math notranslate nohighlight">\(x_r = 1\)</span> if route <span class="math notranslate nohighlight">\(r\)</span> is chosen in the solution, and <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p></li>
</ul>
</section>
<section id="simplified-problem-for-this-tutorial">
<h4>Simplified Problem for This Tutorial<a class="headerlink" href="#simplified-problem-for-this-tutorial" title="Link to this heading"></a></h4>
<p>For this tutorial, we focus on a simplified version of the problem where:</p>
<ol class="arabic simple">
<li><p><strong>Only one feasible solution exists per instance.</strong> This eliminates the need to minimize costs (<span class="math notranslate nohighlight">\(c_r\)</span>) since it becomes irrelevant when there is a unique solution.</p></li>
<li><p>The problem reduces to solving the constraints:
\begin{equation}
\sum_{r\in R}A_{fr}x_r =1,\quad \forall f\in F,
\end{equation}
which can be expressed compactly in matrix form as:
\begin{equation}
A\vec{x}=\vec{1}
\end{equation}</p></li>
</ol>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span>: The constraint matrix.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{x}\)</span>: A vector of binary decision variables.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{1}\)</span>: A vector of ones (length equal to the number of flights).</p></li>
</ul>
</section>
<section id="connection-to-the-exact-cover-problem">
<h4>Connection to the Exact Cover Problem<a class="headerlink" href="#connection-to-the-exact-cover-problem" title="Link to this heading"></a></h4>
<p>This simplified tail-assignment problem is equivalent to the well-known <a class="reference external" href="https://en.wikipedia.org/wiki/Exact_cover">Exact Cover problem</a>. In Exact Cover, the goal is to select a subset of sets such that every element in the universal set is covered exactly once.</p>
<p><strong>Visual Example:</strong></p>
<div align="center">
    <img src="https://raw.githubusercontent.com/Wikstahl/autumn-school-qas2024/refs/heads/main/images/exact_cover.jpg" width="500">
</div>
<p><strong>Figure Caption:</strong> The Exact Cover problem requires selecting a subset of vertices from <span class="math notranslate nohighlight">\(R\)</span> such that exactly one edge connects each vertex in <span class="math notranslate nohighlight">\(F\)</span>. In the example above, the subset <span class="math notranslate nohighlight">\(\{r_1, r_4\}\)</span> forms an exact cover.</p>
</section>
<section id="what-you-ll-learn-in-this-tutorial">
<h4>What You’ll Learn in This Tutorial<a class="headerlink" href="#what-you-ll-learn-in-this-tutorial" title="Link to this heading"></a></h4>
<p>In this tutorial, we will use the <strong>Quantum Approximate Optimization Algorithm (QAOA)</strong> to solve the simplified tail-assignment problem. We’ll explore:</p>
<ol class="arabic simple">
<li><p>How to represent the problem as a quadratic unconstrained binary optimization (QUBO) problem.</p></li>
<li><p>Mapping the problem to a quantum Hamiltonian.</p></li>
<li><p>Solving the problem step-by-step using QAOA.</p></li>
</ol>
</section>
<section id="loading-a-problem-instance">
<h4>Loading a problem instance<a class="headerlink" href="#loading-a-problem-instance" title="Link to this heading"></a></h4>
<p>To begin solving the tail-assignment problem, we need a specific problem instance. In this tutorial, the problem is represented as a constraint matrix <span class="math notranslate nohighlight">\(A\)</span>, where:</p>
<ul class="simple">
<li><p>Each row corresponds to a flight or activity.</p></li>
<li><p>Each column represents a potential route.</p></li>
<li><p>The entry <span class="math notranslate nohighlight">\(A_{fr}\)</span> is <span class="math notranslate nohighlight">\(1\)</span> if flight <span class="math notranslate nohighlight">\(f\)</span> is included in route <span class="math notranslate nohighlight">\(r\)</span>, and <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p></li>
</ul>
<p>By loading the matrix <span class="math notranslate nohighlight">\(A\)</span>, we define the structure of the problem and the constraints that must be satisfied. This matrix serves as the foundation for constructing the optimization model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://raw.githubusercontent.com/Wikstahl/autumn-school-qas2024/refs/heads/main/data/&quot;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;instance_8.csv&quot;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="c1"># load problem data</span>
<span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of flights equals </span><span class="si">{</span><span class="n">num_rows</span><span class="si">}</span><span class="s2">, and number of routes equals </span><span class="si">{</span><span class="n">num_cols</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of flights equals 77, and number of routes equals 8.
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="step-1-map-the-optimization-problem-to-a-hamiltonian">
<h3>Step 1: Map the Optimization Problem to a Hamiltonian<a class="headerlink" href="#step-1-map-the-optimization-problem-to-a-hamiltonian" title="Link to this heading"></a></h3>
<p>The first step in solving the problem with QAOA is to map the classical optimization problem into quantum circuits and operators. This involves three main steps:</p>
<ol class="arabic simple">
<li><p><strong>Reformulate the problem using QUBO notation:</strong>
Transform the problem into the form of a <strong>Quadratic Unconstrained Binary Optimization (QUBO)</strong>. This step reformulates the the problem as a cost function that then makes it easy to map it to a Hamiltonian.</p></li>
<li><p><strong>Express the problem as a Hamiltonian:</strong><br />
Represent the QUBO problem as a Hamiltonian. The goal is to construct a Hamiltonian where the ground state (the lowest energy state) corresponds to the optimal solution of the classical problem.</p></li>
<li><p><strong>Design a quantum circuit:</strong> Create a parameterized quantum circuit that creates quantum states representing candidate solutions to the problem. The parameters of this circuit are iteratively adjusted to find states that minimize the Hamiltonian.</p></li>
</ol>
<p>By sampling from the quantum states produced by the parametrized quantum circuit (Ansatz), you can evaluate candidate solutions using the cost function encoded in the Hamiltonian.</p>
<p><strong>Note:</strong> The process combines quantum and classical computation, as the quantum circuit proposes solutions, and a classical optimizer adjusts the circuit’s parameters based on feedback from the cost evaluation.</p>
<section id="map-optimization-problem-to-qubo-form">
<h4>Map Optimization Problem to QUBO Form<a class="headerlink" href="#map-optimization-problem-to-qubo-form" title="Link to this heading"></a></h4>
<p>The first step in mapping the tail-assignment problem is to express it in <strong>Quadratic Unconstrained Binary Optimization (QUBO)</strong> form. This involves a notation change, where the optimization problem is represented as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-c5309755-0514-42c1-8aa4-fa96159616f1">
<span class="eqno">(3)<a class="headerlink" href="#equation-c5309755-0514-42c1-8aa4-fa96159616f1" title="Permalink to this equation"></a></span>\[\begin{equation}
    f(\vec{x}) = \min_{\vec{x} \in \{0, 1\}^n} \vec{x}^T Q \vec{x},
\end{equation}\]</div>
<p>Here:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f(x)\)</span> is the <strong>cost function</strong> we aim to minimize.</p></li>
<li><p><span class="math notranslate nohighlight">\(Q\)</span> is an <span class="math notranslate nohighlight">\(n \times n\)</span> matrix of real numbers.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span> corresponds to the number of routes.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{x}\)</span> is the vector of binary decision variables introduced earlier.</p></li>
<li><p><span class="math notranslate nohighlight">\(\vec{x}^T\)</span> is the transpose of <span class="math notranslate nohighlight">\(\vec{x}\)</span>.</p></li>
</ul>
<p>Our next task is to map the tail-assignment problem into QUBO form.</p>
<section id="step-1-1-transforming-constraints-into-a-cost-function">
<h5>Step 1.1: Transforming Constraints into a Cost Function<a class="headerlink" href="#step-1-1-transforming-constraints-into-a-cost-function" title="Link to this heading"></a></h5>
<p>The tail-assignment problem is defined by the constraint <span class="math notranslate nohighlight">\(A\vec{x} = \vec{1}\)</span>. To transform this into a QUBO cost function, we subtract <span class="math notranslate nohighlight">\(\vec{1}\)</span> from the right-hand side and square (via inner product) the expression:</p>
<div class="amsmath math notranslate nohighlight" id="equation-ecd1acf4-1772-4419-9b6d-fa0692360bfc">
<span class="eqno">(4)<a class="headerlink" href="#equation-ecd1acf4-1772-4419-9b6d-fa0692360bfc" title="Permalink to this equation"></a></span>\[\begin{equation}
    (A\vec{x} - \vec{1})^2 = 0
\end{equation}\]</div>
<p>This ensures that the cost function evaluates to zero if and only if there exists a binary vector <span class="math notranslate nohighlight">\(\vec{x}\)</span> that satisfy the equation. Thus, the problem can now be expressed as</p>
<div class="amsmath math notranslate nohighlight" id="equation-51c27772-64ef-420a-9232-ba493e06cd58">
<span class="eqno">(5)<a class="headerlink" href="#equation-51c27772-64ef-420a-9232-ba493e06cd58" title="Permalink to this equation"></a></span>\[\begin{equation}
    f(\vec{x}) = \min_{\vec{x} \in \{0, 1\}^n} (A\vec{x} - \vec{1})^2
\end{equation}\]</div>
<p>Next we expanding the square of the cost function. Doing this we get:</p>
<div class="amsmath math notranslate nohighlight" id="equation-5462960c-0e68-46cf-a058-6ae49e2b6310">
<span class="eqno">(6)<a class="headerlink" href="#equation-5462960c-0e68-46cf-a058-6ae49e2b6310" title="Permalink to this equation"></a></span>\[\begin{equation}
    (A\vec{x} - \vec{1})^2 = \vec{x}^T A^T A \vec{x} - 2 \vec{1}^T \vec{x} A + \vec{1}^T \vec{1}
\end{equation}\]</div>
<p>Since <span class="math notranslate nohighlight">\(\vec{1}^T \vec{1}\)</span> is a constant scalar, it does not affect the optimization and can be ignored. This leaves us with two terms:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\vec{x}^T A^T A \vec{x}\)</span>: This term is already in the desired QUBO form.</p></li>
<li><p><span class="math notranslate nohighlight">\(-2 \vec{1}^T \vec{x} A\)</span>: This is a linear term, which will contribute to the diagonal of the <span class="math notranslate nohighlight">\(Q\)</span>-matrix.</p></li>
</ul>
<p>To incorporate the linear term into the <span class="math notranslate nohighlight">\(Q\)</span>-matrix, we note that:</p>
<div class="amsmath math notranslate nohighlight" id="equation-431dd9ea-1020-4fca-bbec-9bceb70e6e2f">
<span class="eqno">(7)<a class="headerlink" href="#equation-431dd9ea-1020-4fca-bbec-9bceb70e6e2f" title="Permalink to this equation"></a></span>\[\begin{equation}
    \vec{x}^T Q \vec{x} = \sum_{i,j} Q_{ij} x_i x_j = \sum_{i=j} Q_{ii} x_i + \sum_{i \neq j} Q_{ij} x_i x_j,
\end{equation}\]</div>
<p>where diagonal term is simpy <span class="math notranslate nohighlight">\(\sum_{i} Q_{ii} x_i\)</span>, since <span class="math notranslate nohighlight">\(x_ix_i=x_i\)</span>.</p>
<p>Thus, the linear term <span class="math notranslate nohighlight">\(-2 \vec{x}^T A^T \vec{1}\)</span> contributes to the diagonal elements of <span class="math notranslate nohighlight">\(Q\)</span>. Specifically:</p>
<div class="amsmath math notranslate nohighlight" id="equation-380c6c0d-6002-4192-ae2e-e3d140bf91a1">
<span class="eqno">(8)<a class="headerlink" href="#equation-380c6c0d-6002-4192-ae2e-e3d140bf91a1" title="Permalink to this equation"></a></span>\[\begin{equation}
    -2 \vec{x}^T A^T \vec{1} = -2 \sum_{i,j} x_j A_{ji} 
\end{equation}\]</div>
<p>This can be written as:</p>
<div class="amsmath math notranslate nohighlight" id="equation-5edf1b62-db9e-4d7a-bce0-ea60a6d628a9">
<span class="eqno">(9)<a class="headerlink" href="#equation-5edf1b62-db9e-4d7a-bce0-ea60a6d628a9" title="Permalink to this equation"></a></span>\[\begin{equation}
    -2 \vec{x}^T \mathrm{diag}(A^T\vec{1}) \vec{x},
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathrm{diag}(A^T\vec{1})\)</span> is a diagonal matrix with diagonal elements:</p>
<div class="amsmath math notranslate nohighlight" id="equation-a2ae0918-29b1-452b-b4ba-04c049c41b62">
<span class="eqno">(10)<a class="headerlink" href="#equation-a2ae0918-29b1-452b-b4ba-04c049c41b62" title="Permalink to this equation"></a></span>\[\begin{equation}
    \mathrm{diag}(A^T\vec{1})_j = \sum_{i} A_{ji}.
\end{equation}\]</div>
</section>
<section id="step-1-3-constructing-the-q-matrix">
<h5>Step 1.3: Constructing the <span class="math notranslate nohighlight">\(Q\)</span>-Matrix<a class="headerlink" href="#step-1-3-constructing-the-q-matrix" title="Link to this heading"></a></h5>
<p>Combining these results, the <span class="math notranslate nohighlight">\(Q\)</span>-matrix is given by:</p>
<div class="amsmath math notranslate nohighlight" id="equation-91a9a563-823e-45ec-a6a7-a4ccbd55da8d">
<span class="eqno">(11)<a class="headerlink" href="#equation-91a9a563-823e-45ec-a6a7-a4ccbd55da8d" title="Permalink to this equation"></a></span>\[\begin{equation}
Q = A^T A - 2 \mathrm{diag}(A^T\vec{1}).
\end{equation}\]</div>
<p>This <span class="math notranslate nohighlight">\(Q\)</span>-matrix now fully represents the QUBO form of the tail-assignment problem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">QUBO</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">num_rows</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">id_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_rows</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># create column vector with ones</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="nd">@A</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="nd">@id_vec</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">Q</span>
    
<span class="n">Q</span> <span class="o">=</span> <span class="n">QUBO</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[-17.   2.   0.   0.   0.   3.   5.   3.]
 [  2. -18.   3.   9.   4.   3.   5.   2.]
 [  0.   3. -20.   0.   0.   3.   5.   0.]
 [  0.   9.   0. -19.   0.   6.   7.   5.]
 [  0.   4.   0.   0. -21.   6.   2.  12.]
 [  3.   3.   3.   6.   6. -18.   3.   4.]
 [  5.   5.   5.   7.   2.   3. -19.   1.]
 [  3.   2.   0.   5.  12.   4.   1. -20.]]
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="step-2-reformulate-qubo-to-hamiltonian">
<h4>Step 2: Reformulate QUBO to Hamiltonian<a class="headerlink" href="#step-2-reformulate-qubo-to-hamiltonian" title="Link to this heading"></a></h4>
<p>You can reformulate the QUBO problem as a <strong>Hamiltonian</strong> (here, a matrix that respresents the energy of a system):</p>
<div class="math notranslate nohighlight">
\[
H_C = \sum_{ij} Q_{ij} Z_i Z_j + \sum_i b_i Z_i.
\]</div>
<blockquote>
<div><p><strong>Reformulation steps from the QAOA problem to the Hamiltonian</strong></p>
<p>To demonstrate how the QAOA problem can be rewritten in this way, first replace the binary variables <span class="math notranslate nohighlight">\(x_i\)</span> to a new set of variables <span class="math notranslate nohighlight">\(z_i\in\{-1, 1\}\)</span> via</p>
<div class="math notranslate nohighlight">
\[ x_i = \frac{1-z_i}{2}. \]</div>
<p>Here you can see that if <span class="math notranslate nohighlight">\(x_i\)</span> is <span class="math notranslate nohighlight">\(0\)</span>, then <span class="math notranslate nohighlight">\(z_i\)</span> must be <span class="math notranslate nohighlight">\(1\)</span>. When the <span class="math notranslate nohighlight">\(x_i\)</span>’s are substituted for the <span class="math notranslate nohighlight">\(z_i\)</span>’s in the optimization problem (<span class="math notranslate nohighlight">\(x^TQx\)</span>), an equivalent formulation can be obtained.</p>
<div class="math notranslate nohighlight">
\[\begin{split} x^TQx=\sum_{ij}Q_{ij}x_ix_j \\ =\frac{1}{4}\sum_{i,j}Q_{ij}(1-z_i)(1-z_j) \\=\frac{1}{4}\sum_{i,j}Q_{ij}z_iz_j-\frac{1}{4}\sum_{i,j}(Q_{ij}+Q_{ji})z_i + \frac{1}{4}\sum_{ij}Q_{ij}. \end{split}\]</div>
<p>Now if we define <span class="math notranslate nohighlight">\(b_i=-\sum_{j}(Q_{ij}+Q_{ji})\)</span>, remove the constant <span class="math notranslate nohighlight">\(1/4\sum_{ij}Q_{ij}\)</span> term, we arrive at the two equivalent formulations of the same optimization problem.</p>
<div class="math notranslate nohighlight">
\[ \min_{x\in\{0,1\}^n} x^TQx\Longleftrightarrow \min_{z\in\{-1,1\}^n} \frac{1}{4}z^TQz + \frac{1}{4}b^Tz \]</div>
<p>Here, <span class="math notranslate nohighlight">\(b\)</span> depends on <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Now, to obtain a quantum formulation of the problem, promote the <span class="math notranslate nohighlight">\(z_i\)</span> variables to a Pauli <span class="math notranslate nohighlight">\(Z\)</span> matrix, such as a <span class="math notranslate nohighlight">\(2\times 2\)</span> matrix of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split} Z_i = \begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1\end{pmatrix}. \end{split}\]</div>
<p>When you substitute these matrices in the optimization problem above, you obtain the following Hamiltonian</p>
<div class="math notranslate nohighlight">
\[ H_C=\frac{1}{4}\sum_{ij}Q_{ij}Z_iZ_j + \frac{1}{4}\sum_i b_iZ_i. \]</div>
<p><em>Also recall that the <span class="math notranslate nohighlight">\(Z\)</span> matrices are embedded in the quantum computer’s computational space, i.e., a Hilbert space of size <span class="math notranslate nohighlight">\(2^n\times 2^n\)</span>. Therefore, you should understand terms such as <span class="math notranslate nohighlight">\(Z_iZ_j\)</span> as the tensor product <span class="math notranslate nohighlight">\(Z_i\otimes Z_j\)</span> embedded in the <span class="math notranslate nohighlight">\(2^n\times 2^n\)</span> Hilbert space. For example, in a problem with five decision variables the term <span class="math notranslate nohighlight">\(Z_1Z_3\)</span> is understood to mean <span class="math notranslate nohighlight">\(I\otimes Z_3\otimes I\otimes Z_1\otimes I\)</span> where <span class="math notranslate nohighlight">\(I\)</span> is the <span class="math notranslate nohighlight">\(2\times 2\)</span> identity matrix.</em></p>
</div></blockquote>
<p>This Hamiltonian is called the <b>cost function Hamiltonian</b>. It has the property that its ground state corresponds to the solution that <b>minimizes the cost function <span class="math notranslate nohighlight">\(f(x)\)</span></b>.
Therefore, to solve your optimization problem you now need to prepare the ground state of <span class="math notranslate nohighlight">\(H_C\)</span> (or a state with a high overlap with it) on the quantum computer. Then, sampling from this state will, with a high probability, yield the solution to <span class="math notranslate nohighlight">\(min~f(x)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">SparsePauliOp</span>

<span class="k">def</span> <span class="nf">generate_pauli_terms</span><span class="p">(</span><span class="n">Q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct the cost Hamiltonian.</span>

<span class="sd">    Args:</span>
<span class="sd">        Q (ndarray): NxN symmetric matrix of coefficients for Z_i Z_j terms.</span>
<span class="sd">        b (ndarray): N-dimensional array coefficients for Z_i terms.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pauli_list: List of (Pauli string, coefficient) pairs representing the Hamiltonian terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># number of qubits</span>

    <span class="n">pauli_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Two-qubit terms</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Create a Pauli string with &quot;Z&quot; at positions i and j</span>
                <span class="n">paulis</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
                <span class="n">paulis</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">paulis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1"># multiply by a factor 2 since we are only summing the upper triangular of Q</span>
                <span class="n">pauli_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">paulis</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">coeff</span><span class="p">))</span>

    <span class="c1"># Single-qubit terms</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="c1"># Create a Pauli string with &quot;Z&quot; at position i</span>
            <span class="n">paulis</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
            <span class="n">paulis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mi">4</span>
            <span class="n">pauli_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">paulis</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">coeff</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">pauli_list</span>

<span class="n">b</span> <span class="o">=</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">Q</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">pauli_terms</span> <span class="o">=</span> <span class="n">generate_pauli_terms</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">cost_hamiltonian</span> <span class="o">=</span> <span class="n">SparsePauliOp</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">pauli_terms</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cost Function Hamiltonian:&quot;</span><span class="p">,</span> <span class="n">cost_hamiltonian</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cost Function Hamiltonian: SparsePauliOp([&#39;IIIIIIZZ&#39;, &#39;IIZIIIIZ&#39;, &#39;IZIIIIIZ&#39;, &#39;ZIIIIIIZ&#39;, &#39;IIIIIZZI&#39;, &#39;IIIIZIZI&#39;, &#39;IIIZIIZI&#39;, &#39;IIZIIIZI&#39;, &#39;IZIIIIZI&#39;, &#39;ZIIIIIZI&#39;, &#39;IIZIIZII&#39;, &#39;IZIIIZII&#39;, &#39;IIZIZIII&#39;, &#39;IZIIZIII&#39;, &#39;ZIIIZIII&#39;, &#39;IIZZIIII&#39;, &#39;IZIZIIII&#39;, &#39;ZIIZIIII&#39;, &#39;IZZIIIII&#39;, &#39;ZIZIIIII&#39;, &#39;ZZIIIIII&#39;, &#39;IIIIIIIZ&#39;, &#39;IIIIIIZI&#39;, &#39;IIIIIZII&#39;, &#39;IIIIZIII&#39;, &#39;IIIZIIII&#39;, &#39;IIZIIIII&#39;, &#39;IZIIIIII&#39;, &#39;ZIIIIIII&#39;],
              coeffs=[ 1. +0.j,  1.5+0.j,  2.5+0.j,  1.5+0.j,  1.5+0.j,  4.5+0.j,  2. +0.j,
  1.5+0.j,  2.5+0.j,  1. +0.j,  1.5+0.j,  2.5+0.j,  3. +0.j,  3.5+0.j,
  2.5+0.j,  3. +0.j,  1. +0.j,  6. +0.j,  1.5+0.j,  2. +0.j,  0.5+0.j,
  2. +0.j, -5. +0.j,  4.5+0.j, -4. +0.j, -1.5+0.j, -5. +0.j, -4.5+0.j,
 -3.5+0.j])
</pre></div>
</div>
</div>
</div>
</section>
<section id="hamiltonian-quantum-circuit">
<h4>Hamiltonian → quantum circuit<a class="headerlink" href="#hamiltonian-quantum-circuit" title="Link to this heading"></a></h4>
<p>The Hamiltonian <span class="math notranslate nohighlight">\(H_C\)</span> contains the quantum definition of your problem. Now you can create a quantum circuit that will help <em>sample</em> good solutions from the quantum computer. The QAOA is inspired by quantum annealing and applies alternating layers of operators in the quantum circuit.</p>
<p>The general idea is to start in the ground state of a known system, <span class="math notranslate nohighlight">\(H^{\otimes n}|0\rangle\)</span> above, and then steer the system into the ground state of the cost operator that you are interested in. This is done by applying the operators <span class="math notranslate nohighlight">\(\exp\{-i\gamma_k H_C\}\)</span> and <span class="math notranslate nohighlight">\(\exp\{-i\beta_k H_B\}\)</span> with angles <span class="math notranslate nohighlight">\(\gamma_1,...,\gamma_p\)</span> and <span class="math notranslate nohighlight">\(\beta_1,...,\beta_p~\)</span>.</p>
<p>The quantum circuit that you generate is <strong>parametrized</strong> by <span class="math notranslate nohighlight">\(\gamma_i\)</span> and <span class="math notranslate nohighlight">\(\beta_i\)</span>, so you can try out different values of <span class="math notranslate nohighlight">\(\gamma_i\)</span> and <span class="math notranslate nohighlight">\(\beta_i\)</span> and sample from the resulting state.</p>
<a class="reference internal image-reference" href="https://github.com/Wikstahl/autumn-school-qas2024/blob/main/images/qaoa_circuit.jpg?raw=true"><img alt="https://github.com/Wikstahl/autumn-school-qas2024/blob/main/images/qaoa_circuit.jpg?raw=true" src="https://github.com/Wikstahl/autumn-school-qas2024/blob/main/images/qaoa_circuit.jpg?raw=true" style="width: 800px;" />
</a>
<p>In this case, you will try an example with two QAOA layers that contains four parameters: <span class="math notranslate nohighlight">\(\gamma_1\)</span>, <span class="math notranslate nohighlight">\(\beta_1\)</span>, <span class="math notranslate nohighlight">\(\gamma_2\)</span>, <span class="math notranslate nohighlight">\(\beta_2\)</span>,.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">QAOAAnsatz</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">QAOAAnsatz</span><span class="p">(</span><span class="n">cost_operator</span><span class="o">=</span><span class="n">cost_hamiltonian</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/cac4ca0ddfb9403f690bc37c51dff9502c6b5a6f1e98105efdb28a412d793420.png" src="_images/cac4ca0ddfb9403f690bc37c51dff9502c6b5a6f1e98105efdb28a412d793420.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">parameters</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ParameterView([ParameterVectorElement(β[0]), ParameterVectorElement(β[1]), ParameterVectorElement(γ[0]), ParameterVectorElement(γ[1])])
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="step-2-optimize-circuits-for-quantum-hardware-execution">
<h3>Step 2. Optimize circuits for quantum hardware execution<a class="headerlink" href="#step-2-optimize-circuits-for-quantum-hardware-execution" title="Link to this heading"></a></h3>
<p>The circuit above contains a series of abstractions useful to think about quantum algorithms, but not possible to run on the hardware. To be able to run on a QPU, the circuit needs to undergo a series of operations that make up the <strong>transpilation</strong> or <strong>circuit optimization</strong> step of the pattern.</p>
<p>Transpilation may involves several steps, such as:</p>
<ul class="simple">
<li><p><strong>Initial mapping</strong> of the qubits in the circuit (such as decision variables) to physical qubits on the device.</p></li>
<li><p><strong>Unrolling</strong> of the instructions in the quantum circuit to the hardware-native instructions that the backend understands.</p></li>
<li><p><strong>Routing</strong> of any qubits in the circuit that interact to physical qubits that are adjacent with one another.</p></li>
<li><p><strong>Error suppression</strong> by adding single-qubit gates to suppress noise with dynamical decoupling.</p></li>
</ul>
<p>The following code transforms and optimizes the abstract circuit into a format that is ready for execution on the specified backend.
For simplicity we will use a simulator backend, but this could easily be swapped out for a real quantum computing backend.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_aer</span> <span class="kn">import</span> <span class="n">AerSimulator</span>
<span class="kn">from</span> <span class="nn">qiskit_ibm_runtime</span> <span class="kn">import</span> <span class="n">QiskitRuntimeService</span>
<span class="kn">from</span> <span class="nn">qiskit.transpiler.preset_passmanagers</span> <span class="kn">import</span> <span class="n">generate_preset_pass_manager</span>

<span class="c1"># Choose backend (this can either be a simulator or a real qc backend.)</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">AerSimulator</span><span class="p">()</span>

<span class="c1"># Create pass manager for transpilation</span>
<span class="n">pm</span> <span class="o">=</span> <span class="n">generate_preset_pass_manager</span><span class="p">(</span><span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span>

<span class="n">candidate_circuit</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
<span class="n">candidate_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">idle_wires</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/52453db04c99801c2523026c52e3b8ee82f337ad142109e0d4cf25e29eb58842.png" src="_images/52453db04c99801c2523026c52e3b8ee82f337ad142109e0d4cf25e29eb58842.png" />
</div>
</div>
</section>
<section id="step-3-execute-using-qiskit-primitives">
<h3>Step 3. Execute using Qiskit primitives<a class="headerlink" href="#step-3-execute-using-qiskit-primitives" title="Link to this heading"></a></h3>
<p>In the QAOA workflow, the optimal QAOA parameters are found in an iterative optimization loop, which runs a series of circuit evaluations and uses a classical optimizer to find the optimal <span class="math notranslate nohighlight">\(\beta_k\)</span> and <span class="math notranslate nohighlight">\(\gamma_k\)</span> parameters. This execution loop is executed via the following steps:</p>
<ol class="arabic simple">
<li><p>Define the initial parameters.</p></li>
<li><p>Use a classical optimizer to minimize the expectation value of the cost Hamiltonian, <span class="math notranslate nohighlight">\(H_C\)</span>, by iteratively adjusting <span class="math notranslate nohighlight">\(\beta_k\)</span> and <span class="math notranslate nohighlight">\(\gamma_k\)</span>.</p></li>
<li><p>Once the optimizer converges on a set of optimal parameters, execute the circuit one last time to sample the final distribution. The sampled states represent candidate solutions for the optimization problem.</p></li>
</ol>
<section id="step-3-1-define-circuit-with-initial-parameters">
<h4>Step 3.1: Define circuit with initial parameters<a class="headerlink" href="#step-3-1-define-circuit-with-initial-parameters" title="Link to this heading"></a></h4>
<p>We start with an initial guess for the parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">init_params</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">init_params</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2.5, 2.5, 0.1, 0.1]
</pre></div>
</div>
</div>
</div>
</section>
<section id="step-3-2-run-optimizer">
<h4>Step 3.2 Run optimizer<a class="headerlink" href="#step-3-2-run-optimizer" title="Link to this heading"></a></h4>
<p>The two primitives are Sampler and Estimator, and the choice of primitive depends on what type of measurement you want to run on the quantum computer. For the minimization of <span class="math notranslate nohighlight">\(H_C\)</span>, use the Estimator since the measurement of the cost function is simply the expectation value of <span class="math notranslate nohighlight">\(\langle H_C \rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">objective_func_vals</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Global variable</span>

<span class="k">def</span> <span class="nf">cost_func_estimator</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">:</span> <span class="s2">&quot;QuantumCircuit&quot;</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">:</span> <span class="s2">&quot;ObservablesArrayLike&quot;</span><span class="p">,</span> <span class="n">estimator</span><span class="p">:</span> <span class="s2">&quot;Estimator&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>

    <span class="c1"># transform the observable defined on virtual qubits to</span>
    <span class="c1"># an observable defined on all physical qubits for the backend.</span>
    <span class="n">isa_hamiltonian</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="o">.</span><span class="n">apply_layout</span><span class="p">(</span><span class="n">ansatz</span><span class="o">.</span><span class="n">layout</span><span class="p">)</span>

    <span class="n">pub</span> <span class="o">=</span> <span class="p">(</span><span class="n">ansatz</span><span class="p">,</span> <span class="n">isa_hamiltonian</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">pub</span><span class="p">])</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">evs</span>

    <span class="n">objective_func_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_ibm_runtime</span> <span class="kn">import</span> <span class="n">EstimatorV2</span> <span class="k">as</span> <span class="n">Estimator</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>

<span class="n">estimator</span> <span class="o">=</span> <span class="n">Estimator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span><span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;default_shots&quot;</span><span class="p">:</span> <span class="mi">4_000</span><span class="p">})</span>

<span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
    <span class="n">cost_func_estimator</span><span class="p">,</span>
    <span class="n">init_params</span><span class="p">,</span>
    <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">candidate_circuit</span><span class="p">,</span> <span class="n">cost_hamiltonian</span><span class="p">,</span> <span class="n">estimator</span><span class="p">),</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;COBYLA&quot;</span><span class="p">,</span>
    <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
    <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;rhobeg&quot;</span><span class="p">:</span> <span class="mf">1e-1</span><span class="p">}</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> message: Optimization terminated successfully.
 success: True
  status: 1
     fun: -23.82091977005749
       x: [ 2.635e+00  2.625e+00  5.093e-02  1.087e-01]
    nfev: 30
   maxcv: 0.0
</pre></div>
</div>
</div>
</div>
<p>The optimizer was able to minimize the cost and find better parameters for the circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">objective_func_vals</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iteration&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Cost&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/f81e71e899cedc379c74817eb711d65dfce03e612f09195f39e99c2ede286219.png" src="_images/f81e71e899cedc379c74817eb711d65dfce03e612f09195f39e99c2ede286219.png" />
</div>
</div>
<p>Once you have found the optimal parameters for the circuit, you can assign these parameters and sample the final distribution obtained with the optimized parameters. Here is where the <em>Sampler</em> primitive should be used since it is the probability distribution of bitstring measurements.</p>
<p><strong>Note:</strong> This means preparing a quantum state <span class="math notranslate nohighlight">\(\psi\)</span> in the computer and then measuring it. A measurement will collapse the state into a single computational basis state - for example, <code class="docutils literal notranslate"><span class="pre">01010100</span></code> - which corresponds to a candidate solution <span class="math notranslate nohighlight">\(x\)</span> to our initial optimization problem (<span class="math notranslate nohighlight">\(\max f(x)\)</span> or <span class="math notranslate nohighlight">\(\min f(x)\)</span> depending on the task).</p>
</section>
<section id="step-3-3-run-circuit-once-more-using-optimal-parameters">
<h4>Step 3.3: Run circuit once more using optimal parameters<a class="headerlink" href="#step-3-3-run-circuit-once-more-using-optimal-parameters" title="Link to this heading"></a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optimized_circuit</span> <span class="o">=</span> <span class="n">candidate_circuit</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="n">optimized_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">idle_wires</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ae54d28c59dcd68f08f3a63e982eb3e8216b52211a1f9cb0cac359dddbff2a04.png" src="_images/ae54d28c59dcd68f08f3a63e982eb3e8216b52211a1f9cb0cac359dddbff2a04.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_ibm_runtime</span> <span class="kn">import</span> <span class="n">SamplerV2</span> <span class="k">as</span> <span class="n">Sampler</span>

<span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;default_shots&quot;</span><span class="p">:</span> <span class="mi">4_000</span><span class="p">})</span>

<span class="n">pub</span> <span class="o">=</span> <span class="p">(</span><span class="n">optimized_circuit</span><span class="p">,)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">pub</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts_bin</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">shots</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">num_shots</span>
<span class="n">final_distribution_bin</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="o">/</span> <span class="n">shots</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">counts_bin</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">final_distribution_bin</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;10010100&#39;: 0.00825, &#39;00010111&#39;: 0.02375, &#39;00011101&#39;: 0.242, &#39;10110110&#39;: 0.00225, &#39;10000101&#39;: 0.05525, &#39;01110100&#39;: 0.00175, &#39;00110011&#39;: 0.00025, &#39;11000110&#39;: 0.004, &#39;10000100&#39;: 0.0165, &#39;00000101&#39;: 0.03275, &#39;01000000&#39;: 0.001, &#39;00010101&#39;: 0.067, &#39;00110111&#39;: 0.00475, &#39;11100111&#39;: 0.0035, &#39;00101101&#39;: 0.00125, &#39;11001111&#39;: 0.0025, &#39;01100011&#39;: 0.0015, &#39;11000101&#39;: 0.0095, &#39;10100000&#39;: 0.0005, &#39;01011111&#39;: 0.003, &#39;10001111&#39;: 0.0105, &#39;10100101&#39;: 0.01075, &#39;01011100&#39;: 0.005, &#39;11100101&#39;: 0.0035, &#39;11011101&#39;: 0.00225, &#39;10010101&#39;: 0.02625, &#39;00001101&#39;: 0.00975, &#39;10000111&#39;: 0.02375, &#39;10000110&#39;: 0.011, &#39;00010100&#39;: 0.00575, &#39;11000100&#39;: 0.01775, &#39;01010000&#39;: 0.00225, &#39;00000111&#39;: 0.017, &#39;01100010&#39;: 0.00075, &#39;11110100&#39;: 0.00475, &#39;01000010&#39;: 0.001, &#39;00111101&#39;: 0.0055, &#39;11110101&#39;: 0.00175, &#39;11101101&#39;: 0.002, &#39;00100101&#39;: 0.00775, &#39;00011111&#39;: 0.01975, &#39;01010101&#39;: 0.0145, &#39;00011001&#39;: 0.0085, &#39;10110101&#39;: 0.0045, &#39;10011101&#39;: 0.02675, &#39;00100111&#39;: 0.0045, &#39;11100000&#39;: 0.0035, &#39;11001101&#39;: 0.004, &#39;00110100&#39;: 0.0015, &#39;01000101&#39;: 0.0045, &#39;11100110&#39;: 0.004, &#39;00110101&#39;: 0.00875, &#39;00010001&#39;: 0.00075, &#39;10110111&#39;: 0.0055, &#39;11100100&#39;: 0.006, &#39;01110101&#39;: 0.0025, &#39;10100011&#39;: 0.0005, &#39;10001101&#39;: 0.02525, &#39;10100100&#39;: 0.00775, &#39;01010001&#39;: 0.00375, &#39;10001001&#39;: 0.002, &#39;01101111&#39;: 0.001, &#39;11000001&#39;: 0.00175, &#39;01111001&#39;: 0.00125, &#39;11100001&#39;: 0.00125, &#39;10101101&#39;: 0.0055, &#39;10010110&#39;: 0.0015, &#39;10101100&#39;: 0.00075, &#39;00010110&#39;: 0.00025, &#39;00001111&#39;: 0.00175, &#39;10100110&#39;: 0.00325, &#39;00111100&#39;: 0.0005, &#39;11110010&#39;: 0.00125, &#39;11000111&#39;: 0.0045, &#39;11010100&#39;: 0.00275, &#39;11001110&#39;: 0.001, &#39;01011001&#39;: 0.0055, &#39;00100011&#39;: 0.00125, &#39;01000111&#39;: 0.0025, &#39;00000110&#39;: 0.0025, &#39;01000110&#39;: 0.00125, &#39;10000001&#39;: 0.0015, &#39;01110011&#39;: 0.00025, &#39;10101110&#39;: 0.00175, &#39;01110111&#39;: 0.0015, &#39;10111100&#39;: 0.0005, &#39;00100100&#39;: 0.00175, &#39;11101110&#39;: 0.00025, &#39;01101110&#39;: 0.00075, &#39;11010001&#39;: 0.00125, &#39;10101111&#39;: 0.00575, &#39;11101111&#39;: 0.0005, &#39;01100100&#39;: 0.00175, &#39;01010100&#39;: 0.00775, &#39;01100101&#39;: 0.00125, &#39;10111001&#39;: 0.0005, &#39;00000100&#39;: 0.008, &#39;10110001&#39;: 0.00025, &#39;01011101&#39;: 0.006, &#39;01001111&#39;: 0.0015, &#39;01000100&#39;: 0.006, &#39;10110100&#39;: 0.0005, &#39;10111101&#39;: 0.00275, &#39;10010111&#39;: 0.012, &#39;11011000&#39;: 0.00025, &#39;01010010&#39;: 0.0005, &#39;01100000&#39;: 0.0015, &#39;01111100&#39;: 0.0005, &#39;11110110&#39;: 0.00025, &#39;01101101&#39;: 0.00075, &#39;11000000&#39;: 0.00075, &#39;10011110&#39;: 0.0005, &#39;11010101&#39;: 0.004, &#39;10001011&#39;: 0.0005, &#39;00000011&#39;: 0.00025, &#39;00001001&#39;: 0.00175, &#39;01100111&#39;: 0.00075, &#39;11010111&#39;: 0.00275, &#39;11100011&#39;: 0.00125, &#39;01010111&#39;: 0.005, &#39;01111110&#39;: 0.00075, &#39;11001100&#39;: 0.0005, &#39;11101011&#39;: 0.0005, &#39;01111011&#39;: 0.00075, &#39;10100111&#39;: 0.006, &#39;11110111&#39;: 0.00075, &#39;10011111&#39;: 0.00475, &#39;10010001&#39;: 0.00075, &#39;01100001&#39;: 0.001, &#39;11101100&#39;: 0.0015, &#39;11011100&#39;: 0.00175, &#39;01001101&#39;: 0.00175, &#39;11010110&#39;: 0.00175, &#39;01111101&#39;: 0.0005, &#39;10001100&#39;: 0.00075, &#39;00111011&#39;: 0.00075, &#39;11000011&#39;: 0.0015, &#39;01001100&#39;: 0.00125, &#39;00100110&#39;: 0.00125, &#39;11011001&#39;: 0.001, &#39;11010000&#39;: 0.001, &#39;01011000&#39;: 0.00025, &#39;00011100&#39;: 0.0005, &#39;11100010&#39;: 0.00125, &#39;10011011&#39;: 0.00025, &#39;11011111&#39;: 0.00075, &#39;00101011&#39;: 0.00025, &#39;01011011&#39;: 0.00175, &#39;00111001&#39;: 0.001, &#39;00010000&#39;: 0.00075, &#39;00111111&#39;: 0.00075, &#39;11110001&#39;: 0.00125, &#39;11111110&#39;: 0.002, &#39;01110000&#39;: 0.00025, &#39;01000001&#39;: 0.00125, &#39;01001000&#39;: 0.00025, &#39;10100001&#39;: 0.0005, &#39;10000000&#39;: 0.0005, &#39;11000010&#39;: 0.002, &#39;00011110&#39;: 0.00025, &#39;00001100&#39;: 0.00025, &#39;11111100&#39;: 0.0005, &#39;10001110&#39;: 0.00075, &#39;11111111&#39;: 0.00075, &#39;11010011&#39;: 0.00075, &#39;00100000&#39;: 0.001, &#39;01110001&#39;: 0.0005, &#39;11111011&#39;: 0.0005, &#39;01101011&#39;: 0.00075, &#39;01011110&#39;: 0.001, &#39;10010000&#39;: 0.0005, &#39;11111101&#39;: 0.00025, &#39;10000010&#39;: 0.0005, &#39;10110011&#39;: 0.00075, &#39;10100010&#39;: 0.00075, &#39;00101100&#39;: 0.00025, &#39;00011000&#39;: 0.00025, &#39;11011011&#39;: 0.00025, &#39;10111111&#39;: 0.00025, &#39;01010110&#39;: 0.0005, &#39;10011001&#39;: 0.0005, &#39;11101001&#39;: 0.00025, &#39;01000011&#39;: 0.0005, &#39;01011010&#39;: 0.0005, &#39;11001001&#39;: 0.00075, &#39;00110110&#39;: 0.00025, &#39;00110001&#39;: 0.00025, &#39;10001000&#39;: 0.00025, &#39;00010011&#39;: 0.00025, &#39;01111111&#39;: 0.0005, &#39;10010010&#39;: 0.00025, &#39;00101111&#39;: 0.00075, &#39;01001001&#39;: 0.00025, &#39;01001010&#39;: 0.0005, &#39;00001110&#39;: 0.00025, &#39;00000000&#39;: 0.00025, &#39;00011011&#39;: 0.00025, &#39;11001011&#39;: 0.00025, &#39;10110010&#39;: 0.00025, &#39;01001011&#39;: 0.00025}
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="step-4-post-process-return-result-in-classical-format">
<h3>Step 4. Post-process, return result in classical format<a class="headerlink" href="#step-4-post-process-return-result-in-classical-format" title="Link to this heading"></a></h3>
<p>The final step involves interpreting the output of the quantum computation and translating it back into a solution for your original problem.</p>
<p>When the quantum circuit is executed, it samples from the probability distribution defined by the final quantum state. The output consists of bitstrings, where each bitstring corresponds to a potential solution to the problem. In this step, we:</p>
<ol class="arabic simple">
<li><p><strong>Filter Solutions</strong>: If any of the sampled bitstrings satisfy the constraints of the original problem (e.g., <span class="math notranslate nohighlight">\(f(\vec{x})=(A\vec{x} -\vec{1})^2=0\)</span> for the tail-assignment problem).</p></li>
<li><p><strong>Count Occurrences</strong>: Determine the most frequently observed bitstrings and plot a histogram.</p></li>
</ol>
<section id="step-4-1-filter-solutions">
<h4>Step 4.1: Filter Solutions<a class="headerlink" href="#step-4-1-filter-solutions" title="Link to this heading"></a></h4>
<p>We now process the bit-strings sampled from the quantum circuit to determine if any of them satisfy the constraints of the original optimization problem. For each sampled bit-string, we calculate whether it satisfies the problem constraints using the classical cost function <span class="math notranslate nohighlight">\(f(\vec{x})\)</span>. If and only if this function evaluates to <span class="math notranslate nohighlight">\(0\)</span> for a bitstring, a solution exists!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">classical_cost_fun</span><span class="p">(</span><span class="n">bit_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="c1"># convert binary string to column vector</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="nb">int</span><span class="p">(</span><span class="n">bit</span><span class="p">)]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">bit_str</span><span class="p">)])</span>
    <span class="n">id_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">A</span><span class="nd">@x</span><span class="o">-</span><span class="n">id_vec</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Look through samples to see if any of the bit strings solve the problem</span>
<span class="k">for</span> <span class="n">bit_str</span> <span class="ow">in</span> <span class="n">counts_bin</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">classical_cost_fun</span><span class="p">(</span><span class="n">bit_str</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Valid solution found:&quot;</span><span class="p">,</span> <span class="n">bit_str</span><span class="p">)</span>
        <span class="k">break</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Valid solution found: 00011101
</pre></div>
</div>
</div>
</div>
</section>
<section id="step-4-2-count-occurences">
<h4>Step 4.2 Count Occurences<a class="headerlink" href="#step-4-2-count-occurences" title="Link to this heading"></a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">highest_probability_bitstring</span><span class="p">(</span><span class="n">prob_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the bitstring with the highest probability as a column vector and corresponding probability.</span>

<span class="sd">    Args:</span>
<span class="sd">        prob_dict (dict): A dictionary where keys are bitstrings (str) and values are probabilities (float).</span>

<span class="sd">    Returns:</span>
<span class="sd">        (np.ndarray, float): The bitstring with the highest probability and the corresponding probability.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the key with the highest value</span>
    <span class="n">highest_key</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prob_dict</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">prob_dict</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
    <span class="n">highest_value</span> <span class="o">=</span> <span class="n">prob_dict</span><span class="p">[</span><span class="n">highest_key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">highest_key</span><span class="p">,</span> <span class="n">highest_value</span>

<span class="n">bit_str</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">highest_probability_bitstring</span><span class="p">(</span><span class="n">final_distribution_bin</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Most Likely bitstring is </span><span class="si">{</span><span class="n">bit_str</span><span class="si">}</span><span class="s2"> with probability </span><span class="si">{</span><span class="n">prob</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Most Likely bitstring is 00011101 with probability 24.2%
</pre></div>
</div>
</div>
</div>
<p>We see that QAOA return the solution bit-string with the highest probability. This can be compared to random-guessing, where the probability of obtaining the solution in this case is <span class="math notranslate nohighlight">\(1/2^8\approx 0.004\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute the classical cost function for all binary bitstrings</span>
<span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">bit_str</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">final_distribution_bin</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">classical_cost_fun</span><span class="p">(</span><span class="n">bit_str</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
    <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
    <span class="n">probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>

<span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>

<span class="c1"># Plot the histogram</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;purple&#39;</span> <span class="k">if</span> <span class="n">cost</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;black&#39;</span> <span class="k">for</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">costs</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">costs</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Classical Cost Function $f(x)$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Probability %&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of Classical Cost Function vs. Probability&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2a30600f02a6ae012804d52df1eb061ee8c15bcdfa45241ee548ce8e3ed049de.png" src="_images/2a30600f02a6ae012804d52df1eb061ee8c15bcdfa45241ee548ce8e3ed049de.png" />
</div>
</div>
</section>
</section>
<section id="extra-running-a-smaller-problem-on-actual-quantum-computer">
<h3>(Extra): Running a smaller problem on actual quantum computer<a class="headerlink" href="#extra-running-a-smaller-problem-on-actual-quantum-computer" title="Link to this heading"></a></h3>
<p>In this section, we demonstrate how to run a smaller version of the tail-assignment problem on a real quantum computer. To accommodate the 5-qubit Helmi quantum computer, we load a simplified 2-qubit toy problem.</p>
<ul class="simple">
<li><p>Load a Toy Problem: We initialize a smaller version of the tail-assignment problem, ensuring it fits within the qubit limits of the hardware.</p></li>
<li><p>Simulate Performance: Before running the problem on the real hardware, we test the circuit on a simulator to evaluate its behavior under ideal conditions.</p></li>
<li><p>Execute on a Real Backend: Finally, we execute the problem on the Helmi quantum computer to compare results and assess the impact of quantum noise.</p></li>
</ul>
<p>By exploring this smaller-scale problem, we get insights into real-world quantum hardware performance and its limitations, while preparing for scaling up to larger problems in the future.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;instance_2.csv&quot;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="c1"># load problem data</span>
<span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of flights equals </span><span class="si">{</span><span class="n">num_rows</span><span class="si">}</span><span class="s2">, and number of routes equals </span><span class="si">{</span><span class="n">num_cols</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of flights equals 2, and number of routes equals 2.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span> <span class="o">=</span> <span class="n">QUBO</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">Q</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">pauli_terms</span> <span class="o">=</span> <span class="n">generate_pauli_terms</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">cost_hamiltonian</span> <span class="o">=</span> <span class="n">SparsePauliOp</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">pauli_terms</span><span class="p">)</span>
<span class="n">cost_hamiltonian</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>SparsePauliOp([&#39;ZZ&#39;, &#39;IZ&#39;],
              coeffs=[0.5+0.j, 0.5+0.j])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QAOAAnsatz</span><span class="p">(</span><span class="n">cost_operator</span><span class="o">=</span><span class="n">cost_hamiltonian</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="c1"># Create pass manager for transpilation</span>
<span class="n">pm</span> <span class="o">=</span> <span class="n">generate_preset_pass_manager</span><span class="p">(</span><span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span>
<span class="n">candidate_circuit</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>

<span class="c1"># Theoretical pre-calculated optimal parameters</span>
<span class="n">optimal_params</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.3562</span><span class="p">,</span> <span class="mf">2.3562</span><span class="p">,</span> <span class="mf">1.5708</span><span class="p">,</span> <span class="mf">1.5708</span><span class="p">]</span>
<span class="n">optimized_circuit</span> <span class="o">=</span> <span class="n">candidate_circuit</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">optimal_params</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optimized_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/af1f41bef15920178586c955ee77d3d0cd07e5f63eeb74a05c26319e852769d4.png" src="_images/af1f41bef15920178586c955ee77d3d0cd07e5f63eeb74a05c26319e852769d4.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;default_shots&quot;</span><span class="p">:</span> <span class="mi">4_000</span><span class="p">})</span>
<span class="n">pub</span> <span class="o">=</span> <span class="p">(</span><span class="n">optimized_circuit</span><span class="p">,)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">pub</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts_bin</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">shots</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">num_shots</span>
<span class="n">final_distribution_bin</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="o">/</span> <span class="n">shots</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">counts_bin</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="n">final_distribution_bin</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;01&#39;: 1.0}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Look through samples to see if any of the bit strings solve the problem</span>
<span class="k">for</span> <span class="n">bit_str</span> <span class="ow">in</span> <span class="n">counts_bin</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">classical_cost_fun</span><span class="p">(</span><span class="n">bit_str</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Valid solution found:&quot;</span><span class="p">,</span> <span class="n">bit_str</span><span class="p">)</span>
        <span class="k">break</span>
<span class="n">x</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">highest_probability_bitstring</span><span class="p">(</span><span class="n">final_distribution_bin</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Valid solution found: 01
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot distrubution of bit-strings.</span>
<span class="n">bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">final_distribution_bin</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">final_distribution_bin</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<span class="c1"># Plot the histogram</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;bit-strings&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Probability %&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of bit-strings vs. Probability&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/6521f20585c97cfc9efeafe20e00ed5758907c3a1b25f2c91fead6121dcb9d45.png" src="_images/6521f20585c97cfc9efeafe20e00ed5758907c3a1b25f2c91fead6121dcb9d45.png" />
</div>
</div>
<p>For the 2-qubit toy problem, the QAOA algorithm correctly identifies the optimal solution bit-string with 100% probability in the simulation using 2-layers. This result is under ideal conditions, where noise and hardware imperfections are absent.</p>
<section id="running-qaoa-on-the-helmi-quantum-computer">
<h4>Running QAOA on the HELMI quantum computer<a class="headerlink" href="#running-qaoa-on-the-helmi-quantum-computer" title="Link to this heading"></a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">iqm.qiskit_iqm</span> <span class="kn">import</span> <span class="n">IQMProvider</span>

<span class="n">HELMI_CORTEX_URL</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HELMI_CORTEX_URL&#39;</span><span class="p">)</span>  <span class="c1"># This is set when loading the module</span>
<span class="n">provider</span> <span class="o">=</span> <span class="n">IQMProvider</span><span class="p">(</span><span class="n">HELMI_CORTEX_URL</span><span class="p">)</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.compiler</span> <span class="kn">import</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">iqm.qiskit_iqm.iqm_transpilation</span> <span class="kn">import</span> <span class="n">optimize_single_qubit_gates</span>

<span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">optimized_transpiled_circuit</span> <span class="o">=</span> <span class="n">optimize_single_qubit_gates</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="o">.</span><span class="n">assign_parameters</span><span class="p">(</span><span class="n">optimal_params</span><span class="p">))</span>
<span class="n">optimized_transpiled_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d3fd835d305489f19485256fa4a679ebddd92b53ec6773545a75bb48f0d4bb35.png" src="_images/d3fd835d305489f19485256fa4a679ebddd92b53ec6773545a75bb48f0d4bb35.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">optimized_transpiled_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;JobStatus.QUEUED: &#39;job is queued&#39;&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts_bin</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="p">()[</span><span class="s2">&quot;counts&quot;</span><span class="p">]</span>
<span class="n">shots</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shots</span>
<span class="n">final_distribution_bin</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="o">/</span> <span class="n">shots</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">counts_bin</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="n">final_distribution_bin</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;01&#39;: 0.7080078125,
 &#39;11&#39;: 0.2880859375,
 &#39;00&#39;: 0.0029296875,
 &#39;10&#39;: 0.0009765625}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot distrubution of bit-strings.</span>
<span class="n">bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">final_distribution_bin</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">final_distribution_bin</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<span class="c1"># Plot the histogram</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;bit-strings&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Probability %&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Histogram of bit-strings vs. Probability&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/8624a948632fb10569fa8dd5911b477f6cc74ddc93c85cc159e542e205804a91.png" src="_images/8624a948632fb10569fa8dd5911b477f6cc74ddc93c85cc159e542e205804a91.png" />
</div>
</div>
</section>
</section>
<section id="conclusion">
<h3>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading"></a></h3>
<p>This tutorial demonstrated how to solve the tail-assignment problem using Qiskit. While quantum computers currently do not outperform classical computers for combinatorial optimization tasks—primarily due to noise and hardware limitations—progress in this field is advancing rapidly.</p>
<p>The hardware is steadily improving, with new algorithms continually being developed. Many of these quantum heuristics are currently tested on classical simulators, which are limited to small problem sizes (typically around 20 qubits).</p>
<p>In the near future, as quantum computers with more qubits and less noise, it will become feasible to benchmark quantum heuristics on larger, real-world problem instances. This progress holds the potential to unlock new capabilities in solving challenging optimization problems that are intractable by classical methods.</p>
</section>
</section>
<span id="document-qwalks"></span><section class="tex2jax_ignore mathjax_ignore" id="quantum-walks-on-quantum-computers">
<h2>Quantum walks on quantum computers<a class="headerlink" href="#quantum-walks-on-quantum-computers" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/5af2ea3809cb6dc1071e9aaec2b1967a/Quantum_Walks.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
<span id="document-tergite-overview"></span><section class="tex2jax_ignore mathjax_ignore" id="tergite-overview">
<h2>Tergite overview<a class="headerlink" href="#tergite-overview" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/a0a98d75e67ccb6ff108058ddd617208/qas-24-tergite-overview.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Overview</span> <span class="pre">slides</span></code></a></p>
<section id="contents">
<h3>Contents<a class="headerlink" href="#contents" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="#what-is-tergite">What is Tergite?</a></p></li>
<li><p><a class="reference internal" href="#why-is-tergite-necessary">Why is Tergite necessary?</a></p></li>
<li><p><a class="reference internal" href="#what-can-i-do-with-tergite">What can I do with Tergite?</a></p></li>
<li><p><a class="reference internal" href="#how-does-tergite-work">How does Tergite work?</a></p></li>
<li><p><a class="reference internal" href="#test-out-tergite">Test out Tergite</a></p></li>
</ul>
</section>
<section id="what-is-tergite">
<h3>What is Tergite?<a class="headerlink" href="#what-is-tergite" title="Link to this heading"></a></h3>
<p>Let’s take a walk down memory lane to the time when classical computers were large expensive machines that could only be afforded by large corporations.
Back then, batch processing enabled multiple users in a given company to share a single computer.</p>
<figure class="align-default" id="id1">
<img alt="An operator working on old mainframe" src="_images/operator-working-on-mainframe.jpg" />
<figcaption>
<p><span class="caption-text">An operator working on an old mainframe</span><a class="headerlink" href="#id1" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Quantum computing is at a similar stage today. Quantum computers are large expensive machines that can only be operated by a select few.
There is need for specialized software to give multiple users simplified access to a single quantum computer.</p>
<p><a class="reference external" href="https://tergite.github.io/">Tergite</a> is one such collection of software that enables a quantum computer experimentalist to:</p>
<ul class="simple">
<li><p>Submit experiments to the quantum computer’s queue.</p></li>
<li><p>Retrieve results of completed experiments</p></li>
<li><p>Monitor the device parameters of the quantum computer</p></li>
</ul>
<p>Just like in the batch processing of old, the quantum computer requires an operator.<br />
Through Tergite, an operator of a quantum computer can do the following:</p>
<ul class="simple">
<li><p>(Re)calibrate the quantum computer</p></li>
<li><p>Turn on/off the quantum computer</p></li>
<li><p>Manage experimentalists’ access to the quantum computer</p></li>
</ul>
</section>
<section id="why-is-tergite-necessary">
<h3>Why is Tergite necessary?<a class="headerlink" href="#why-is-tergite-necessary" title="Link to this heading"></a></h3>
<section id="operation-of-a-quantum-computer-requires-a-highly-specialized-skillset">
<h4>1. Operation of a quantum computer requires a highly specialized skillset.<a class="headerlink" href="#operation-of-a-quantum-computer-requires-a-highly-specialized-skillset" title="Link to this heading"></a></h4>
<p>Most quantum computers of today are very complex machines that require specialized care in a lab environment.
The skillset required to operate such machines takes many years of postgraduate studies to master.</p>
<p>Tergite gives experimentalists, who don’t have this skill, access to the quantum computer to run experiments on it.</p>
</section>
<section id="quantum-computers-need-frequent-recalibration">
<h4>2. Quantum computers need frequent recalibration<a class="headerlink" href="#quantum-computers-need-frequent-recalibration" title="Link to this heading"></a></h4>
<p>One characteristic of today’s quantum computers is the fact that their device parameters drift with time.
Temperature changes, cosmic radiation, aging of electronics, mechanincal vibrations etc. cause the
device parameters of the quantum computers to change with time.</p>
<p><a class="reference external" href="https://github.com/tergite/tergite-autocalibration/">Tergite autocalibration</a> is library used to recalibrate quantum computers. It is part of the Tergite stack.</p>
</section>
<section id="idle-time-on-a-quantum-computer-is-very-expensive">
<h4>3. Idle time on a quantum computer is very expensive.<a class="headerlink" href="#idle-time-on-a-quantum-computer-is-very-expensive" title="Link to this heading"></a></h4>
<p>A typical quantum computer today costs more than half a million euros (€500,000).
Every second a quantum computer lies under-utilized, a lot of money is being thrown down the drain.
Batching experiments from multiple experimentalists is an attempt to make sure the quantum computer is in use at all times.</p>
</section>
</section>
<section id="what-can-i-do-with-tergite">
<h3>What can I do with Tergite?<a class="headerlink" href="#what-can-i-do-with-tergite" title="Link to this heading"></a></h3>
<section id="access-the-wacqt-quantum-computer">
<h4>1. Access the WACQT quantum computer<a class="headerlink" href="#access-the-wacqt-quantum-computer" title="Link to this heading"></a></h4>
<p>The Wallenberg Center for Quantum Computing (WACQT) is a Swedish national research programme with a focus on quantum technology.
One of its major goals is to create a quantum computer that is accessible to Swedish researchers and WACQT industrial partners.
The WACQT quantum computer is physically housed at <a class="reference external" href="https://www.chalmers.se/">Chalmers University of Technology</a>
and is operated by <a class="reference external" href="https://chalmersnextlabs.se/">Chalmers Next Labs AB</a>.</p>
<figure class="align-default" id="id2">
<img alt="The WACQT quantum computer" src="_images/wacqt-quantum-computer.jpeg" />
<figcaption>
<p><span class="caption-text">The WACQT quantum computer laboratory</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In order to access this quantum computer via the internet, one has to go through the Tergite stack running at <a class="reference external" href="https://www.qal9000.se">QAL 9000</a>.</p>
<p>Interacting with the WACQT quantum computer requires the use of the <a class="reference external" href="https://pypi.org/project/tergite/">Tergite software development kit (SDK)</a>.</p>
</section>
<section id="calibrate-superconducting-qubit-chips">
<h4>2. Calibrate superconducting qubit chips<a class="headerlink" href="#calibrate-superconducting-qubit-chips" title="Link to this heading"></a></h4>
<p>If one has a superconducting quantum chip with a design similar to the WACQT quantum computer chip, it is possible to
calibrate this chip using the <a class="reference external" href="https://github.com/tergite/tergite-autocalibration/">Tergite autocalibration</a> library.
Doing this requires substantial hardware and software know-how.</p>
<p><a class="reference external" href="https://chalmersnextlabs.se/">Chalmers Next Labs AB</a> currently offers a service to calibrate such chips for Swedish Small and Medium Enterprises (SMEs).</p>
</section>
<section id="expose-a-physical-quantum-computer-to-the-internet">
<h4>3. Expose a physical quantum computer to the internet<a class="headerlink" href="#expose-a-physical-quantum-computer-to-the-internet" title="Link to this heading"></a></h4>
<p>The entire Tergite stack can be run in front of a physical quantum computer to expose it to a select group of
experimentalists. It contains Identity Access Management (IAM) to handle authorization of only members of a
given organization. Any organization can use Tergite to spin up a cloud offering for their quantum computers.
The Tergite stack is open source and free to use or extend under the <a class="reference external" href="https://github.com/tergite/tergite/blob/main/LICENSE.txt">Apache 2.0 License</a>.</p>
<p>However, there are a few requirements for Tergite to work well:</p>
<ul class="simple">
<li><p>The quantum chip should be a superconducting with a similar design to the WACQT quantum computer chip designas described by Kosen et al. in the <a class="reference external" href="https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.5.030350">“Signal Crosstalk in a Flip-Chip Quantum Processor”</a> article.</p></li>
<li><p>The quantum computer should be controlled by <a class="reference external" href="https://www.qblox.com/">Qblox instruments</a></p></li>
</ul>
</section>
</section>
<section id="how-does-tergite-work">
<h3>How does Tergite work?<a class="headerlink" href="#how-does-tergite-work" title="Link to this heading"></a></h3>
<figure class="align-default" id="id3">
<img alt="Data flow diagram of Tergite" src="_images/tergite-data-flow.png" />
<figcaption>
<p><span class="caption-text">Data flows in Tergite</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="components-of-the-stack">
<h4>Components of the stack<a class="headerlink" href="#components-of-the-stack" title="Link to this heading"></a></h4>
<p>Tergite is composed of four main components:</p>
<section id="backend">
<h5><a class="reference external" href="https://github.com/tergite/tergite-backend">Backend</a><a class="headerlink" href="#backend" title="Link to this heading"></a></h5>
<p>The operating system of the quantum computer. Its basic functions include:</p>
<ul class="simple">
<li><p>Transpiling <a class="reference external" href="https://arxiv.org/abs/1809.03452">OpenPulse</a> job definitions to <a class="reference external" href="https://quantify-os.org/docs/quantify-scheduler/dev/tutorials/Schedules%20and%20Pulses.html">Quantify Schedules</a> that can be understood by the Qblox control instruments.</p></li>
<li><p>Queuing jobs so that the quantum chip can receive one job at a time.</p></li>
<li><p>Saving the device parameters of the quantum chip, after (re)calibration.</p></li>
</ul>
</section>
<section id="frontend">
<h5><a class="reference external" href="https://github.com/tergite/tergite-frontend">Frontend</a><a class="headerlink" href="#frontend" title="Link to this heading"></a></h5>
<p>The public interface through which users on the internet interact with the quantum computer. It consists of:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/tergite/tergite-frontend/tree/main/apps/tergite-mss">RESTful API</a>
: The programmatic interface through which scripts and other computer programs interact with the quantum computer</p></li>
<li><p><a class="reference external" href="https://github.com/tergite/tergite-frontend/tree/main/apps/tergite-dashboard">Dashboard</a>
: The web-based graphical interface through which users interact with the quantum computer</p></li>
</ul>
</section>
<section id="software-development-kit-sdk">
<h5><a class="reference external" href="https://github.com/tergite/tergite">Software Development Kit (SDK)</a><a class="headerlink" href="#software-development-kit-sdk" title="Link to this heading"></a></h5>
<p>The Library which eases writing of python scripts and programs that interact with the quantum computer.
It is based on <a class="reference external" href="https://github.com/Qiskit/qiskit">Qiskit</a> and communicates with the backend using <a class="reference external" href="https://arxiv.org/abs/1809.03452">OpenPulse</a> sent via HTTP/HTTPS</p>
</section>
<section id="automatic-calibration-tool">
<h5><a class="reference external" href="https://github.com/tergite/tergite-autocalibration">Automatic Calibration Tool</a><a class="headerlink" href="#automatic-calibration-tool" title="Link to this heading"></a></h5>
<p>The Command Line Interface (CLI) used to determine the device parameters of the quantum computer.</p>
</section>
</section>
<section id="basic-flow">
<h4>Basic Flow<a class="headerlink" href="#basic-flow" title="Link to this heading"></a></h4>
<p><img alt="User sends quantum experiments to Tergite" src="_images/tergite-basic-flow-row-1.svg" />
<img alt="Tergite backend handles quantum experiments" src="_images/tergite-basic-flow-row-2.svg" />
<img alt="Qblox instruments run experiments" src="_images/tergite-basic-flow-row-3.svg" />
<img alt="User retrieves experiment results" src="_images/tergite-basic-flow-row-4.svg" /></p>
</section>
</section>
<section id="test-out-tergite">
<h3>Test out Tergite<a class="headerlink" href="#test-out-tergite" title="Link to this heading"></a></h3>
<p>It is possible to test out a live instance of Tergite by using the <a class="reference external" href="https://www.qal9000.se/">QAL 9000 quantum computer</a>.
However, someone from WACQT must have given you permission to use it because it is not open to the general public.</p>
<p>It is also possible to run Tergite on your own computer.
The only catch is that you will only be able to run your experiments on simulators.
Instructions on how to run Tergite locally are found in the <a class="reference external" href="https://tergite.github.io/tutorials/01_quick_start.html">Tergite quick start tutorial</a>.</p>
</section>
</section>
<span id="document-cos"></span><section class="tex2jax_ignore mathjax_ignore" id="distributed-quantum-computing">
<h2>Distributed Quantum Computing<a class="headerlink" href="#distributed-quantum-computing" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/e7a4c465a0e6318304e776636c9d317f/QAS-COS.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
<span id="document-qelm"></span><section class="tex2jax_ignore mathjax_ignore" id="quantum-extreme-learning-machine">
<h2>Quantum extreme learning machine<a class="headerlink" href="#quantum-extreme-learning-machine" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/e9c0741550debf3795d5bc66f4e1a547/QELM_CaseStudy.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
<span id="document-matsci_on_qc/README"></span><section class="tex2jax_ignore mathjax_ignore" id="quantum-computing-for-materials-science">
<h2>Quantum Computing for Materials Science<a class="headerlink" href="#quantum-computing-for-materials-science" title="Link to this heading"></a></h2>
<blockquote>
<div><p><strong>Note</strong>: This tutorial is based on research work available on <a class="reference external" href="https://arxiv.org/abs/2412.00951">arXiv:2412.00951</a>. Related codes and input files can be found in the <a class="reference external" href="https://github.com/MarcMaussner/2024_inhibitQ/tree/main/phase2_submission">2024_inhibitQ repository</a>.</p>
</div></blockquote>
<p>The slides for the talk related to this tutorial can be found <a class="reference download internal" download="" href="_downloads/498413dcc19eeda31a06490b936fd9e0/QAS2024_mat_sci_on_qc.pdf"><span class="xref download myst">here</span></a> (right-click and select “Open in new tab” to view in browser).</p>
<p>The demo files for this tutorial are described and detailed throughout the text here in this page and the associated pages. It should also appear in your LUMI notebooks, otherwise, you can download them from <a class="reference external" href="https://github.com/ENCCS/qas2024/tree/main/content/notebooks/mat_sc_on_qc"><code class="docutils literal notranslate"><span class="pre">mat_sc_on_qc</span></code></a></p>
<section id="contents">
<h3>Contents<a class="headerlink" href="#contents" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="#introduction">Introduction</a></p></li>
<li><p><a class="reference internal" href="#why-quantum-computing-for-materials">Why Quantum Computing for Materials?</a></p></li>
<li><p><a class="reference internal" href="#prerequisites">Prerequisites</a></p></li>
<li><p><a class="reference internal" href="#hands-on-example">Hands-on Example</a></p>
<ul>
<li><p><a class="reference internal" href="#classical-calculations"><span class="xref myst">Classical Calculations</span></a></p></li>
<li><p><a class="reference internal" href="#hybrid-quantum-classical-calculation"><span class="xref myst">Hybrid Quantum-Classical Calculation</span></a></p></li>
<li><p><a class="reference internal" href="#results-and-analysis"><span class="xref myst">Results &amp; Analysis</span></a></p>
<ul>
<li><p><a class="reference internal" href="#binding-energy-comparison"><span class="xref myst">Binding Energy Comparison</span></a></p></li>
<li><p><a class="reference internal" href="#discussion-and-future-work"><span class="xref myst">Discussion &amp; Future Work</span></a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h3>
<p>Quantum chemistry calculations are among the most promising early applications of quantum computers. However, materials science simulations, particularly those involving solid-state systems, have not been well covered in the literature. Such calculations are usually associated with periodic system descriptions and can involve a large number of atoms, often in the hundreds. This repository aims to provide a comprehensive guide on how to perform these calculations using quantum computers in a way that aligns with current efforts to introduce quantum-centric supercomputers, where the quantum computer is considered an accelerator for classical calculations, similar to the role of GPUs in various fields. The tutorial here is focusing on simulating the calculation on a quantum computer, some hinders weren’t solved when it comes to running the calculation on quantum computer at the time of writing this tutorial.</p>
</section>
<section id="why-quantum-computing-for-materials">
<h3>Why Quantum Computing for Materials?<a class="headerlink" href="#why-quantum-computing-for-materials" title="Link to this heading"></a></h3>
<p>The simulation of large solid-state systems typically involves a significant number of atoms, which necessitates approximations in calculating the ground state energy. Methods like Density Functional Theory (DFT) are useful in this context. However, there are important parts of the system that can be described more accurately, especially when they involve interactions of particular interest to scientists. Quantum computing algorithms could be advantageous in focusing on such subsystems of the supercell and communicating the results to the DFT code. In simpler terms, they can correct the energy by accounting for more detailed information from these specific subsystems. This approach is known as quantum embedding<a class="footnote-reference brackets" href="#id6" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Of course, this is a very simplified description and can be considered analogous to the QM/MM method; again, this is just a simplification of the problem description and not an entirely accurate illustration.</p>
<p>It is a hot topic now given the quantum centeric supercomputers effort and the rise of hybrid quantum classical approaches. More recent literature to study can be found in those references<a class="footnote-reference brackets" href="#id7" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id8" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id9" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id10" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="prerequisites">
<h3>Prerequisites<a class="headerlink" href="#prerequisites" title="Link to this heading"></a></h3>
<p>To follow this tutorial, you should have a basic understanding of quantum computing and materials science or quantum chemistry, like simulating the H2 molecule or LiH tutorials by qiskit for example. Familiarity with quantum chemistry calculations and Density Functional Theory (DFT) will be helpful.</p>
</section>
<section id="hands-on-example">
<h3>Hands-on Example<a class="headerlink" href="#hands-on-example" title="Link to this heading"></a></h3>
<section id="classical-calculations">
<h4>1. Classical Calculations<a class="headerlink" href="#classical-calculations" title="Link to this heading"></a></h4>
<p>For detailed information about the classical calculations, including supercell generation, geometry optimization, supercell calculations, and binding energy calculation, please see <a class="reference internal" href="#document-matsci_on_qc/classical_calculations"><span class="std std-doc">Classical Calculations</span></a>.</p>
<p>The supercell used in this tutorial is a 4x4x1 Al(111) substrate with a 1,2,4-triazole molecule on top of the Al(111) surface.</p>
<p><img alt="The geometry optimized supercell of triazole molecule on top Al substrate" src="_images/example_supercell.svg" /></p>
</section>
<section id="hybrid-quantum-classical-calculation">
<h4>2. Hybrid Quantum Classical Calculation<a class="headerlink" href="#hybrid-quantum-classical-calculation" title="Link to this heading"></a></h4>
<p>This section demonstrates the integration of classical DFT calculations with quantum computing methods through an active space embedding scheme. The implementation combines CP2K for classical DFT calculations with Qiskit for quantum computations, using an active space of 2 electrons in 5 orbitals.</p>
<p>Key components include:</p>
<ul class="simple">
<li><p>Classical DFT calculations using CP2K</p></li>
<li><p>Quantum calculations with Active space embedding using ADAPT-VQE algorithm</p></li>
<li><p>Socket-based integration between classical and quantum components</p></li>
</ul>
<p>For detailed implementation information, including configuration parameters and workflow structure, see <a class="reference internal" href="#document-matsci_on_qc/hybrid_quantum_classical"><span class="std std-doc">Hybrid Quantum Classical Calculations</span></a>.</p>
</section>
<section id="calculations-results">
<h4>3. Calculations Results<a class="headerlink" href="#calculations-results" title="Link to this heading"></a></h4>
<p>After performing the hybrid quantum-classical calculations, we analyze the binding energy to understand the interaction strength between the surface and the adsorbate. The binding energy is calculated as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">E_binding</span> <span class="o">=</span> <span class="n">E_supercell</span> <span class="o">-</span> <span class="p">(</span><span class="n">E_substrate</span> <span class="o">+</span> <span class="n">E_inhibitor</span><span class="p">)</span>
</pre></div>
</div>
<section id="binding-energy-comparison">
<h5>Binding Energy Comparison<a class="headerlink" href="#binding-energy-comparison" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Inhibitor</p></th>
<th class="head"><p>Binding Energy (eV)</p></th>
<th class="head"><p>Binding Distance (Å)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Classical DFT</p></td>
<td><p>1,2,4-Triazole</p></td>
<td><p>-0.385512</p></td>
<td><p>3.54</p></td>
</tr>
<tr class="row-odd"><td><p>AdaptVQE</p></td>
<td><p>1,2,4-Triazole</p></td>
<td><p>-0.385508</p></td>
<td><p>3.54</p></td>
</tr>
<tr class="row-even"><td><p>Vanilla VQE</p></td>
<td><p>1,2,4-Triazole</p></td>
<td><p>-2.325986</p></td>
<td><p>3.54</p></td>
</tr>
</tbody>
</table>
</section>
<section id="discussion-and-future-work">
<h5>Discussion and Future Work<a class="headerlink" href="#discussion-and-future-work" title="Link to this heading"></a></h5>
<p>The results of this simulations show an agreement between classical DFT and AdaptVQE method. The AdaptVQE implementation proved more robust with its gradient-based operator pool selection compared to the vanilla VQE, which showed significant deviation with notably higher binding energy.</p>
</section>
<section id="outlook-and-discussion">
<h5>Outlook and Discussion<a class="headerlink" href="#outlook-and-discussion" title="Link to this heading"></a></h5>
<p>The calculation employed an active space of 2 electrons in 5 orbitals (10 spin-orbitals) around the Fermi level. For more accurate results, expanding the active space to include more orbitals could lead to different binding energies compared to the classical approach, particularly in better capturing the complex hybridization between molecular orbitals and substrate states. At the time of writting this tutorial, only the assigned number of orbitals and electrons managed the calculation to converge.</p>
</section>
<section id="conclusion-and-future-work">
<h5>Conclusion and Future Work<a class="headerlink" href="#conclusion-and-future-work" title="Link to this heading"></a></h5>
<p>This work successfully demonstrating a workflow for hybrid quantum-classical calculations for materials science, suitable for running on quantum centric supercomputers like Lumi. A lot of work is still needed to make this method practical for large systems and to improve the convergence of the calculation when using the AdaptVQE algorithm and including more orbitals in the active space, which will make the calculation worth it on quantum computers. Ofcourse, error mitigation techniques will be needed to make this method practical, but that is another story.</p>
</section>
<section id="snippets-from-the-slides">
<h5>Snippets from the slides<a class="headerlink" href="#snippets-from-the-slides" title="Link to this heading"></a></h5>
<p>I believe those snippets augment the text and provide a better understanding of the work. Ofcourse, the full slides are available <a class="reference download internal" download="" href="_downloads/498413dcc19eeda31a06490b936fd9e0/QAS2024_mat_sci_on_qc.pdf"><span class="xref download myst">here</span></a> (right-click and select “Open in new tab” to view in browser).`</p>
<p>Here comes the snippets from the slides:
<img alt="Quantum centric-supercomputing" src="_images/quantum-centric-supercomputing.png" />
<img alt="workflow_for_simulations" src="_images/workflow_for_simulations.png" />
<img alt="quantum_embedding_in_action" src="_images/quantum_embedding_in_action.png" />
<img alt="adaptVQE" src="_images/adaptVQE.png" />
<img alt="practical_usecase" src="_images/practical_usecase.png" />
<img alt="cp2k_qiskit_integration" src="_images/cp2k_qiskit_integration.png" /></p>
</section>
</section>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading"></a></h3>
</section>
</section>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Vorwerk, C., Sheng, N., Govoni, M., et al. “Quantum embedding theories to simulate condensed systems on quantum computers.” <em>Nature Computational Science</em> <strong>2</strong>, 424–432 (2022). <a class="reference external" href="https://doi.org/10.1038/s43588-022-00279-0">DOI:10.1038/s43588-022-00279-0</a></p>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Multiscale Embedding for Quantum Computing. <em>arXiv preprint</em> arXiv:2409.06813 (2023). <a class="reference external" href="https://arxiv.org/abs/2409.06813">https://arxiv.org/abs/2409.06813</a></p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>Toward practical quantum embedding simulation of realistic chemical systems on near-term quantum computers. <em>Chemical Science</em> <strong>13</strong>, 7311-7324 (2022). <a class="reference external" href="https://pubs.rsc.org/en/content/articlelanding/2022/sc/d2sc01492k">DOI:10.1039/D2SC01492K</a></p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>Quantum Embedding and Quantum Simulations. Galli Group Research. University of Chicago. <a class="reference external" href="https://galligroup.uchicago.edu/Research/embedding.php">https://galligroup.uchicago.edu/Research/embedding.php</a></p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>Quantum Embedding Method for the Simulation of Strongly Correlated Systems on Quantum Computers. <em>arXiv preprint</em> arXiv:2302.03052 (2023). <a class="reference external" href="https://arxiv.org/abs/2302.03052">https://arxiv.org/abs/2302.03052</a></p>
</aside>
</aside>
<span id="document-ihpc"></span><section class="tex2jax_ignore mathjax_ignore" id="quantum-computing-activities-of-ncc-iceland">
<h2>Quantum Computing Activities of NCC Iceland<a class="headerlink" href="#quantum-computing-activities-of-ncc-iceland" title="Link to this heading"></a></h2>
<p><a class="reference download internal" download="" href="_downloads/a108798b2cc839146ac23be7c3e3fc08/IHPC-NCC-Iceland-Quantum-Morris-Riedel.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Slides</span></code></a></p>
</section>
</div>
<div class="toctree-wrapper compound">
</div>
<section id="who-is-the-course-for">
<span id="learner-personas"></span><h2>Who is the course for?<a class="headerlink" href="#who-is-the-course-for" title="Link to this heading"></a></h2>
</section>
<section id="about-the-course">
<h2>About the course<a class="headerlink" href="#about-the-course" title="Link to this heading"></a></h2>
</section>
<section id="see-also">
<h2>See also<a class="headerlink" href="#see-also" title="Link to this heading"></a></h2>
</section>
<section id="credits">
<h2>Credits<a class="headerlink" href="#credits" title="Link to this heading"></a></h2>
<p>The lesson file structure and browsing layout is inspired by and derived from
<a class="reference external" href="https://github.com/coderefinery/sphinx-lesson">work</a> by <a class="reference external" href="https://coderefinery.org/">CodeRefinery</a> licensed under the <a class="reference external" href="http://opensource.org/licenses/mit-license.html">MIT license</a>. We have copied and adapted
most of their license text.</p>
<section id="instructional-material">
<h3>Instructional Material<a class="headerlink" href="#instructional-material" title="Link to this heading"></a></h3>
<p>This instructional material is made available under the
<a class="reference external" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution license (CC-BY-4.0)</a>.
The following is a human-readable summary of (and not a substitute for) the
<a class="reference external" href="https://creativecommons.org/licenses/by/4.0/legalcode">full legal text of the CC-BY-4.0 license</a>.
You are free to:</p>
<ul class="simple">
<li><p><strong>share</strong> - copy and redistribute the material in any medium or format</p></li>
<li><p><strong>adapt</strong> - remix, transform, and build upon the material for any purpose,
even commercially.</p></li>
</ul>
<p>The licensor cannot revoke these freedoms as long as you follow these license terms:</p>
<ul class="simple">
<li><p><strong>Attribution</strong> - You must give appropriate credit (mentioning that your work
is derived from work that is Copyright (c) ENCCS and individual contributors and, where practical, linking
to <a class="reference external" href="https://enccs.github.io/sphinx-lesson-template">https://enccs.github.io/sphinx-lesson-template</a>), provide a <a class="reference external" href="https://creativecommons.org/licenses/by/4.0/">link to the license</a>, and indicate if changes were
made. You may do so in any reasonable manner, but not in any way that suggests
the licensor endorses you or your use.</p></li>
<li><p><strong>No additional restrictions</strong> - You may not apply legal terms or
technological measures that legally restrict others from doing anything the
license permits.</p></li>
</ul>
<p>With the understanding that:</p>
<ul class="simple">
<li><p>You do not have to comply with the license for elements of the material in
the public domain or where your use is permitted by an applicable exception
or limitation.</p></li>
<li><p>No warranties are given. The license may not give you all of the permissions
necessary for your intended use. For example, other rights such as
publicity, privacy, or moral rights may limit how you use the material.</p></li>
</ul>
</section>
<section id="software">
<h3>Software<a class="headerlink" href="#software" title="Link to this heading"></a></h3>
<p>Except where otherwise noted, the example programs and other software provided
with this repository are made available under the <a class="reference external" href="http://opensource.org/">OSI</a>-approved
<a class="reference external" href="https://opensource.org/licenses/mit-license.html">MIT license</a>.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, The contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>