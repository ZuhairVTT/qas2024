

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial - Introduction to Helmi &mdash; Quantum Autumn School 2024  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx_lesson.css?v=e9df6548" />
      <link rel="stylesheet" type="text/css" href="../../_static/term_role_formatting.css?v=4194e21c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx_rtd_theme_ext_color_contrast.css?v=8e8ea19f" />
      <link rel="stylesheet" type="text/css" href="../../_static/overrides.css?v=0572569b" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=187304be"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../_static/minipres.js?v=a0d29692"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script data-domain="enccs.github.io/qas2024" defer="defer" src="https://plausible.io/js/script.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex/" />
    <link rel="search" title="Search" href="../../search/" />
    <link rel="next" title="Introduction to variational quantum algorithms: VQE and QAOA" href="../../qaoa_vqe_intro/" />
    <link rel="prev" title="Introduction to Helmi" href="../../helmi/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../" class="icon icon-home">
            Quantum Autumn School 2024
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Setup</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../setup/">Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 1</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../welcome/">Welcome and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hpc_qc/">Integration of High Performance Computing and Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../helmi/">Introduction to Helmi</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial - Introduction to Helmi</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#estimating-the-ghz-fidelity">Estimating the GHZ fidelity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preparing-the-ghz-circuit">Preparing the GHZ circuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applying-readout-mitigation">Applying readout mitigation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-quantum-coherences">Multiple Quantum Coherences</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#theory">Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preparing-the-mqc-circuits">Preparing the MQC circuits</a></li>
<li class="toctree-l3"><a class="reference internal" href="#with-ideal-backend">With Ideal Backend</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulations-vs-actual-hardware">Simulations vs Actual Hardware</a></li>
<li class="toctree-l3"><a class="reference internal" href="#with-helmi-backend">With Helmi Backend</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../qaoa_vqe_intro/">Introduction to variational quantum algorithms: VQE and QAOA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../QAS2024_QAOA_exercise/">Tutorial - Variational Quantum Algorithms</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 2</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Decoding_excercise/">Tutorial - MAP Decoding Exercise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../css_code_steane/">Tutorial - Fault-Tolerant Quantum Computing with CSS codes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../surface_code_threshold/">Tutorial - Estimating the Surface Code Threshold</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qmc_fin/">Quantum Monte Carlo and quantum finance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../option_pricing/">Pricing a European call option on a quantum computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../option_pricing_tutorial/">Tutorial - Pricing a European call option using quantum computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qsip/">QSIP - Quantum Sweden Innovation Platform</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Day 3</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../flight_scheduling_optimization_qaoa/">Tutorial - Solving Flight Scheduling Optimization using QAOA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qwalks/">Quantum walks on quantum computers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tergite-overview/">Tergite overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cos/">Distributed Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qelm/">Quantum extreme learning machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../matsci_on_qc/README/">Quantum Computing for Materials Science</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ihpc/">Quantum Computing Activities of NCC Iceland</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://enccs.se/lessons/">All ENCCS lessons</a></li>
<li class="toctree-l1"><a class="reference external" href="https://enccs.se/">About ENCCS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../">Quantum Autumn School 2024</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tutorial - Introduction to Helmi</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ENCCS/qas2024/blob/main/content/notebooks/GHZ_Estimator_Attendees.ipynb" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="tutorial-introduction-to-helmi">
<h1>Tutorial - Introduction to Helmi<a class="headerlink" href="#tutorial-introduction-to-helmi" title="Link to this heading"></a></h1>
<section id="estimating-the-ghz-fidelity">
<h2>Estimating the GHZ fidelity<a class="headerlink" href="#estimating-the-ghz-fidelity" title="Link to this heading"></a></h2>
<section id="preparing-the-ghz-circuit">
<h3>Preparing the GHZ circuit<a class="headerlink" href="#preparing-the-ghz-circuit" title="Link to this heading"></a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Importing the required modules</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">iqm.qiskit_iqm</span> <span class="kn">import</span> <span class="n">IQMProvider</span>
<span class="kn">from</span> <span class="nn">iqm.qiskit_iqm.fake_backends</span> <span class="kn">import</span> <span class="n">fake_adonis</span>
<span class="kn">from</span> <span class="nn">iqm.qiskit_iqm.iqm_transpilation</span> <span class="kn">import</span> <span class="n">optimize_single_qubit_gates</span>
<span class="kn">from</span> <span class="nn">qiskit.compiler</span> <span class="kn">import</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">from</span> <span class="nn">qiskit.result</span> <span class="kn">import</span> <span class="n">marginal_counts</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up the Helmi backend</span>
<span class="n">HELMI_CORTEX_URL</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HELMI_CORTEX_URL&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">HELMI_CORTEX_URL</span><span class="p">:</span>
	<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Environment variable HELMI_CORTEX_URL is not set&quot;</span><span class="p">)</span>

<span class="n">provider</span> <span class="o">=</span> <span class="n">IQMProvider</span><span class="p">(</span><span class="n">HELMI_CORTEX_URL</span><span class="p">)</span> 
<span class="n">backend</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span> <span class="c1"># fake_adonis.IQMFakeAdonis()</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Native operations: </span><span class="si">{</span><span class="n">backend</span><span class="o">.</span><span class="n">operation_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of qubits: </span><span class="si">{</span><span class="n">backend</span><span class="o">.</span><span class="n">num_qubits</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coupling map: </span><span class="si">{</span><span class="n">backend</span><span class="o">.</span><span class="n">coupling_map</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">backend</span><span class="o">.</span><span class="n">coupling_map</span><span class="p">)</span>
<span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;QB</span><span class="si">{</span><span class="n">node</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">}</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;skyblue&quot;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us first prepare the GHZ circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simple GHZ circuit</span>
<span class="n">qubits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QB&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span> <span class="c1">#expected equal majority counts of &#39;00000&#39; and &#39;11111&#39;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here is how the circuit will look like if we convert to Helmi’s native gateset.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Optimising for Helmi -&gt; </span>
<span class="n">initial_layout</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">qubit_name_to_index</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span><span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">transpiled_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As the <em>RZ</em> gates commute with the <em>CZ</em> gates, and the measurement is not affected by the final <em>RZ</em> gate, we can optimise those away to decrease the number of gates we perform.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">optimize_single_qubit_gates</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="p">)</span>
<span class="n">transpiled_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">transpiled_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">transpiled_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unmitigated GHZ fidelity =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="s2">&quot;00000&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="s2">&quot;11111&quot;</span><span class="p">])</span><span class="o">/</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="applying-readout-mitigation">
<h3>Applying readout mitigation<a class="headerlink" href="#applying-readout-mitigation" title="Link to this heading"></a></h3>
<p>The code used here was modified from <a class="reference external" href="https://nvidia.github.io/cuda-quantum/latest/applications/python/readout_error_mitigation.html">this tutorial</a> from NVIDIA.</p>
<p>To perform readout mitigation with the minimum number of jobs, we will prepare the <span class="math notranslate nohighlight">\(\mid \! 00000 \rangle\)</span> and <span class="math notranslate nohighlight">\(\mid \! 11111 \rangle\)</span> and see which states we actually measure.</p>
<p>First, we observe how the <span class="math notranslate nohighlight">\(\mid \! 00000 \rangle\)</span> state is not strongly affected by state preparation and measurement (SPAM) errors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QB&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">qc_0s</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="n">qc_0s</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">initial_layout</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">qubit_name_to_index</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="n">qc_0s</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc_0s</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span> <span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_0s</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_0s</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">result_0s</span> <span class="o">=</span> <span class="n">job_0s</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts_0s</span> <span class="o">=</span> <span class="n">result_0s</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts_0s</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we can observe how the <span class="math notranslate nohighlight">\(\mid \! 11111 \rangle\)</span> is much more strongly affected by SPAM error. Part of this comes from the <span class="math notranslate nohighlight">\(\mid \! 1 \rangle\)</span> state relaxing to <span class="math notranslate nohighlight">\(\mid \! 0 \rangle\)</span>, however, the exact ways in which Helmi is calibrated also plays an important role here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QB&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
<span class="n">qc_1s</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">qc_1s</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">qubit</span><span class="p">])</span>
<span class="n">qc_1s</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">initial_layout</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">qubit_name_to_index</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="n">qc_1s</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc_1s</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span> <span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_1s</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_1s</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">result_1s</span> <span class="o">=</span> <span class="n">job_1s</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts_1s</span> <span class="o">=</span> <span class="n">result_1s</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts_1s</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">local_states</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span> <span class="o">*</span> <span class="n">n_qubits</span><span class="p">]</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;00000&quot;</span><span class="p">:</span> <span class="n">result_0s</span><span class="p">,</span> <span class="s2">&quot;11111&quot;</span><span class="p">:</span> <span class="n">result_1s</span><span class="p">}</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">local_states</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> becomes </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">possible_counts</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">local_states</span>
<span class="p">]</span>
<span class="n">matrices</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">marginalized_counts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_shots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">local_states</span><span class="p">:</span>
        <span class="n">marginal_cts</span> <span class="o">=</span> <span class="n">marginal_counts</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
        <span class="n">marginalized_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">marginal_cts</span><span class="p">)</span>
        <span class="n">total_shots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">marginal_cts</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="c1"># matrix[i][j] is the probability of counting i for expected j</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">marginalized_counts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                                                      <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_shots</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We have just prepared the confusion matrices for each of the <span class="math notranslate nohighlight">\(5\)</span> qubits using just <span class="math notranslate nohighlight">\(2\)</span> jobs, which can be used to calculate the confusion matrix for the whole system. This does assume that measurement or doing gates on one qubit does not affect other gates. We could create these confusion matrices using <span class="math notranslate nohighlight">\(2n_{\text{qubits}}\)</span>, or even more properly using <span class="math notranslate nohighlight">\(2^{n_{\text{qubits}}}\)</span> jobs, however, just these <span class="math notranslate nohighlight">\(2\)</span> jobs should suffice.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matrices</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Confusion matrix for QB</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">n_qubits</span><span class="p">)))</span>
<span class="n">states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">label</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">label</span><span class="p">)),</span> <span class="n">labels</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Let us have another look at the counts from the GHZ circuit. We will perform readout error mitigation on it, and hopefully, improve the GHZ state fidelity.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="n">noisy_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span><span class="n">new_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">states</span><span class="p">)])</span>
<span class="n">noisy_counts</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_closest_distribution</span><span class="p">(</span><span class="n">empirical_dist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the closest distribution to an empirical distribution by minimizing the L1 norm.</span>

<span class="sd">    Args:</span>
<span class="sd">        empirical_dist: Empirical distribution that you want to find the closest distribution to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Closest distribution to `empirical_dist`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">empirical_dist</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Constraint: all elements of p must be positive, and the distribution must sum to 1</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ineq&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;eq&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="n">bnds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">empirical_dist</span><span class="p">))]</span>
    <span class="n">initial_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">empirical_dist</span><span class="p">))</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
        <span class="n">objective</span><span class="p">,</span>
        <span class="n">initial_value</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">},</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bnds</span><span class="p">,</span>
        <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_counts_from_distribution</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates samples based on a given distribution and returns the counts of each sample value.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_qubits: The number of qubits in the quantum circuit.</span>
<span class="sd">        dist: The probability distribution from which samples are drawn.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An array of counts for each possible value in the distribution. The array has a length of 2^n_qubits.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_qubits</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Function to draw the confusion matrix</span>
<span class="k">def</span> <span class="nf">plot_cmat</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Reds</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Confusion Matrix&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Prepared State&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Measured State&quot;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>First, we invert the confusion matrix for each individual qubit. Next, we approximate the inverse confusion matrix for Helmi using the tensor product. Now, we can simply apply this to our “noisy” results and we should have mitigated the effects of the readout errors.</p>
<p>As this is a mathematical operation, we can end up with negative counts, which lack any physical meaning. We can find another distribution with all positive values that is similar to our mitigated distribution. We sample this distribution probabilistically to obtain our corrected counts.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pinv_confusion_matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">]</span>
<span class="n">A_pinv</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">,</span> <span class="n">pinv_confusion_matrices</span><span class="p">)</span>
<span class="n">mitigated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A_pinv</span><span class="p">,</span> <span class="n">noisy_counts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mitigated counts:</span><span class="se">\n</span><span class="si">{</span><span class="n">mitigated</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mitigated</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">positive_dist</span> <span class="o">=</span> <span class="n">find_closest_distribution</span><span class="p">(</span><span class="n">mitigated</span> <span class="o">/</span> <span class="n">shots</span><span class="p">)</span>
    <span class="n">mitigated</span> <span class="o">=</span> <span class="n">get_counts_from_distribution</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">shots</span><span class="p">,</span> <span class="n">positive_dist</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Corrected for negative counts:</span><span class="se">\n</span><span class="si">{</span><span class="n">mitigated</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">A_joint</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">,</span> <span class="n">matrices</span><span class="p">)</span>
<span class="n">plot_cmat</span><span class="p">(</span><span class="n">A_joint</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As we can see, the mitigated fidelity is higher than the unmitigated fidelity, at the cost of two more jobs run.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_histogram</span><span class="p">([</span><span class="n">counts</span><span class="p">,</span> <span class="nb">dict</span><span class="p">({</span><span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mitigated</span><span class="p">)})],</span> <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Unmitigated&quot;</span><span class="p">,</span> <span class="s2">&quot;Mitigated&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unmitigated GHZ fidelity =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="s2">&quot;00000&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="s2">&quot;11111&quot;</span><span class="p">])</span><span class="o">/</span><span class="n">shots</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Corrected GHZ fidelity =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">mitigated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mitigated</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="multiple-quantum-coherences">
<h2>Multiple Quantum Coherences<a class="headerlink" href="#multiple-quantum-coherences" title="Link to this heading"></a></h2>
<section id="theory">
<h3>Theory<a class="headerlink" href="#theory" title="Link to this heading"></a></h3>
<p><a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.101.032343">Multiple Quantum Coherences</a> (MQC) offers an alternative way to estimate the GHZ fidelity. It allows us to calculate a lower and upper bound on the GHZ fidelity, as well as calculating the exact GHZ fidelity if run alongside a GHZ circuit.</p>
<p>MQC works by utilising phase kickback, a highly versatile tool used in many algorithms to “kick” a phase from a target qubit “back” to a control qubit. First, we prepare a <span class="math notranslate nohighlight">\(N\)</span>-qubit GHZ state, and then we apply a phase <span class="math notranslate nohighlight">\(\phi\)</span> to all <span class="math notranslate nohighlight">\(N\)</span> qubits. Then, we “undo” the GHZ state, and this “kicksback” the phase to the control qubit, applying a phase shift of <span class="math notranslate nohighlight">\(N\phi\)</span> to the control qubit.</p>
<p>To help explain this more easily, I will quote the paper directly here.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Starting from the <span class="math notranslate nohighlight">\(N\)</span>-qubit ground state: <span class="math notranslate nohighlight">\(\mid \! GS \rangle = \mid \! 000..00 \rangle\)</span>, apply a Hadamard gate on qubit <span class="math notranslate nohighlight">\(0\)</span> followed by a sequence of <em>CX</em> gates. Ideally this brings the system into the GHZ state: <span class="math notranslate nohighlight">\(\mid \! GHZ \rangle = \tfrac 1{\sqrt 2} \left( \mid \! 000..00 \rangle + \mid \! 111..11 \rangle\right)\)</span></p></li>
<li><p>Apply a collective rotation given by the unitary <span class="math notranslate nohighlight">\(U_{\phi}\)</span> on all qubits. This amounts to adding a phase <span class="math notranslate nohighlight">\(N\phi\)</span> to the GHZ state: <span class="math notranslate nohighlight">\(\tfrac 1{\sqrt 2} \left( \mid \! 000..00 \rangle + e^{-iN\phi}\mid \! 111..11 \rangle\right)\)</span></p></li>
<li><p>Disentangle the GHZ state by performing the <em>CX</em> gate sequence in reverse order. The amplified phase is mapped onto qubit <span class="math notranslate nohighlight">\(0\)</span>: <span class="math notranslate nohighlight">\(\tfrac 1{\sqrt 2} \left( \mid \! 000..00 \rangle + e^{-iN\phi}\mid \! 111..11 \rangle\right) \otimes \mid \! 00..00 \rangle\)</span></p></li>
<li><p>Read out the amplified phase by measuring the probability of the system returning to its initial state: \mid ! GS \rangle</p></li>
</ol>
<p>The measured signal of this protocol is given by <span class="math notranslate nohighlight">\(S_\phi = \left| \langle 000..00 \! \mid \! U^{\dagger}_{GHZ} U_{\phi} U_{GHZ} \! \mid \! 000..00 \rangle \right|^2 = Tr(\rho_\phi\rho)\)</span> where <span class="math notranslate nohighlight">\(\rho = U_{GHZ} \! \mid \! GS \rangle \langle GS \! \mid \! U^{\dagger}_{GHZ}\)</span>, <span class="math notranslate nohighlight">\(U_{GHZ} = U_{CZ}H_0\)</span>, and <span class="math notranslate nohighlight">\(\rho_\phi = U_{\phi}\rho U^{\dagger}_{\phi}\)</span>.</p>
</div></blockquote>
<p>If we run this on a noiseless quantum computer, we expect <span class="math notranslate nohighlight">\(S_{\phi} = \tfrac 12(1 + \cos(N\phi))\)</span>. We can then measure <span class="math notranslate nohighlight">\(S_{\phi}\)</span> for multiple angles <span class="math notranslate nohighlight">\(\phi\)</span>, and then perform a Fourier transform to find which frequency our <span class="math notranslate nohighlight">\(S_{\phi}\)</span> actually corresponds to.</p>
<div class="math notranslate nohighlight">
\[I_q=\mathcal{N}^{-1}\left|\sum_\phi e^{i q \phi} S_\phi\right|\]</div>
<p>Ideally, it should be completely dependent on <span class="math notranslate nohighlight">\(N\)</span>, and have no reliance on any of the other frequencies - however, due to noise, we shall get a spread of frequencies with varying amplitudes. We can then use these to estimate the lower and upper bounds of the GHZ fidelity.</p>
<div class="math notranslate nohighlight">
\[2 \sqrt{I_N} \leq F \leq \sqrt{I_0 / 2}+\sqrt{I_N}\]</div>
</section>
<section id="preparing-the-mqc-circuits">
<h3>Preparing the MQC circuits<a class="headerlink" href="#preparing-the-mqc-circuits" title="Link to this heading"></a></h3>
<p>First, let us define a parametrised circuit for the MQC experiment. Developed based on the original paper.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mqc_circuit</span><span class="p">(</span><span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="n">qubits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QB&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
    <span class="n">mqc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">mqc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="c1"># We will comment out this line later</span>
        <span class="n">mqc</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">mqc</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mqc</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we define which <span class="math notranslate nohighlight">\(\phi\)</span> to sweep over, and how many shots to execute for each circuit. We need a minimum of <span class="math notranslate nohighlight">\(12\)</span> experiments here, so that our Fourier transform can detect frequencies upto <span class="math notranslate nohighlight">\(6\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_exp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_qubits</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">j</span> <span class="o">/</span> <span class="n">n_exp</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_exp</span><span class="p">)]</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">16_384</span>
</pre></div>
</div>
</div>
</div>
<p>The parameterized circuits are collected in a list <code class="docutils literal notranslate"><span class="pre">mqc_circuits</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mqc_circuits</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
    <span class="n">mqc</span> <span class="o">=</span> <span class="n">mqc_circuit</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>    
    <span class="n">mqc_circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mqc</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us observe how the untranspiled circuit looks.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mqc_circuits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Before running, we transpile each circuit to the native gate set and map the logical qubits to the physical qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initial_layout</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend</span><span class="o">.</span><span class="n">qubit_name_to_index</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;QB1&quot;</span><span class="p">,</span> <span class="s2">&quot;QB2&quot;</span><span class="p">,</span> <span class="s2">&quot;QB3&quot;</span><span class="p">,</span> <span class="s2">&quot;QB4&quot;</span><span class="p">,</span> <span class="s2">&quot;QB5&quot;</span><span class="p">]]</span>

<span class="n">fidelity_circuits</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">mqc_circuits</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span><span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">fidelity_circuits</span> <span class="o">=</span> <span class="n">optimize_single_qubit_gates</span><span class="p">(</span><span class="n">fidelity_circuits</span><span class="p">)</span>
<span class="n">fidelity_circuits</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">fidelity_circuits</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span><span class="o">=</span> <span class="n">initial_layout</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s have a look at the transpiled circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fidelity_circuits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="with-ideal-backend">
<h3>With Ideal Backend<a class="headerlink" href="#with-ideal-backend" title="Link to this heading"></a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fake_backend</span> <span class="o">=</span> <span class="n">fake_adonis</span><span class="o">.</span><span class="n">IQMFakeAdonis</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fake_jobs</span> <span class="o">=</span> <span class="n">fake_backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fidelity_circuits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fake_results</span> <span class="o">=</span> <span class="n">fake_jobs</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">fake_counts</span> <span class="o">=</span> <span class="n">fake_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_histogram</span><span class="p">(</span><span class="n">fake_counts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>After running the circuit, we should only have the states <span class="math notranslate nohighlight">\(\mid \! 00000 \rangle\)</span> and <span class="math notranslate nohighlight">\(\mid \! 00100 \rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fake_outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">fake_count</span><span class="p">[</span><span class="s1">&#39;00000&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">fake_count</span><span class="p">[</span><span class="s1">&#39;00000&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">fake_count</span><span class="p">[</span><span class="s1">&#39;00100&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">fake_count</span> <span class="ow">in</span> <span class="n">fake_counts</span><span class="p">]</span> <span class="c1"># (fake_count[&#39;00000&#39;] + fake_count[&#39;00100&#39;])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">all_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">10_000</span><span class="p">)</span>
<span class="n">expected_fidelity</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">n_qubits</span> <span class="o">*</span> <span class="n">j</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">all_angles</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">fake_outcomes</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Fake&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">all_angles</span><span class="p">,</span> <span class="n">expected_fidelity</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Expected&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Angle $(\phi)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$S_{\phi}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I_0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">I_n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="n">I_0</span> <span class="o">+=</span> <span class="n">fake_outcomes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">I_n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">n_qubits</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">fake_outcomes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">I_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_0</span> <span class="o">/</span> <span class="n">n_exp</span><span class="p">)</span>
<span class="n">I_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_n</span> <span class="o">/</span> <span class="n">n_exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lower bound for MQC fidelity = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_n</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Upper bound for MQC fidelity = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_n</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="simulations-vs-actual-hardware">
<h3>Simulations vs Actual Hardware<a class="headerlink" href="#simulations-vs-actual-hardware" title="Link to this heading"></a></h3>
<p>Let us now rerun this, but comment out the <code class="docutils literal notranslate"><span class="pre">mqc.x(qubit)</span></code> line at the very start of the circuit. Similarly, try changing the <code class="docutils literal notranslate"><span class="pre">n_exp</span></code> to a higher value. What changes do you observe?</p>
<details>
  <summary>Spoiler warning</summary>
<p>We should not observe any significant changes in the fidelity estimates for the simulator. However, we will now see how this changes when we run on actual hardware.</p>
</details>
</section>
<section id="with-helmi-backend">
<h3>With Helmi Backend<a class="headerlink" href="#with-helmi-backend" title="Link to this heading"></a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jobs</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">fidelity_circuits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jobs</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mqc_results</span> <span class="o">=</span> <span class="n">jobs</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">mqc_counts</span> <span class="o">=</span> <span class="n">mqc_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mqc_results</span><span class="o">.</span><span class="n">timestamps</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_histogram</span><span class="p">(</span><span class="n">mqc_counts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mqc_count</span><span class="p">[</span><span class="s1">&#39;00000&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">mqc_count</span><span class="p">[</span><span class="s1">&#39;00000&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">mqc_count</span><span class="p">[</span><span class="s1">&#39;00100&#39;</span><span class="p">])</span>  <span class="k">for</span> <span class="n">mqc_count</span> <span class="ow">in</span> <span class="n">mqc_counts</span><span class="p">]</span> <span class="c1"># (mqc_count[&#39;00000&#39;] + mqc_count[&#39;00100&#39;])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">all_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">10_000</span><span class="p">)</span>
<span class="n">expected_fidelity</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">n_qubits</span> <span class="o">*</span> <span class="n">i</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_angles</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">fake_outcomes</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">outcomes</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Experimental&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">all_angles</span><span class="p">,</span> <span class="n">expected_fidelity</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Expected&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Angle $(\phi)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$S_{\phi}$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I_0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">I_n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="n">I_0</span> <span class="o">+=</span> <span class="n">outcomes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">I_n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">n_qubits</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">outcomes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">I_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_0</span> <span class="o">/</span> <span class="n">n_exp</span><span class="p">)</span>
<span class="n">I_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I_n</span> <span class="o">/</span> <span class="n">n_exp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lower bound for MQC fidelity = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_n</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Upper bound for MQC fidelity = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I_n</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<p>What we observe is that removing the <span class="math notranslate nohighlight">\(X\)</span> gates results in a noticeable phase shift in the results, even though it should technically not matter. The presenter’s hypothesis is that this phenomenon is related to qubit relaxation, which causes the state <span class="math notranslate nohighlight">\(\mid \! 00000\rangle\)</span> to dominate over <span class="math notranslate nohighlight">\(\mid  \! 11111\rangle\)</span>, even though they should be even. Consequently, applying the <span class="math notranslate nohighlight">\(X\)</span> gates inverts this distribution, and further relaxation should lead to a more balanced ratio of these states. An analogy can be drawn to the Hahn-Echo experiment, where a <span class="math notranslate nohighlight">\(Z\)</span> gate can help cancel out some of the dephasing effects.</p>
<p>Furthermore, running more experiments provides a higher fidelity. The presenter hypothesises that this can be attributed to the noise after the Fourier transform being spread out over more frequencies, leading to improved results. We are not changing the experiment - just collecting additional data to help average out errors.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../../helmi/" class="btn btn-neutral float-left" title="Introduction to Helmi" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../qaoa_vqe_intro/" class="btn btn-neutral float-right" title="Introduction to variational quantum algorithms: VQE and QAOA" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, The contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>